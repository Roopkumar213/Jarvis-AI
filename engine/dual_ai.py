# Add two numbers

a = int(input("Enter first number: "))
b = int(input("Enter second number: "))

sum = a + b

print("The sum is:", sum)
import subprocess
import pyautogui
import time
from datetime import datetime

def ai_dj_mode_enhanced(command=""):
    try:
        if not command:
            return start_dj_session()
        
        command_lower = command.lower()
        if "party" in command_lower or "upbeat" in command_lower:
            return dj_party_mode()
        elif "chill" in command_lower or "relax" in command_lower:
            return dj_chill_mode()
        elif "focus" in command_lower or "work" in command_lower:
            return dj_focus_mode()
        elif "stop" in command_lower or "off" in command_lower:
            return stop_dj_session()
        else:
            return ai_music_selection(command)
    except Exception as e:
        return f"DJ mode error: {str(e)}"

def start_dj_session():
    try:
        current_hour = datetime.now().hour
        if 6 <= current_hour <= 12:
            return dj_focus_mode()
        elif 13 <= current_hour <= 18:
            return dj_auto_mode()
        elif 19 <= current_hour <= 23:
            return dj_party_mode()
        else:
            return dj_chill_mode()
    except Exception as e:
        return f"DJ session error: {str(e)}"

def dj_party_mode():
    try:
        subprocess.run('start chrome https://www.youtube.com', shell=True)
        time.sleep(3)
        pyautogui.click(640, 100)  # Search box
        time.sleep(1)
        pyautogui.typewrite('party music mix 2024')
        pyautogui.press('enter')
        time.sleep(3)
        pyautogui.click(320, 300)  # First video
        time.sleep(2)
        return "AI DJ: Party mode activated! Playing YouTube party mix"
    except Exception as e:
        return f"Party mode error: {str(e)}"

def dj_chill_mode():
    try:
        subprocess.run('start chrome https://www.youtube.com', shell=True)
        time.sleep(3)
        pyautogui.click(640, 100)
        time.sleep(1)
        pyautogui.typewrite('lofi hip hop study chill music')
        pyautogui.press('enter')
        time.sleep(3)
        pyautogui.click(320, 300)
        time.sleep(2)
        return "AI DJ: Chill mode activated! Playing YouTube lofi mix"
    except Exception as e:
        return f"Chill mode error: {str(e)}"

def dj_focus_mode():
    try:
        subprocess.run('start chrome https://www.youtube.com', shell=True)
        time.sleep(3)
        pyautogui.click(640, 100)
        time.sleep(1)
        pyautogui.typewrite('focus music instrumental ambient study')
        pyautogui.press('enter')
        time.sleep(3)
        pyautogui.click(320, 300)
        time.sleep(2)
        return "AI DJ: Focus mode activated! Playing YouTube focus music"
    except Exception as e:
        return f"Focus mode error: {str(e)}"

def dj_auto_mode():
    try:
        playlists = ['top hits 2024', 'pop music mix', 'rock classics', 'indie music', 'electronic dance']
        import random
        playlist = random.choice(playlists)
        
        subprocess.run('start chrome https://www.youtube.com', shell=True)
        time.sleep(3)
        pyautogui.click(640, 100)
        time.sleep(1)
        pyautogui.typewrite(playlist)
        pyautogui.press('enter')
        time.sleep(3)
        pyautogui.click(320, 300)
        time.sleep(2)
        return f"AI DJ: Auto mode activated! Playing YouTube {playlist}"
    except Exception as e:
        return f"Auto mode error: {str(e)}"

def ai_music_selection(request):
    try:
        subprocess.run('start chrome https://www.youtube.com', shell=True)
        time.sleep(3)
        pyautogui.click(640, 100)
        time.sleep(1)
        pyautogui.typewrite(request[:50])
        pyautogui.press('enter')
        time.sleep(3)
        pyautogui.click(320, 300)
        time.sleep(2)
        return f"AI DJ: Playing YouTube {request}"
    except Exception as e:
        return f"Music selection error: {str(e)}"

def stop_dj_session():
    try:
        pyautogui.press('space')
        return "AI DJ: Session ended. Music paused."
    except Exception as e:
        return f"Stop DJ error: {str(e)}"
def try_all_ai_providers(prompt, system_prompt="", messages=None):
    """Try Groq -> Gemini -> Ollama in order"""
    
    # Try Groq first
    try:
        from engine.dual_ai import dual_ai
        if hasattr(dual_ai, 'groq_client'):
            response = dual_ai.groq_client.chat.completions.create(
                model="llama-3.1-8b-instant",
                messages=messages or [{"role": "user", "content": prompt}],
                temperature=0.4
            )
            return response.choices[0].message.content.strip()
    except Exception as e:
        print(f"Groq failed: {e}")
    
    # Try Gemini second
    try:
        from engine.dual_ai import dual_ai
        if hasattr(dual_ai, 'gemini_model'):
            response = dual_ai.gemini_model.generate_content(prompt)
            return response.text.strip()
    except Exception as e:
        print(f"Gemini failed: {e}")
    
 
    # All failed
    return None
import threading
import time
import numpy as np

class AmbientAwareness:
    def __init__(self):
        self.active = False
        self.thread = None
        
    def start(self):
        """Start ambient sound detection"""
        if self.active:
            return "Ambient awareness already running"
        
        try:
            import pyaudio
            
            self.active = True
            
            def listen_background():
                try:
                    # Audio config
                    CHUNK = 1024
                    FORMAT = pyaudio.paInt16
                    CHANNELS = 1
                    RATE = 44100
                    THRESHOLD = 5  # Very low threshold for sensitive detection
                    
                    p = pyaudio.PyAudio()
                    stream = p.open(format=FORMAT, channels=CHANNELS, rate=RATE, 
                                  input=True, frames_per_buffer=CHUNK)
                    
                    doorbell_count = 0
                    alarm_count = 0
                    crying_count = 0
                    
                    while self.active:
                        try:
                            data = stream.read(CHUNK, exception_on_overflow=False)
                            audio_data = np.frombuffer(data, dtype=np.int16)
                            # Fix volume calculation
                            mean_square = np.mean(audio_data.astype(np.float64)**2)
                            volume = np.sqrt(max(0, mean_square)) if mean_square > 0 else 0
                            
                            if volume > THRESHOLD:
                                high_freq = np.mean(np.abs(audio_data[audio_data > np.mean(audio_data)]))
                                
                                # Doorbell (short, high-pitched)
                                if high_freq > 50 and volume > 20:
                                    doorbell_count += 1
                                    if doorbell_count >= 3:
                                        self._alert("Doorbell detected! Someone is at the door.")
                                        doorbell_count = 0
                                        time.sleep(5)
                                
                                # Alarm (sustained loud)
                                elif volume > 30:
                                    alarm_count += 1
                                    if alarm_count >= 5:
                                        self._alert("Alarm detected! Please check for emergencies.")
                                        alarm_count = 0
                                        time.sleep(10)
                                
                                # Baby crying (variable pitch)
                                elif 20 < high_freq < 100 and volume > 15:
                                    crying_count += 1
                                    if crying_count >= 5:
                                        self._alert("Baby crying detected! The baby may need attention.")
                                        crying_count = 0
                                        time.sleep(15)
                                
                                # General sound detection
                                elif volume > 10:
                                    print(f"Sound: Vol={volume:.1f}, Freq={high_freq:.1f}")
                            
                            # Reset counters gradually
                            if volume < THRESHOLD:
                                doorbell_count = max(0, doorbell_count - 1)
                                alarm_count = max(0, alarm_count - 1)
                                crying_count = max(0, crying_count - 1)
                            
                            # Debug output for testing
                            if volume > 2:
                                print(f"Audio: {volume:.1f}", end=" ", flush=True)
                            
                            time.sleep(0.1)
                            
                        except Exception as e:
                            continue
                    
                    stream.stop_stream()
                    stream.close()
                    p.terminate()
                    
                except Exception as e:
                    self.active = False
            
            self.thread = threading.Thread(target=listen_background, daemon=True)
            self.thread.start()
            
            return "Ambient awareness started - listening for doorbell, alarms, baby crying"
            
        except ImportError:
            return "PyAudio not installed. Run: pip install pyaudio numpy"
        except Exception as e:
            return f"Failed to start: {str(e)}"
    
    def stop(self):
        """Stop ambient detection"""
        self.active = False
        if self.thread:
            self.thread.join(timeout=2)
        return "Ambient awareness stopped"
    
    def status(self):
        """Get status"""
        return f"Ambient awareness: {'Active' if self.active else 'Inactive'}"
    
    def _alert(self, message):
        """Alert user"""
        print(f"üîä AMBIENT ALERT: {message}")
        
        try:
            from engine.features import speak
            speak(message)
        except:
            pass

# Global instance
ambient_awareness = AmbientAwareness()
import os
import re
from pathlib import Path
from typing import Dict, List, Tuple, Optional

class AutoCodeArchitect:
    def __init__(self):
        self.desktop_path = Path.home() / "Desktop"
    
    def detect_request_type(self, query: str) -> Dict:
        query_lower = query.lower()
        
        language = self._detect_language(query_lower)
        project_type = self._detect_project_type(query_lower)
        project_name = self._extract_project_name(query)
        
        return {
            'language': language,
            'project_type': project_type,
            'project_name': project_name,
            'original_query': query
        }
    
    def _detect_language(self, query: str) -> str:
        query_lower = query.lower()
        if any(word in query_lower for word in ['python', 'flask', 'django', 'fastapi']):
            return 'python'
        elif any(word in query_lower for word in ['javascript', 'js', 'node', 'react', 'vue', 'angular']):
            return 'javascript'
        elif any(word in query_lower for word in ['java', 'spring']):
            return 'java'
        elif any(word in query_lower for word in ['c#', 'csharp', '.net']):
            return 'csharp'
        elif any(word in query_lower for word in ['php', 'laravel']):
            return 'php'
        elif any(word in query_lower for word in ['html', 'css', 'static']):
            return 'html'
        else:
            return 'python'
    
    def _detect_project_type(self, query: str) -> str:
        query_lower = query.lower()
        if any(phrase in query_lower for phrase in ['only html', 'html and css', 'static', 'frontend only']):
            return 'static'
        elif any(word in query_lower for word in ['react', 'vue', 'angular']):
            return 'spa'
        elif any(word in query_lower for word in ['api', 'rest', 'microservice']):
            return 'api'
        elif any(word in query_lower for word in ['desktop', 'gui', 'tkinter', 'electron']):
            return 'desktop'
        elif any(word in query_lower for word in ['mobile', 'android', 'ios']):
            return 'mobile'
        else:
            return 'web'
    
    def _extract_project_name(self, query: str) -> str:
        # Extract everything after 'generate code' or similar commands
        patterns = [
            r'generate\s+code\s+(.+?)(?:\s+using|\s+with|\s+in|$)',
            r'create\s+(?:a\s+)?(.+?)(?:\s+using|\s+with|\s+in|$)',
            r'build\s+(?:a\s+)?(.+?)(?:\s+using|\s+with|\s+in|$)',
            r'make\s+(?:a\s+)?(.+?)(?:\s+using|\s+with|\s+in|$)'
        ]
        
        for pattern in patterns:
            match = re.search(pattern, query, re.IGNORECASE)
            if match:
                name = match.group(1).strip()
                # Clean up the name
                name = re.sub(r'\b(app|application|project|system)\b', '', name, flags=re.IGNORECASE).strip()
                # Convert to title case and remove spaces
                name = ''.join(word.capitalize() for word in name.split())
                if name and len(name) > 2:
                    return name[:20] + 'App'
        
        # If no pattern matches, use the whole query after 'generate code'
        if 'generate code' in query.lower():
            name = query.lower().replace('generate code', '').strip()
            name = ''.join(word.capitalize() for word in name.split())
            if name:
                return name[:20] + 'App'
        
        return 'JarvisProject'
    
    def generate_code(self, request_info: Dict) -> Dict:
        return self._generate_project(request_info)
    
    def _generate_project(self, request_info: Dict) -> Dict:
        language = request_info['language']
        project_type = request_info['project_type']
        project_name = request_info['project_name']
        
        files = self._generate_project_files(request_info)
        
        return {
            'type': 'project',
            'project_name': project_name,
            'files': files,
            'language': language,
            'project_type': project_type
        }
    
    def _generate_project_files(self, request_info: Dict) -> Dict:
        files = {}
        language = request_info['language']
        project_type = request_info['project_type']
        project_name = request_info['project_name']
        
        files['README.md'] = self._generate_readme(project_name, project_type, language)
        
        if project_type == 'static' or language == 'html':
            files['index.html'] = self._generate_static_html(project_name, request_info['original_query'])
            files['style.css'] = self._generate_static_css()
            files['script.js'] = self._generate_static_js(project_name)
        elif language == 'javascript':
            files['server.js'] = self._generate_main_code(request_info)
            files['package.json'] = self._generate_package_json(project_name)
            if project_type != 'api':
                files['public/index.html'] = self._generate_html_template(project_name, request_info['original_query'])
                files['public/style.css'] = self._generate_css_styles()
        elif language == 'java':
            files['Main.java'] = self._generate_main_code(request_info)
            files['pom.xml'] = self._generate_maven_pom(project_name)
        elif language == 'csharp':
            files['Program.cs'] = self._generate_main_code(request_info)
            files[f'{project_name}.csproj'] = self._generate_csproj(project_name)
        elif language == 'php':
            files['index.php'] = self._generate_main_code(request_info)
            files['composer.json'] = self._generate_composer_json(project_name)
        elif language == 'python':
            files['app.py'] = self._generate_main_code(request_info)
            files['requirements.txt'] = self._generate_requirements(project_type)
            if project_type == 'web':
                files['templates/index.html'] = self._generate_html_template(project_name, request_info['original_query'])
                files['static/style.css'] = self._generate_css_styles()
        else:
            files['app.py'] = self._generate_main_code(request_info)
        
        return files
    
    def _generate_main_code(self, request_info: Dict) -> str:
        language = request_info['language']
        project_type = request_info['project_type']
        project_name = request_info['project_name']
        query = request_info['original_query']
        
        if language == 'python':
            return self._generate_python_code(project_name, query, project_type)
        elif language == 'javascript':
            return self._generate_javascript_code(project_name, query, project_type)
        elif language == 'java':
            return self._generate_java_code(project_name, query, project_type)
        elif language == 'csharp':
            return self._generate_csharp_code(project_name, query, project_type)
        elif language == 'php':
            return self._generate_php_code(project_name, query, project_type)
        else:
            return self._generate_python_code(project_name, query, project_type)
    
    def _generate_python_code(self, project_name: str, query: str = '', project_type: str = 'web') -> str:
        return self._generate_advanced_python_app(project_name, query, project_type)
    
    def _python_flask_app(self, project_name: str, query: str = '') -> str:
        # Generate code based on project name/type
        query_and_name = (query + ' ' + project_name).lower()
        
        if 'calculator' in query_and_name:
            return '''from flask import Flask, render_template, request, jsonify

app = Flask(__name__)

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/calculate', methods=['POST'])
def calculate():
    try:
        data = request.json
        num1 = float(data['num1'])
        num2 = float(data['num2'])
        operation = data['operation']
        
        if operation == '+':
            result = num1 + num2
        elif operation == '-':
            result = num1 - num2
        elif operation == '*':
            result = num1 * num2
        elif operation == '/':
            result = num1 / num2 if num2 != 0 else "Cannot divide by zero"
        else:
            result = "Invalid operation"
            
        return jsonify({'result': result})
    except Exception as e:
        return jsonify({'error': str(e)})

if __name__ == '__main__':
    app.run(debug=True)
'''
        elif 'library' in query.lower() and 'management' in query.lower():
            return '''from flask import Flask, render_template, request, redirect, url_for, session, flash
import sqlite3
from datetime import datetime, date, timedelta

app = Flask(__name__)
app.secret_key = 'library_secret'

def init_db():
    conn = sqlite3.connect('library.db')
    c = conn.cursor()
    
    # Create users table
    c.execute("""CREATE TABLE IF NOT EXISTS users
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  username TEXT UNIQUE NOT NULL,
                  password TEXT NOT NULL,
                  role TEXT DEFAULT 'user',
                  name TEXT NOT NULL)""")
    
    # Create books table
    c.execute("""CREATE TABLE IF NOT EXISTS books
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  title TEXT NOT NULL,
                  author TEXT NOT NULL,
                  isbn TEXT UNIQUE,
                  category TEXT,
                  total_copies INTEGER DEFAULT 1,
                  available_copies INTEGER DEFAULT 1)""")
    
    # Create issued_books table
    c.execute("""CREATE TABLE IF NOT EXISTS issued_books
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  book_id INTEGER,
                  user_id INTEGER,
                  issue_date TEXT NOT NULL,
                  due_date TEXT NOT NULL,
                  return_date TEXT,
                  status TEXT DEFAULT 'issued')""")
    
    # Insert sample data
    c.execute("INSERT OR IGNORE INTO users (username, password, role, name) VALUES (?, ?, ?, ?)", 
              ('admin', 'admin123', 'admin', 'Administrator'))
    c.execute("INSERT OR IGNORE INTO users (username, password, role, name) VALUES (?, ?, ?, ?)", 
              ('user1', 'user123', 'user', 'John Doe'))
    c.execute("INSERT OR IGNORE INTO books (title, author, isbn, category, total_copies, available_copies) VALUES (?, ?, ?, ?, ?, ?)", 
              ('Python Programming', 'John Smith', '978-0123456789', 'Programming', 5, 5))
    
    conn.commit()
    conn.close()

@app.route('/')
def login():
    return render_template('index.html')

@app.route('/login', methods=['POST'])
def do_login():
    username = request.form['username']
    password = request.form['password']
    conn = sqlite3.connect('library.db')
    c = conn.cursor()
    c.execute('SELECT * FROM users WHERE username = ? AND password = ?', (username, password))
    user = c.fetchone()
    conn.close()
    if user:
        session['user_id'] = user[0]
        session['username'] = user[1]
        session['role'] = user[3]
        return redirect('/dashboard')
    return redirect('/')

@app.route('/dashboard')
def dashboard():
    if 'user_id' not in session:
        return redirect('/')
    conn = sqlite3.connect('library.db')
    c = conn.cursor()
    search = request.args.get('search', '')
    sort_by = request.args.get('sort', 'title')
    query = 'SELECT * FROM books WHERE available_copies > 0'
    params = []
    if search:
        query += ' AND (title LIKE ? OR author LIKE ?)'
        params.extend([f'%{search}%', f'%{search}%'])
    if sort_by in ['title', 'author', 'category']:
        query += f' ORDER BY {sort_by}'
    c.execute(query, params)
    books = c.fetchall()
    conn.close()
    return render_template('dashboard.html', books=books, search=search, sort_by=sort_by)

@app.route('/issue/<int:book_id>')
def issue_book(book_id):
    if 'user_id' not in session:
        return redirect('/')
    conn = sqlite3.connect('library.db')
    c = conn.cursor()
    c.execute('SELECT available_copies FROM books WHERE id = ?', (book_id,))
    book = c.fetchone()
    if book and book[0] > 0:
        issue_date = date.today().strftime('%Y-%m-%d')
        due_date = (date.today() + timedelta(days=14)).strftime('%Y-%m-%d')
        c.execute('INSERT INTO issued_books (book_id, user_id, issue_date, due_date) VALUES (?, ?, ?, ?)', 
                  (book_id, session['user_id'], issue_date, due_date))
        c.execute('UPDATE books SET available_copies = available_copies - 1 WHERE id = ?', (book_id,))
        conn.commit()
    conn.close()
    return redirect('/dashboard')

@app.route('/return/<int:issue_id>')
def return_book(issue_id):
    if 'user_id' not in session:
        return redirect('/')
    conn = sqlite3.connect('library.db')
    c = conn.cursor()
    c.execute('SELECT book_id FROM issued_books WHERE id = ? AND user_id = ?', (issue_id, session['user_id']))
    result = c.fetchone()
    if result:
        book_id = result[0]
        return_date = date.today().strftime('%Y-%m-%d')
        c.execute('UPDATE issued_books SET return_date = ?, status = "returned" WHERE id = ?', (return_date, issue_id))
        c.execute('UPDATE books SET available_copies = available_copies + 1 WHERE id = ?', (book_id,))
        conn.commit()
    conn.close()
    return redirect('/dashboard')

if __name__ == '__main__':
    init_db()
    app.run(debug=True)
'''
        elif 'student' in query.lower() and 'management' in query.lower():
            return '''from flask import Flask, render_template, request, redirect, url_for, flash
import sqlite3
from datetime import datetime

app = Flask(__name__)
app.secret_key = 'student_secret'

def init_db():
    conn = sqlite3.connect('students.db')
    c = conn.cursor()
    c.execute("""CREATE TABLE IF NOT EXISTS students
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  student_id TEXT UNIQUE,
                  name TEXT NOT NULL,
                  email TEXT,
                  course TEXT,
                  year INTEGER,
                  gpa REAL DEFAULT 0.0)""")
    conn.commit()
    conn.close()

@app.route('/')
def dashboard():
    conn = sqlite3.connect('students.db')
    c = conn.cursor()
    c.execute('SELECT * FROM students ORDER BY name')
    students = c.fetchall()
    conn.close()
    return render_template('index.html', students=students)

@app.route('/add', methods=['POST'])
def add_student():
    conn = sqlite3.connect('students.db')
    c = conn.cursor()
    c.execute('INSERT INTO students (student_id, name, email, course, year, gpa) VALUES (?, ?, ?, ?, ?, ?)',
             (request.form['student_id'], request.form['name'], request.form['email'],
              request.form['course'], int(request.form['year']), float(request.form['gpa'])))
    conn.commit()
    conn.close()
    return redirect('/')

if __name__ == '__main__':
    init_db()
    app.run(debug=True)
'''
        elif 'todo' in query.lower():
            return '''from flask import Flask, render_template, request, redirect, url_for
import sqlite3
from datetime import datetime

app = Flask(__name__)

def init_db():
    conn = sqlite3.connect('todo.db')
    c = conn.cursor()
    c.execute("""CREATE TABLE IF NOT EXISTS tasks
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  title TEXT NOT NULL,
                  description TEXT,
                  priority TEXT DEFAULT 'medium',
                  status TEXT DEFAULT 'pending',
                  created_date TEXT)""")
    conn.commit()
    conn.close()

@app.route('/')
def index():
    conn = sqlite3.connect('todo.db')
    c = conn.cursor()
    c.execute('SELECT * FROM tasks ORDER BY priority DESC')
    tasks = c.fetchall()
    conn.close()
    return render_template('index.html', tasks=tasks)

@app.route('/add', methods=['POST'])
def add_task():
    conn = sqlite3.connect('todo.db')
    c = conn.cursor()
    c.execute('INSERT INTO tasks (title, description, priority, created_date) VALUES (?, ?, ?, ?)',
             (request.form['title'], request.form['description'], 
              request.form['priority'], datetime.now().strftime('%Y-%m-%d')))
    conn.commit()
    conn.close()
    return redirect('/')

if __name__ == '__main__':
    init_db()
    app.run(debug=True)
'''
        else:
            # Generate advanced Flask app based on detailed user requirements
            return self._generate_advanced_flask_app(project_name, query)
    
    def _generate_html_template(self, project_name: str, query: str = '') -> str:
        if 'calculator' in query.lower():
            return '''<!DOCTYPE html>
<html>
<head>
    <title>Calculator App</title>
    <link rel="stylesheet" href="/static/style.css">
</head>
<body>
    <div class="calculator">
        <h1>Calculator</h1>
        <div class="display">
            <input type="text" id="result" readonly>
        </div>
        <div class="buttons">
            <button onclick="clearDisplay()">C</button>
            <button onclick="appendToDisplay('/')">/</button>
            <button onclick="appendToDisplay('*')">*</button>
            <button onclick="deleteLast()">‚Üê</button>
            
            <button onclick="appendToDisplay('7')">7</button>
            <button onclick="appendToDisplay('8')">8</button>
            <button onclick="appendToDisplay('9')">9</button>
            <button onclick="appendToDisplay('-')">-</button>
            
            <button onclick="appendToDisplay('4')">4</button>
            <button onclick="appendToDisplay('5')">5</button>
            <button onclick="appendToDisplay('6')">6</button>
            <button onclick="appendToDisplay('+')">+</button>
            
            <button onclick="appendToDisplay('1')">1</button>
            <button onclick="appendToDisplay('2')">2</button>
            <button onclick="appendToDisplay('3')">3</button>
            <button onclick="calculate()" rowspan="2">=</button>
            
            <button onclick="appendToDisplay('0')" colspan="2">0</button>
            <button onclick="appendToDisplay('.')">,</button>
        </div>
    </div>
    
    <script>
        let display = document.getElementById('result');
        
        function appendToDisplay(value) {
            display.value += value;
        }
        
        function clearDisplay() {
            display.value = '';
        }
        
        function deleteLast() {
            display.value = display.value.slice(0, -1);
        }
        
        function calculate() {
            try {
                display.value = eval(display.value);
            } catch (error) {
                display.value = 'Error';
            }
        }
    </script>
</body>
</html>'''
        elif 'library' in query.lower():
            return '''<!DOCTYPE html>
<html>
<head>
    <title>Library Management System</title>
    <link rel="stylesheet" href="/static/style.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
    <div class="login-container">
        <div class="login-card">
            <h1>Library Management System</h1>
            <form method="POST" action="/login">
                <input type="text" name="username" placeholder="Username" required>
                <input type="password" name="password" placeholder="Password" required>
                <button type="submit" class="btn-primary">Login</button>
            </form>
            <div class="demo-info">
                <p>Demo Accounts:</p>
                <p>Admin: admin / admin123</p>
                <p>User: user1 / user123</p>
            </div>
        </div>
    </div>
</body>
</html>'''
        elif 'student' in query.lower() and 'management' in query.lower():
            return '''<!DOCTYPE html>
<html>
<head>
    <title>Student Management System</title>
    <link rel="stylesheet" href="/static/style.css">
</head>
<body>
    <div class="container">
        <h1>Student Management System</h1>
        
        <div class="add-student">
            <h2>Add New Student</h2>
            <form method="POST" action="/add">
                <input type="text" name="student_id" placeholder="Student ID" required>
                <input type="text" name="name" placeholder="Full Name" required>
                <input type="email" name="email" placeholder="Email">
                <input type="text" name="course" placeholder="Course" required>
                <input type="number" name="year" placeholder="Year" min="1" max="4" required>
                <input type="number" name="gpa" placeholder="GPA" step="0.01" min="0" max="4">
                <button type="submit">Add Student</button>
            </form>
        </div>
        
        <div class="students-list">
            <h2>Students List</h2>
            <table>
                <thead>
                    <tr>
                        <th>Student ID</th>
                        <th>Name</th>
                        <th>Email</th>
                        <th>Course</th>
                        <th>Year</th>
                        <th>GPA</th>
                    </tr>
                </thead>
                <tbody>
                    {% for student in students %}
                    <tr>
                        <td>{{ student[1] }}</td>
                        <td>{{ student[2] }}</td>
                        <td>{{ student[3] }}</td>
                        <td>{{ student[4] }}</td>
                        <td>{{ student[5] }}</td>
                        <td>{{ student[6] }}</td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
    </div>
</body>
</html>'''
        elif 'todo' in query.lower():
            return '''<!DOCTYPE html>
<html>
<head>
    <title>Todo List Manager</title>
    <link rel="stylesheet" href="/static/style.css">
</head>
<body>
    <div class="container">
        <h1>Todo List Manager</h1>
        
        <div class="add-task">
            <h2>Add New Task</h2>
            <form method="POST" action="/add">
                <input type="text" name="title" placeholder="Task Title" required>
                <textarea name="description" placeholder="Description"></textarea>
                <select name="priority">
                    <option value="low">Low Priority</option>
                    <option value="medium" selected>Medium Priority</option>
                    <option value="high">High Priority</option>
                </select>
                <button type="submit">Add Task</button>
            </form>
        </div>
        
        <div class="tasks-list">
            <h2>Tasks</h2>
            {% for task in tasks %}
            <div class="task priority-{{ task[3] }}">
                <h3>{{ task[1] }}</h3>
                <p>{{ task[2] }}</p>
                <span class="priority">{{ task[3].title() }} Priority</span>
                <span class="status">{{ task[4].title() }}</span>
            </div>
            {% endfor %}
        </div>
    </div>
</body>
</html>'''
        else:
            return f'''<!DOCTYPE html>
<html>
<head>
    <title>{{{{ app_name }}}}</title>
    <link rel="stylesheet" href="/static/style.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
    <div class="container">
        <header>
            <h1>{{{{ app_name }}}}</h1>
            <p>Complete Management System</p>
        </header>
        
        <div class="add-section">
            <h2>Add New Item</h2>
            <form method="POST" action="/add" class="add-form">
                <input type="text" name="name" placeholder="Name" required>
                <textarea name="description" placeholder="Description"></textarea>
                <input type="text" name="category" placeholder="Category">
                <button type="submit" class="btn-primary">Add Item</button>
            </form>
        </div>
        
        <div class="items-section">
            <h2>Items List</h2>
            <div class="items-grid">
                {{% for item in items %}}
                <div class="item-card">
                    <h3>{{{{ item[1] }}}}</h3>
                    <p>{{{{ item[2] or 'No description' }}}}</p>
                    <div class="item-meta">
                        <span class="category">{{{{ item[3] }}}}</span>
                        <span class="date">{{{{ item[5] }}}}</span>
                    </div>
                    <div class="item-actions">
                        <a href="/delete/{{{{ item[0] }}}}" class="btn-delete" onclick="return confirm('Delete this item?')">Delete</a>
                    </div>
                </div>
                {{% endfor %}}
            </div>
            
            {{% if not items %}}
            <div class="empty-state">
                <p>No items found. Add your first item above!</p>
            </div>
            {{% endif %}}
        </div>
    </div>
    
    <script>
        // Add some interactivity
        document.addEventListener('DOMContentLoaded', function() {{
            console.log('{{{{ app_name }}}} loaded successfully!');
        }});
    </script>
</body>
</html>'''
    
    def _generate_dashboard_template(self) -> str:
        return '''<!DOCTYPE html>
<html>
<head>
    <title>Library Dashboard</title>
    <link rel="stylesheet" href="/static/style.css">
</head>
<body>
    <div class="dashboard">
        <div class="sidebar">
            <h2>Library System</h2>
            <nav>
                <a href="/dashboard">Books</a>
                <a href="/my-books">My Books</a>
                <a href="/logout">Logout</a>
            </nav>
        </div>
        <div class="main-content">
            <div class="search-bar">
                <form method="GET">
                    <input type="text" name="search" placeholder="Search books..." value="{{ search }}">
                    <select name="sort">
                        <option value="title" {% if sort_by == 'title' %}selected{% endif %}>Title</option>
                        <option value="author" {% if sort_by == 'author' %}selected{% endif %}>Author</option>
                        <option value="category" {% if sort_by == 'category' %}selected{% endif %}>Category</option>
                    </select>
                    <button type="submit">Search</button>
                </form>
            </div>
            <div class="books-grid">
                {% for book in books %}
                <div class="book-card">
                    <h3>{{ book[1] }}</h3>
                    <p>Author: {{ book[2] }}</p>
                    <p>Category: {{ book[4] }}</p>
                    <p>Available: {{ book[6] }}/{{ book[5] }}</p>
                    <a href="/issue/{{ book[0] }}" class="btn-issue">Issue Book</a>
                </div>
                {% endfor %}
            </div>
        </div>
    </div>
</body>
</html>'''
    
    def _generate_css_styles(self) -> str:
        return '''body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
    background-color: #f5f5f5;
}

.login-container {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
}

.login-card {
    background: white;
    padding: 40px;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    width: 300px;
}

.login-card h1 {
    text-align: center;
    color: #333;
    margin-bottom: 30px;
}

.login-card input {
    width: 100%;
    padding: 12px;
    margin: 10px 0;
    border: 1px solid #ddd;
    border-radius: 4px;
    box-sizing: border-box;
}

.btn-primary {
    width: 100%;
    padding: 12px;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 16px;
}

.btn-primary:hover {
    background-color: #0056b3;
}

.demo-info {
    margin-top: 20px;
    padding: 15px;
    background-color: #f8f9fa;
    border-radius: 4px;
    font-size: 14px;
}

.dashboard {
    display: flex;
    height: 100vh;
}

.sidebar {
    width: 250px;
    background-color: #343a40;
    color: white;
    padding: 20px;
}

.sidebar h2 {
    margin-bottom: 30px;
}

.sidebar nav a {
    display: block;
    color: white;
    text-decoration: none;
    padding: 10px 0;
    border-bottom: 1px solid #495057;
}

.sidebar nav a:hover {
    background-color: #495057;
    padding-left: 10px;
}

.main-content {
    flex: 1;
    padding: 20px;
}

.search-bar {
    background: white;
    padding: 20px;
    border-radius: 8px;
    margin-bottom: 20px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.search-bar form {
    display: flex;
    gap: 10px;
    align-items: center;
}

.search-bar input, .search-bar select {
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 4px;
}

.search-bar button {
    padding: 10px 20px;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

.books-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 20px;
}

.book-card {
    background: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.book-card h3 {
    margin-top: 0;
    color: #333;
}

.btn-issue {
    display: inline-block;
    padding: 8px 16px;
    background-color: #28a745;
    color: white;
    text-decoration: none;
    border-radius: 4px;
    margin-top: 10px;
}

.btn-issue:hover {
    background-color: #218838;
}'''
    
    def _generate_readme(self, project_name: str, project_type: str, language: str) -> str:
        return f'''# {project_name}

Generated by Jarvis Auto Code Architect

## Description
A {project_type} application built with {language.title()}.

## Installation

### Requirements
- {language.title()} (latest version recommended)

### Setup
1. Clone or download this project
2. Navigate to the project directory
3. Install dependencies:
   ```bash
   pip install -r requirements.txt
   ```

## Usage
Run the main application:
```bash
python app.py
```

## Features
- Modern {project_type} interface
- Cross-platform compatibility
- Easy to extend and customize

## Generated by
Jarvis AI Assistant - Auto Code Architect
'''
    
    def _generate_static_html(self, project_name: str, query: str = '') -> str:
        """Generate advanced static HTML based on user requirements"""
        query_lower = query.lower()
        features = self._analyze_requirements(query_lower)
        
        # Determine project type
        if 'portfolio' in query_lower:
            return self._generate_portfolio_html(project_name, features)
        elif 'ecommerce' in query_lower or 'shop' in query_lower:
            return self._generate_portfolio_html(project_name, features)
        elif 'blog' in query_lower:
            return self._generate_portfolio_html(project_name, features)
        elif 'landing' in query_lower:
            return self._generate_portfolio_html(project_name, features)
        else:
            return self._generate_portfolio_html(project_name, features)
    
    def _generate_portfolio_html(self, project_name: str, features: dict) -> str:
        return f'''<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{project_name}</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar">
        <div class="nav-container">
            <div class="nav-logo">
                <h2>Portfolio</h2>
            </div>
            <div class="nav-menu" id="nav-menu">
                <a href="#home" class="nav-link">Home</a>
                <a href="#about" class="nav-link">About</a>
                <a href="#skills" class="nav-link">Skills</a>
                <a href="#projects" class="nav-link">Projects</a>
                <a href="#contact" class="nav-link">Contact</a>
                {"<button class='theme-toggle' id='theme-toggle'><i class='fas fa-moon'></i></button>" if features['responsive'] else ""}
            </div>
            <div class="nav-toggle" id="nav-toggle">
                <span class="bar"></span>
                <span class="bar"></span>
                <span class="bar"></span>
            </div>
        </div>
    </nav>

    <!-- Hero Section -->
    <section id="home" class="hero">
        <div class="hero-container">
            <div class="hero-content">
                <h1 class="hero-title">Hi, I'm <span class="highlight">John Doe</span></h1>
                <p class="hero-subtitle">Full Stack Developer & UI/UX Designer</p>
                <p class="hero-description">I create amazing digital experiences that make people's lives easier.</p>
                <div class="hero-buttons">
                    <a href="#projects" class="btn btn-primary">View My Work</a>
                    <a href="#contact" class="btn btn-secondary">Get In Touch</a>
                </div>
            </div>
            <div class="hero-image">
                <div class="image-placeholder">
                    <i class="fas fa-user-circle"></i>
                </div>
            </div>
        </div>
    </section>

    <!-- About Section -->
    <section id="about" class="about">
        <div class="container">
            <h2 class="section-title">About Me</h2>
            <div class="about-content">
                <div class="about-text">
                    <p>I'm a passionate developer with 5+ years of experience creating web applications and user interfaces. I love turning complex problems into simple, beautiful designs.</p>
                    <div class="stats">
                        <div class="stat">
                            <h3>50+</h3>
                            <p>Projects Completed</p>
                        </div>
                        <div class="stat">
                            <h3>5+</h3>
                            <p>Years Experience</p>
                        </div>
                        <div class="stat">
                            <h3>100+</h3>
                            <p>Happy Clients</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Skills Section -->
    <section id="skills" class="skills">
        <div class="container">
            <h2 class="section-title">Skills & Technologies</h2>
            <div class="skills-grid">
                <div class="skill-card">
                    <i class="fab fa-html5"></i>
                    <h3>Frontend</h3>
                    <p>HTML5, CSS3, JavaScript, React, Vue.js</p>
                </div>
                <div class="skill-card">
                    <i class="fas fa-server"></i>
                    <h3>Backend</h3>
                    <p>Node.js, Python, PHP, Java, .NET</p>
                </div>
                <div class="skill-card">
                    <i class="fas fa-database"></i>
                    <h3>Database</h3>
                    <p>MySQL, PostgreSQL, MongoDB, SQLite</p>
                </div>
                <div class="skill-card">
                    <i class="fas fa-tools"></i>
                    <h3>Tools</h3>
                    <p>Git, Docker, AWS, Figma, Photoshop</p>
                </div>
            </div>
        </div>
    </section>

    <!-- Projects Section -->
    <section id="projects" class="projects">
        <div class="container">
            <h2 class="section-title">Featured Projects</h2>
            <div class="projects-grid">
                <div class="project-card">
                    <div class="project-image">
                        <div class="image-placeholder">
                            <i class="fas fa-image"></i>
                        </div>
                        <div class="project-overlay">
                            <a href="#" class="project-link"><i class="fas fa-external-link-alt"></i></a>
                            <a href="#" class="project-link"><i class="fab fa-github"></i></a>
                        </div>
                    </div>
                    <div class="project-content">
                        <h3>E-Commerce Platform</h3>
                        <p>Full-stack e-commerce solution with React and Node.js</p>
                        <div class="project-tech">
                            <span>React</span>
                            <span>Node.js</span>
                            <span>MongoDB</span>
                        </div>
                    </div>
                </div>
                
                <div class="project-card">
                    <div class="project-image">
                        <div class="image-placeholder">
                            <i class="fas fa-image"></i>
                        </div>
                        <div class="project-overlay">
                            <a href="#" class="project-link"><i class="fas fa-external-link-alt"></i></a>
                            <a href="#" class="project-link"><i class="fab fa-github"></i></a>
                        </div>
                    </div>
                    <div class="project-content">
                        <h3>Task Management App</h3>
                        <p>Collaborative task management with real-time updates</p>
                        <div class="project-tech">
                            <span>Vue.js</span>
                            <span>Firebase</span>
                            <span>CSS3</span>
                        </div>
                    </div>
                </div>
                
                <div class="project-card">
                    <div class="project-image">
                        <div class="image-placeholder">
                            <i class="fas fa-image"></i>
                        </div>
                        <div class="project-overlay">
                            <a href="#" class="project-link"><i class="fas fa-external-link-alt"></i></a>
                            <a href="#" class="project-link"><i class="fab fa-github"></i></a>
                        </div>
                    </div>
                    <div class="project-content">
                        <h3>Weather Dashboard</h3>
                        <p>Beautiful weather app with location-based forecasts</p>
                        <div class="project-tech">
                            <span>JavaScript</span>
                            <span>API</span>
                            <span>Chart.js</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Contact Section -->
    <section id="contact" class="contact">
        <div class="container">
            <h2 class="section-title">Get In Touch</h2>
            <div class="contact-content">
                <div class="contact-info">
                    <div class="contact-item">
                        <i class="fas fa-envelope"></i>
                        <div>
                            <h3>Email</h3>
                            <p>john.doe@example.com</p>
                        </div>
                    </div>
                    <div class="contact-item">
                        <i class="fas fa-phone"></i>
                        <div>
                            <h3>Phone</h3>
                            <p>+1 (555) 123-4567</p>
                        </div>
                    </div>
                    <div class="contact-item">
                        <i class="fas fa-map-marker-alt"></i>
                        <div>
                            <h3>Location</h3>
                            <p>New York, NY</p>
                        </div>
                    </div>
                </div>
                
                <form class="contact-form" id="contact-form">
                    <div class="form-group">
                        <input type="text" id="name" name="name" placeholder="Your Name" required>
                    </div>
                    <div class="form-group">
                        <input type="email" id="email" name="email" placeholder="Your Email" required>
                    </div>
                    <div class="form-group">
                        <input type="text" id="subject" name="subject" placeholder="Subject" required>
                    </div>
                    <div class="form-group">
                        <textarea id="message" name="message" placeholder="Your Message" rows="5" required></textarea>
                    </div>
                    <button type="submit" class="btn btn-primary">Send Message</button>
                </form>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <p>&copy; 2024 John Doe. All rights reserved.</p>
                <div class="social-links">
                    <a href="#"><i class="fab fa-linkedin"></i></a>
                    <a href="#"><i class="fab fa-github"></i></a>
                    <a href="#"><i class="fab fa-twitter"></i></a>
                    <a href="#"><i class="fab fa-instagram"></i></a>
                </div>
            </div>
        </div>
    </footer>
        
        <div class="add-section">
            <h2>Add New Item</h2>
            <form id="addForm" class="add-form">
                <input type="text" id="itemName" placeholder="Item Name" required>
                <input type="text" id="itemCategory" placeholder="Category">
                <input type="number" id="itemQuantity" placeholder="Quantity" min="0">
                <input type="number" id="itemPrice" placeholder="Price" step="0.01" min="0">
                <textarea id="itemDescription" placeholder="Description"></textarea>
                <button type="submit" class="btn-primary">Add Item</button>
            </form>
        </div>
        
        <div class="items-section">
            <h2>Items List</h2>
            <div class="search-bar">
                <input type="text" id="searchInput" placeholder="Search items...">
                <select id="categoryFilter">
                    <option value="">All Categories</option>
                </select>
            </div>
            <div id="itemsList" class="items-grid">
                <!-- Items will be populated by JavaScript -->
            </div>
            <div id="emptyState" class="empty-state">
                <p>No items found. Add your first item above!</p>
            </div>
        </div>
    </div>
    
    <script src="script.js"></script>
</body>
</html>'''
    
    def _generate_static_css(self) -> str:
        return '''* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    padding: 20px;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    background: white;
    border-radius: 15px;
    box-shadow: 0 20px 40px rgba(0,0,0,0.1);
    overflow: hidden;
}

header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 40px;
    text-align: center;
}

header h1 {
    font-size: 2.5rem;
    margin-bottom: 10px;
}

header p {
    font-size: 1.2rem;
    opacity: 0.9;
}

.add-section {
    padding: 40px;
    background: #f8f9fa;
    border-bottom: 1px solid #e9ecef;
}

.add-section h2 {
    margin-bottom: 20px;
    color: #333;
}

.add-form {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 15px;
    align-items: end;
}

.add-form input,
.add-form textarea,
.add-form select {
    padding: 12px;
    border: 2px solid #e9ecef;
    border-radius: 8px;
    font-size: 16px;
    transition: border-color 0.3s;
}

.add-form input:focus,
.add-form textarea:focus {
    outline: none;
    border-color: #667eea;
}

.add-form textarea {
    grid-column: 1 / -1;
    resize: vertical;
    min-height: 80px;
}

.btn-primary {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border: none;
    padding: 12px 24px;
    border-radius: 8px;
    font-size: 16px;
    cursor: pointer;
    transition: transform 0.2s;
}

.btn-primary:hover {
    transform: translateY(-2px);
}

.items-section {
    padding: 40px;
}

.items-section h2 {
    margin-bottom: 20px;
    color: #333;
}

.search-bar {
    display: flex;
    gap: 15px;
    margin-bottom: 30px;
}

.search-bar input,
.search-bar select {
    padding: 10px;
    border: 2px solid #e9ecef;
    border-radius: 8px;
    font-size: 14px;
}

.search-bar input {
    flex: 1;
}

.items-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 20px;
}

.item-card {
    background: white;
    border: 2px solid #e9ecef;
    border-radius: 12px;
    padding: 20px;
    transition: all 0.3s;
    position: relative;
}

.item-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 10px 25px rgba(0,0,0,0.1);
    border-color: #667eea;
}

.item-card h3 {
    color: #333;
    margin-bottom: 10px;
    font-size: 1.3rem;
}

.item-card p {
    color: #666;
    margin-bottom: 15px;
    line-height: 1.5;
}

.item-meta {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}

.category {
    background: #667eea;
    color: white;
    padding: 4px 12px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: bold;
}

.quantity {
    background: #28a745;
    color: white;
    padding: 4px 12px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: bold;
}

.price {
    background: #ffc107;
    color: #333;
    padding: 4px 12px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: bold;
}

.item-actions {
    display: flex;
    gap: 10px;
}

.btn-delete {
    background: #dc3545;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 6px;
    font-size: 14px;
    cursor: pointer;
    text-decoration: none;
    transition: background 0.2s;
}

.btn-delete:hover {
    background: #c82333;
}

.empty-state {
    text-align: center;
    padding: 60px 20px;
    color: #666;
    font-size: 1.1rem;
}

@media (max-width: 768px) {
    .add-form {
        grid-template-columns: 1fr;
    }
    
    .search-bar {
        flex-direction: column;
    }
    
    .items-grid {
        grid-template-columns: 1fr;
    }
}'''
    
    def _generate_javascript_code(self, project_name: str, query: str = '', project_type: str = 'web') -> str:
        return self._generate_advanced_javascript_app(project_name, query, project_type)
    
    def _generate_java_code(self, project_name: str, query: str = '', project_type: str = 'web') -> str:
        return self._generate_advanced_java_app(project_name, query, project_type)
    
    def _generate_spring_boot(self, project_name: str, query: str = '') -> str:
        class_name = project_name.replace('App', '').replace(' ', '')
        return f'''package com.jarvis.{class_name.lower()};

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.*;
import org.springframework.stereotype.Service;
import java.util.*;
import java.time.LocalDateTime;

@SpringBootApplication
public class {class_name}Application {{
    public static void main(String[] args) {{
        SpringApplication.run({class_name}Application.class, args);
    }}
}}

@RestController
@RequestMapping("/api")
class {class_name}Controller {{
    private final {class_name}Service service;
    
    public {class_name}Controller({class_name}Service service) {{
        this.service = service;
    }}
    
    @GetMapping("/items")
    public List<Item> getAllItems() {{
        return service.getAllItems();
    }}
    
    @PostMapping("/items")
    public Item createItem(@RequestBody Item item) {{
        return service.createItem(item);
    }}
    
    @DeleteMapping("/items/{{id}}")
    public void deleteItem(@PathVariable Long id) {{
        service.deleteItem(id);
    }}
}}

@Service
class {class_name}Service {{
    private List<Item> items = new ArrayList<>();
    private Long nextId = 1L;
    
    public List<Item> getAllItems() {{
        return items;
    }}
    
    public Item createItem(Item item) {{
        item.setId(nextId++);
        item.setCreatedAt(LocalDateTime.now());
        items.add(item);
        return item;
    }}
    
    public void deleteItem(Long id) {{
        items.removeIf(item -> item.getId().equals(id));
    }}
}}

class Item {{
    private Long id;
    private String name;
    private String description;
    private String category;
    private LocalDateTime createdAt;
    
    // Constructors
    public Item() {{}}
    
    public Item(String name, String description, String category) {{
        this.name = name;
        this.description = description;
        this.category = category;
    }}
    
    // Getters and Setters
    public Long getId() {{ return id; }}
    public void setId(Long id) {{ this.id = id; }}
    
    public String getName() {{ return name; }}
    public void setName(String name) {{ this.name = name; }}
    
    public String getDescription() {{ return description; }}
    public void setDescription(String description) {{ this.description = description; }}
    
    public String getCategory() {{ return category; }}
    public void setCategory(String category) {{ this.category = category; }}
    
    public LocalDateTime getCreatedAt() {{ return createdAt; }}
    public void setCreatedAt(LocalDateTime createdAt) {{ this.createdAt = createdAt; }}
}}'''
    
    def _generate_advanced_flask_app(self, project_name: str, query: str = '') -> str:
        """Generate advanced Flask app based on user requirements"""
        query_lower = query.lower()
        
        # Analyze requirements
        has_auth = any(word in query_lower for word in ['login', 'register', 'user', 'auth', 'account'])
        has_charts = any(word in query_lower for word in ['chart', 'graph', 'visualization', 'analytics'])
        has_api = any(word in query_lower for word in ['api', 'rest', 'json'])
        has_file_upload = any(word in query_lower for word in ['upload', 'file', 'image'])
        has_email = any(word in query_lower for word in ['email', 'notification', 'mail'])
        has_search = any(word in query_lower for word in ['search', 'filter', 'find'])
        has_export = any(word in query_lower for word in ['export', 'pdf', 'csv', 'download'])
        
        # Determine database schema based on context
        if 'expense' in query_lower or 'finance' in query_lower:
            db_schema = self._get_expense_schema()
            routes = self._get_expense_routes()
        elif 'inventory' in query_lower or 'stock' in query_lower:
            db_schema = self._get_inventory_schema()
            routes = self._get_inventory_routes()
        elif 'student' in query_lower or 'school' in query_lower:
            db_schema = self._get_student_schema()
            routes = self._get_student_routes()
        elif 'employee' in query_lower or 'hr' in query_lower:
            db_schema = self._get_employee_schema()
            routes = self._get_employee_routes()
        else:
            db_schema = self._get_generic_schema()
            routes = self._get_generic_routes()
        
        # Generate imports based on features
        imports = ['from flask import Flask, render_template, request, redirect, url_for, jsonify, flash, session']
        imports.append('import sqlite3')
        imports.append('from datetime import datetime, date')
        imports.append('import os')
        
        if has_auth:
            imports.append('from werkzeug.security import generate_password_hash, check_password_hash')
        if has_file_upload:
            imports.append('from werkzeug.utils import secure_filename')
        if has_email:
            imports.append('from flask_mail import Mail, Message')
        if has_export:
            imports.append('import csv')
            imports.append('import io')
        
        app_name = project_name.replace('App', '').lower()
        
        return f'''{"; ".join(imports)}

app = Flask(__name__)
app.secret_key = '{app_name}_secret_key_change_in_production'

# Configuration
app.config['UPLOAD_FOLDER'] = 'uploads'
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16MB max file size

{"# Email configuration" if has_email else ""}
{"app.config['MAIL_SERVER'] = 'smtp.gmail.com'" if has_email else ""}
{"app.config['MAIL_PORT'] = 587" if has_email else ""}
{"app.config['MAIL_USE_TLS'] = True" if has_email else ""}
{"mail = Mail(app)" if has_email else ""}

def init_db():
    conn = sqlite3.connect('{app_name}.db')
    c = conn.cursor()
    
{db_schema}
    
    conn.commit()
    conn.close()

{routes}

{self._get_auth_routes() if has_auth else ""}

{self._get_api_routes(app_name) if has_api else ""}

{self._get_chart_routes() if has_charts else ""}

{self._get_export_routes(app_name) if has_export else ""}

if __name__ == '__main__':
    if not os.path.exists('uploads'):
        os.makedirs('uploads')
    init_db()
    app.run(debug=True)
'''
    
    def _get_expense_schema(self) -> str:
        return '''    # Users table
    c.execute("""CREATE TABLE IF NOT EXISTS users
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  username TEXT UNIQUE NOT NULL,
                  email TEXT UNIQUE NOT NULL,
                  password_hash TEXT NOT NULL,
                  created_date TEXT NOT NULL)""")
    
    # Categories table
    c.execute("""CREATE TABLE IF NOT EXISTS categories
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  name TEXT NOT NULL,
                  type TEXT NOT NULL,
                  color TEXT DEFAULT '#007bff')""")
    
    # Transactions table
    c.execute("""CREATE TABLE IF NOT EXISTS transactions
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  user_id INTEGER,
                  type TEXT NOT NULL,
                  amount REAL NOT NULL,
                  category_id INTEGER,
                  description TEXT,
                  date TEXT NOT NULL,
                  created_date TEXT NOT NULL,
                  FOREIGN KEY (user_id) REFERENCES users (id),
                  FOREIGN KEY (category_id) REFERENCES categories (id))""")
    
    # Insert default categories
    categories = [
        ('Food & Dining', 'expense', '#ff6b6b'),
        ('Transportation', 'expense', '#4ecdc4'),
        ('Shopping', 'expense', '#45b7d1'),
        ('Entertainment', 'expense', '#96ceb4'),
        ('Bills & Utilities', 'expense', '#feca57'),
        ('Salary', 'income', '#48dbfb'),
        ('Freelance', 'income', '#0abde3'),
        ('Investment', 'income', '#006ba6')
    ]
    c.executemany('INSERT OR IGNORE INTO categories (name, type, color) VALUES (?, ?, ?)', categories)'''
    
    def _get_expense_routes(self) -> str:
        return '''@app.route('/')
def dashboard():
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    conn = sqlite3.connect('{app_name}.db')
    c = conn.cursor()
    
    # Get current month transactions
    current_month = datetime.now().strftime('%Y-%m')
    c.execute("""SELECT t.*, cat.name as category_name, cat.color 
                 FROM transactions t 
                 JOIN categories cat ON t.category_id = cat.id 
                 WHERE t.user_id = ? AND t.date LIKE ?
                 ORDER BY t.date DESC""", (session['user_id'], f'{current_month}%'))
    transactions = c.fetchall()
    
    # Calculate totals
    c.execute("""SELECT 
                    SUM(CASE WHEN type = 'income' THEN amount ELSE 0 END) as total_income,
                    SUM(CASE WHEN type = 'expense' THEN amount ELSE 0 END) as total_expense
                 FROM transactions 
                 WHERE user_id = ? AND date LIKE ?""", (session['user_id'], f'{current_month}%'))
    totals = c.fetchone()
    
    # Get categories
    c.execute('SELECT * FROM categories ORDER BY type, name')
    categories = c.fetchall()
    
    conn.close()
    
    balance = (totals[0] or 0) - (totals[1] or 0)
    
    return render_template('dashboard.html', 
                         transactions=transactions,
                         categories=categories,
                         total_income=totals[0] or 0,
                         total_expense=totals[1] or 0,
                         balance=balance)

@app.route('/add_transaction', methods=['POST'])
def add_transaction():
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    conn = sqlite3.connect('{app_name}.db')
    c = conn.cursor()
    c.execute("""INSERT INTO transactions 
                 (user_id, type, amount, category_id, description, date, created_date) 
                 VALUES (?, ?, ?, ?, ?, ?, ?)""",
             (session['user_id'], request.form['type'], float(request.form['amount']),
              int(request.form['category_id']), request.form.get('description', ''),
              request.form['date'], datetime.now().strftime('%Y-%m-%d %H:%M:%S')))
    conn.commit()
    conn.close()
    
    flash('Transaction added successfully!', 'success')
    return redirect(url_for('dashboard'))

@app.route('/delete_transaction/<int:transaction_id>')
def delete_transaction(transaction_id):
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    conn = sqlite3.connect('{app_name}.db')
    c = conn.cursor()
    c.execute('DELETE FROM transactions WHERE id = ? AND user_id = ?', 
             (transaction_id, session['user_id']))
    conn.commit()
    conn.close()
    
    flash('Transaction deleted successfully!', 'success')
    return redirect(url_for('dashboard'))'''
    
    def _generate_advanced_python_app(self, project_name: str, query: str = '', project_type: str = 'web') -> str:
        """Generate advanced Python app based on user requirements"""
        query_lower = query.lower()
        
        if 'fastapi' in query_lower or project_type == 'api':
            return self._python_flask_app(project_name, query)
        elif 'django' in query_lower:
            return self._python_flask_app(project_name, query)
        else:
            return self._python_flask_app(project_name, query)
    
    def _generate_advanced_javascript_app(self, project_name: str, query: str = '', project_type: str = 'web') -> str:
        """Generate advanced JavaScript app based on user requirements"""
        query_lower = query.lower()
        features = self._analyze_requirements(query_lower)
        
        if 'react' in query_lower:
            return self._generate_node_api(project_name, query)
        elif 'vue' in query_lower:
            return self._generate_node_api(project_name, query)
        elif 'node' in query_lower or project_type == 'api':
            return self._generate_node_api(project_name, query)
        else:
            return self._generate_node_api(project_name, query)
    
    def _generate_advanced_java_app(self, project_name: str, query: str = '', project_type: str = 'web') -> str:
        """Generate advanced Java app based on user requirements"""
        query_lower = query.lower()
        
        if 'spring' in query_lower:
            return self._generate_spring_boot(project_name, query)
        else:
            return self._java_console(project_name, query)
    
    def _analyze_requirements(self, query: str) -> dict:
        """Analyze user requirements and return feature flags"""
        return {
            'auth': any(word in query for word in ['login', 'register', 'user', 'auth', 'account', 'signin']),
            'database': any(word in query for word in ['database', 'sqlite', 'mysql', 'postgres', 'data', 'store']),
            'api': any(word in query for word in ['api', 'rest', 'json', 'endpoint']),
            'charts': any(word in query for word in ['chart', 'graph', 'visualization', 'analytics', 'dashboard']),
            'file_upload': any(word in query for word in ['upload', 'file', 'image', 'document']),
            'email': any(word in query for word in ['email', 'notification', 'mail', 'smtp']),
            'search': any(word in query for word in ['search', 'filter', 'find', 'query']),
            'export': any(word in query for word in ['export', 'pdf', 'csv', 'download', 'report']),
            'realtime': any(word in query for word in ['realtime', 'websocket', 'live', 'chat']),
            'payment': any(word in query for word in ['payment', 'stripe', 'paypal', 'billing']),
            'responsive': any(word in query for word in ['responsive', 'mobile', 'bootstrap', 'css']),
            'security': any(word in query for word in ['security', 'encryption', 'ssl', 'secure']),
            'testing': any(word in query for word in ['test', 'testing', 'unit test', 'pytest']),
            'deployment': any(word in query for word in ['deploy', 'docker', 'heroku', 'aws']),
            'admin': any(word in query for word in ['admin', 'management', 'dashboard', 'control panel'])
        }
    
    def _generate_fastapi_app_old(self, project_name: str, query: str, features: dict) -> str:
        """Generate advanced FastAPI application"""
        app_name = project_name.replace('App', '').lower()
        
        imports = ['from fastapi import FastAPI, HTTPException, Depends, status']
        imports.append('from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials')
        imports.append('from pydantic import BaseModel')
        imports.append('import sqlite3')
        imports.append('from datetime import datetime, timedelta')
        imports.append('import jwt')
        imports.append('import bcrypt')
        
        if features['file_upload']:
            imports.append('from fastapi import UploadFile, File')
        if features['email']:
            imports.append('import smtplib')
        if features['export']:
            imports.append('import pandas as pd')
        
        return f'''{chr(10).join(imports)}

app = FastAPI(title="{project_name}", description="Advanced {app_name} API")
security = HTTPBearer()

# Database setup
def init_db():
    conn = sqlite3.connect('{app_name}.db')
    c = conn.cursor()
    
    # Users table
    c.execute("""CREATE TABLE IF NOT EXISTS users
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  username TEXT UNIQUE NOT NULL,
                  email TEXT UNIQUE NOT NULL,
                  password_hash TEXT NOT NULL,
                  is_active BOOLEAN DEFAULT TRUE,
                  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)""")
    
    # Main data table
    c.execute("""CREATE TABLE IF NOT EXISTS items
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  user_id INTEGER,
                  title TEXT NOT NULL,
                  description TEXT,
                  category TEXT,
                  status TEXT DEFAULT 'active',
                  metadata JSON,
                  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                  FOREIGN KEY (user_id) REFERENCES users (id))""")
    
    conn.commit()
    conn.close()

# Pydantic models
class UserCreate(BaseModel):
    username: str
    email: str
    password: str

class UserLogin(BaseModel):
    username: str
    password: str

class ItemCreate(BaseModel):
    title: str
    description: str = None
    category: str = "general"
    metadata: dict = {{}}

class ItemResponse(BaseModel):
    id: int
    title: str
    description: str
    category: str
    status: str
    created_at: str

# Authentication
def create_access_token(data: dict):
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(hours=24)
    to_encode.update({{"exp": expire}})
    return jwt.encode(to_encode, "secret_key", algorithm="HS256")

def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):
    try:
        payload = jwt.decode(credentials.credentials, "secret_key", algorithms=["HS256"])
        username = payload.get("sub")
        if username is None:
            raise HTTPException(status_code=401, detail="Invalid token")
        return username
    except jwt.PyJWTError:
        raise HTTPException(status_code=401, detail="Invalid token")

# Routes
@app.post("/register")
def register(user: UserCreate):
    conn = sqlite3.connect('{app_name}.db')
    c = conn.cursor()
    
    # Hash password
    password_hash = bcrypt.hashpw(user.password.encode('utf-8'), bcrypt.gensalt())
    
    try:
        c.execute("INSERT INTO users (username, email, password_hash) VALUES (?, ?, ?)",
                 (user.username, user.email, password_hash))
        conn.commit()
        return {{"message": "User created successfully"}}
    except sqlite3.IntegrityError:
        raise HTTPException(status_code=400, detail="Username or email already exists")
    finally:
        conn.close()

@app.post("/login")
def login(user: UserLogin):
    conn = sqlite3.connect('{app_name}.db')
    c = conn.cursor()
    c.execute("SELECT password_hash FROM users WHERE username = ?", (user.username,))
    result = c.fetchone()
    conn.close()
    
    if result and bcrypt.checkpw(user.password.encode('utf-8'), result[0]):
        access_token = create_access_token(data={{"sub": user.username}})
        return {{"access_token": access_token, "token_type": "bearer"}}
    
    raise HTTPException(status_code=401, detail="Invalid credentials")

@app.get("/items", response_model=list[ItemResponse])
def get_items(current_user: str = Depends(get_current_user)):
    conn = sqlite3.connect('{app_name}.db')
    c = conn.cursor()
    c.execute("""SELECT i.* FROM items i 
                 JOIN users u ON i.user_id = u.id 
                 WHERE u.username = ? ORDER BY i.created_at DESC""", (current_user,))
    items = c.fetchall()
    conn.close()
    
    return [ItemResponse(
        id=item[0], title=item[2], description=item[3], 
        category=item[4], status=item[5], created_at=item[7]
    ) for item in items]

@app.post("/items")
def create_item(item: ItemCreate, current_user: str = Depends(get_current_user)):
    conn = sqlite3.connect('{app_name}.db')
    c = conn.cursor()
    
    # Get user ID
    c.execute("SELECT id FROM users WHERE username = ?", (current_user,))
    user_id = c.fetchone()[0]
    
    c.execute("""INSERT INTO items (user_id, title, description, category, metadata) 
                 VALUES (?, ?, ?, ?, ?)""",
             (user_id, item.title, item.description, item.category, str(item.metadata)))
    conn.commit()
    conn.close()
    
    return {{"message": "Item created successfully"}}

@app.delete("/items/{{item_id}}")
def delete_item(item_id: int, current_user: str = Depends(get_current_user)):
    conn = sqlite3.connect('{app_name}.db')
    c = conn.cursor()
    c.execute("""DELETE FROM items WHERE id = ? AND user_id = 
                 (SELECT id FROM users WHERE username = ?)""", (item_id, current_user))
    conn.commit()
    conn.close()
    
    return {{"message": "Item deleted successfully"}}

{"@app.get('/export/csv')" if features['export'] else ""}
{"def export_csv(current_user: str = Depends(get_current_user)):" if features['export'] else ""}
{"    # Export functionality here" if features['export'] else ""}
{"    pass" if features['export'] else ""}

if __name__ == "__main__":
    init_db()
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
'''
    
    def _get_generic_schema(self) -> str:
        return '''    c.execute("""CREATE TABLE IF NOT EXISTS items
                     (id INTEGER PRIMARY KEY AUTOINCREMENT,
                      name TEXT NOT NULL,
                      description TEXT,
                      category TEXT,
                      status TEXT DEFAULT 'active',
                      created_date TEXT NOT NULL)""")
'''
    
    def _get_generic_routes(self) -> str:
        return '''@app.route('/')
def index():
    return render_template('index.html')

@app.route('/items')
def items():
    conn = sqlite3.connect('{app_name}.db')
    c = conn.cursor()
    c.execute('SELECT * FROM items ORDER BY created_date DESC')
    items = c.fetchall()
    conn.close()
    return render_template('items.html', items=items)
'''
    
    def _get_auth_routes(self) -> str:
        return '''@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        # Login logic here
        pass
    return render_template('login.html')

@app.route('/register', methods=['GET', 'POST'])
def register():
    if request.method == 'POST':
        # Registration logic here
        pass
    return render_template('register.html')
'''
    
    def _get_api_routes(self, app_name: str) -> str:
        return f'''@app.route('/api/items')
def api_items():
    conn = sqlite3.connect('{app_name}.db')
    c = conn.cursor()
    c.execute('SELECT * FROM items')
    items = c.fetchall()
    conn.close()
    return jsonify(items)
'''
    
    def _get_chart_routes(self) -> str:
        return '''@app.route('/api/charts')
def chart_data():
    # Chart data logic here
    return jsonify({'data': []})
'''
    
    def _get_export_routes(self, app_name: str) -> str:
        return f'''@app.route('/export/csv')
def export_csv():
    # CSV export logic here
    return "CSV export"
'''
    
    def _java_console(self, project_name: str, query: str = '') -> str:
        class_name = project_name.replace('App', '').replace(' ', '')
        return f'''public class {class_name} {{
    public static void main(String[] args) {{
        System.out.println("Welcome to {project_name}!");
        
        // Add your implementation here
        {class_name}Manager manager = new {class_name}Manager();
        manager.start();
    }}
}}

class {class_name}Manager {{
    public void start() {{
        System.out.println("{project_name} is running...");
        // Implementation goes here
    }}
}}'''
    
    def _generate_csharp_code(self, project_name: str, query: str = '', project_type: str = 'web') -> str:
        if project_type == 'web':
            return self._generate_aspnet_core(project_name, query)
        else:
            return self._generate_csharp_console(project_name, query)
    
    def _generate_php_code(self, project_name: str, query: str = '', project_type: str = 'web') -> str:
        if 'laravel' in query.lower():
            return self._generate_laravel_app(project_name, query)
        else:
            return self._generate_php_app(project_name, query)
    
    def _generate_node_api(self, project_name: str, query: str = '') -> str:
        app_name = project_name.replace('App', '').lower()
        return f'''const express = require('express');
const cors = require('cors');
const fs = require('fs');
const path = require('path');

const app = express();
const PORT = process.env.PORT || 3000;
const DATA_FILE = '{app_name}_data.json';

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.static('public'));

// Initialize data file
if (!fs.existsSync(DATA_FILE)) {{
    fs.writeFileSync(DATA_FILE, JSON.stringify([]));
}}

// Helper functions
const readData = () => {{
    try {{
        const data = fs.readFileSync(DATA_FILE, 'utf8');
        return JSON.parse(data);
    }} catch (error) {{
        return [];
    }}
}};

const writeData = (data) => {{
    fs.writeFileSync(DATA_FILE, JSON.stringify(data, null, 2));
}};

// Routes
app.get('/api/items', (req, res) => {{
    const items = readData();
    res.json(items);
}});

app.post('/api/items', (req, res) => {{
    const items = readData();
    const newItem = {{
        id: Date.now(),
        ...req.body,
        createdAt: new Date().toISOString()
    }};
    items.push(newItem);
    writeData(items);
    res.status(201).json(newItem);
}});

app.put('/api/items/:id', (req, res) => {{
    const items = readData();
    const itemId = parseInt(req.params.id);
    const itemIndex = items.findIndex(item => item.id === itemId);
    
    if (itemIndex === -1) {{
        return res.status(404).json({{ error: 'Item not found' }});
    }}
    
    items[itemIndex] = {{ ...items[itemIndex], ...req.body }};
    writeData(items);
    res.json(items[itemIndex]);
}});

app.delete('/api/items/:id', (req, res) => {{
    const items = readData();
    const itemId = parseInt(req.params.id);
    const filteredItems = items.filter(item => item.id !== itemId);
    
    if (filteredItems.length === items.length) {{
        return res.status(404).json({{ error: 'Item not found' }});
    }}
    
    writeData(filteredItems);
    res.json({{ message: 'Item deleted successfully' }});
}});

app.listen(PORT, () => {{
    console.log(`{project_name} API running on port ${{PORT}}`);
}});'''
    
    def _generate_static_js(self, project_name: str) -> str:
        return f'''// {project_name} JavaScript
let items = JSON.parse(localStorage.getItem('items')) || [];
let categories = new Set();

// DOM Elements
const addForm = document.getElementById('addForm');
const itemsList = document.getElementById('itemsList');
const emptyState = document.getElementById('emptyState');
const searchInput = document.getElementById('searchInput');
const categoryFilter = document.getElementById('categoryFilter');

// Initialize app
document.addEventListener('DOMContentLoaded', function() {{
    renderItems();
    updateCategoryFilter();
    
    // Event listeners
    addForm.addEventListener('submit', addItem);
    searchInput.addEventListener('input', filterItems);
    categoryFilter.addEventListener('change', filterItems);
}});

// Add new item
function addItem(e) {{
    e.preventDefault();
    
    const name = document.getElementById('itemName').value;
    const category = document.getElementById('itemCategory').value || 'General';
    const quantity = parseInt(document.getElementById('itemQuantity').value) || 0;
    const price = parseFloat(document.getElementById('itemPrice').value) || 0;
    const description = document.getElementById('itemDescription').value;
    
    const newItem = {{
        id: Date.now(),
        name,
        category,
        quantity,
        price,
        description,
        createdDate: new Date().toLocaleDateString()
    }};
    
    items.push(newItem);
    categories.add(category);
    
    saveToStorage();
    renderItems();
    updateCategoryFilter();
    addForm.reset();
    
    // Show success message
    showMessage('Item added successfully!', 'success');
}}

// Render items
function renderItems(filteredItems = items) {{
    if (filteredItems.length === 0) {{
        itemsList.style.display = 'none';
        emptyState.style.display = 'block';
        return;
    }}
    
    itemsList.style.display = 'grid';
    emptyState.style.display = 'none';
    
    itemsList.innerHTML = filteredItems.map(item => `
        <div class="item-card">
            <h3>${{item.name}}</h3>
            <p>${{item.description || 'No description'}}</p>
            <div class="item-meta">
                <span class="category">${{item.category}}</span>
                <span class="quantity">Qty: ${{item.quantity}}</span>
                <span class="price">$${{item.price.toFixed(2)}}</span>
            </div>
            <div class="item-actions">
                <button class="btn-delete" onclick="deleteItem(${{item.id}})">
                    Delete
                </button>
            </div>
        </div>
    `).join('');
}}

// Delete item
function deleteItem(id) {{
    if (confirm('Are you sure you want to delete this item?')) {{
        items = items.filter(item => item.id !== id);
        saveToStorage();
        renderItems();
        updateCategoryFilter();
        showMessage('Item deleted successfully!', 'success');
    }}
}}

// Filter items
function filterItems() {{
    const searchTerm = searchInput.value.toLowerCase();
    const selectedCategory = categoryFilter.value;
    
    let filtered = items.filter(item => {{
        const matchesSearch = item.name.toLowerCase().includes(searchTerm) ||
                            item.description.toLowerCase().includes(searchTerm);
        const matchesCategory = !selectedCategory || item.category === selectedCategory;
        
        return matchesSearch && matchesCategory;
    }});
    
    renderItems(filtered);
}}

// Update category filter
function updateCategoryFilter() {{
    categories.clear();
    items.forEach(item => categories.add(item.category));
    
    categoryFilter.innerHTML = '<option value="">All Categories</option>' +
        Array.from(categories).map(cat => `<option value="${{cat}}">${{cat}}</option>`).join('');
}}

// Save to localStorage
function saveToStorage() {{
    localStorage.setItem('items', JSON.stringify(items));
}}

// Show message
function showMessage(message, type) {{
    const messageDiv = document.createElement('div');
    messageDiv.className = `message message-${{type}}`;
    messageDiv.textContent = message;
    messageDiv.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: ${{type === 'success' ? '#28a745' : '#dc3545'}};
        color: white;
        padding: 15px 20px;
        border-radius: 8px;
        z-index: 1000;
        animation: slideIn 0.3s ease;
    `;
    
    document.body.appendChild(messageDiv);
    
    setTimeout(() => {{
        messageDiv.remove();
    }}, 3000);
}}

// Add CSS animation
const style = document.createElement('style');
style.textContent = `
    @keyframes slideIn {{
        from {{ transform: translateX(100%); opacity: 0; }}
        to {{ transform: translateX(0); opacity: 1; }}
    }}
`;
document.head.appendChild(style);'''
    
    def _generate_package_json(self, project_name: str) -> str:
        return f'''{{
  "name": "{project_name.lower()}",
  "version": "1.0.0",
  "description": "{project_name} - Generated by Jarvis",
  "main": "server.js",
  "scripts": {{
    "start": "node server.js",
    "dev": "nodemon server.js"
  }},
  "dependencies": {{
    "express": "^4.18.0",
    "cors": "^2.8.5",
    "body-parser": "^1.20.0"
  }},
  "devDependencies": {{
    "nodemon": "^2.0.20"
  }}
}}'''
    
    def _generate_requirements(self, project_type: str) -> str:
        if project_type == 'api':
            return "fastapi>=0.68.0\nuvicorn>=0.15.0\npydantic>=1.8.0"
        else:
            return "Flask>=2.0.0\nrequests>=2.25.0"
    
    def _generate_maven_pom(self, project_name: str) -> str:
        return f'''<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.jarvis</groupId>
    <artifactId>{project_name.lower()}</artifactId>
    <version>1.0.0</version>
    <properties>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
            <version>2.7.0</version>
        </dependency>
    </dependencies>
</project>'''
    
    def create_project_on_desktop(self, project_data: Dict) -> str:
        try:
            project_name = project_data['project_name']
            project_path = self.desktop_path / project_name
            
            project_path.mkdir(exist_ok=True)
            
            for filename, content in project_data['files'].items():
                file_path = project_path / filename
                file_path.parent.mkdir(parents=True, exist_ok=True)
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(content)
            
            return f"Project '{project_name}' created successfully at: {project_path}"
            
        except Exception as e:
            return f"Error creating project: {str(e)}"

auto_code_architect = AutoCodeArchitect()

def generate_inline_code(query: str) -> str:
    """Generate inline code snippets"""
    query_lower = query.lower()
    
    # Detect programming language
    language = 'python'  # default
    if ' c ' in query_lower or query_lower.startswith('c ') or query_lower.endswith(' c'):
        language = 'c'
    elif 'java' in query_lower:
        language = 'java'
    elif 'javascript' in query_lower or 'js' in query_lower:
        language = 'javascript'
    elif 'cpp' in query_lower or 'c++' in query_lower:
        language = 'cpp'
    
    if 'add' in query_lower and 'number' in query_lower:
        if language == 'c':
            return """#include <stdio.h>

int add_two_numbers(int a, int b) {
    return a + b;
}

int main() {
    int num1, num2, result;
    printf("Enter first number: ");
    scanf("%d", &num1);
    printf("Enter second number: ");
    scanf("%d", &num2);
    result = add_two_numbers(num1, num2);
    printf("Sum: %d\n", result);
    return 0;
}"""
        elif language == 'java':
            return """import java.util.Scanner;

public class AddNumbers {
    public static int addTwoNumbers(int a, int b) {
        return a + b;
    }
    
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter first number: ");
        int num1 = scanner.nextInt();
        System.out.print("Enter second number: ");
        int num2 = scanner.nextInt();
        int result = addTwoNumbers(num1, num2);
        System.out.println("Sum: " + result);
        scanner.close();
    }
}"""
        elif language == 'javascript':
            return """function addTwoNumbers(a, b) {
    return a + b;
}

// Example usage
const num1 = parseFloat(prompt("Enter first number: "));
const num2 = parseFloat(prompt("Enter second number: "));
const result = addTwoNumbers(num1, num2);
console.log(`Sum: ${result}`);
alert(`Sum: ${result}`);"""
        else:  # Python
            return """def add_two_numbers(a, b):
    return a + b

# Example usage
num1 = float(input("Enter first number: "))
num2 = float(input("Enter second number: "))
result = add_two_numbers(num1, num2)
print(f"Sum: {result}")"""
    
    elif 'calculator' in query_lower:
        return """def calculator(a, b, operation):
    if operation == '+':
        return a + b
    elif operation == '-':
        return a - b
    elif operation == '*':
        return a * b
    elif operation == '/':
        return a / b if b != 0 else "Cannot divide by zero"
    else:
        return "Invalid operation"

# Full calculator program
while True:
    try:
        num1 = float(input("Enter first number: "))
        operation = input("Enter operation (+, -, *, /): ")
        num2 = float(input("Enter second number: "))
        
        result = calculator(num1, num2, operation)
        print(f"Result: {result}")
        
        if input("Continue? (y/n): ").lower() != 'y':
            break
    except ValueError:
        print("Invalid input! Please enter numbers.")"""
    
    elif 'factorial' in query_lower:
        return """def factorial(n):
    if n == 0 or n == 1:
        return 1
    return n * factorial(n - 1)

# Example usage
num = int(input("Enter a number: "))
if num < 0:
    print("Factorial is not defined for negative numbers")
else:
    result = factorial(num)
    print(f"Factorial of {num} is {result}")"""
    
    elif 'fibonacci' in query_lower:
        return """def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

# Example usage
num = int(input("Enter number of terms: "))
print(f"Fibonacci sequence for {num} terms:")
for i in range(num):
    print(fibonacci(i), end=" ")
print()"""
    
    elif 'sort' in query_lower:
        return """def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr

# Example usage
numbers = [64, 34, 25, 12, 22, 11, 90]
print(f"Original array: {numbers}")
sorted_numbers = bubble_sort(numbers.copy())
print(f"Sorted array: {sorted_numbers}")"""
    
    else:
        # Generate complete working code based on query keywords
        if 'prime' in query_lower:
            return """def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

# Example usage
num = int(input("Enter a number: "))
if is_prime(num):
    print(f"{num} is a prime number")
else:
    print(f"{num} is not a prime number")"""
        
        else:
            return f"""# Complete implementation for: {query}
def main():
    print("Program started")
    # Add your implementation here
    result = "Hello World"
    print(f"Result: {{result}}")
    return result

if __name__ == "__main__":
    main()"""

def write_code_at_cursor(code: str, file_path: str) -> str:
    """Write code at cursor position in active file"""
    try:
        # For now, append to end of file (cursor position detection would need IDE integration)
        with open(file_path, 'a', encoding='utf-8') as f:
            f.write('\n\n' + code + '\n')
        return f"Code written to {file_path}"
    except Exception as e:
        return f"Error writing code: {str(e)}"

def generate_code_project(query: str) -> str:
    try:
        # Check if user wants inline code
        if any(word in query.lower() for word in ['write here', 'cursor', 'inline', 'here']):
            code = generate_inline_code(query)
            
            # Write at actual cursor position using clipboard method
            import pyautogui
            import pyperclip
            
            try:
                # Copy code to clipboard
                pyperclip.copy(code)
                
                # Paste at current cursor position
                pyautogui.hotkey('ctrl', 'v')
                
                return f"Code written at cursor position"
            except:
                # Fallback: write to active file
                active_file = r"c:\Users\Hp\Desktop\inp\run.py"
                with open(active_file, 'a', encoding='utf-8') as f:
                    f.write('\n\n' + code + '\n')
                return f"Code appended to run.py"
        
        # Otherwise create project
        request_info = auto_code_architect.detect_request_type(query)
        result = auto_code_architect.generate_code(request_info)
        
        creation_result = auto_code_architect.create_project_on_desktop(result)
        return f"Creating project on Desktop...\n\n{creation_result}\n\nProject Type: {result['project_type']}\nLanguage: {result['language']}"
    
    except Exception as e:
        return f"Error generating code: {str(e)}"
import pyttsx3
import speech_recognition as sr
import eel
import time
import threading
import json
import numpy as np
from datetime import datetime, timedelta
import random
import os
import subprocess
import schedule
from engine.command_history import command_history

# Emotion Detection System
class EmotionSystem:
    def __init__(self):
        self.current_emotion = 'neutral'
        self.enabled = False
        self.emotion_history = []
        self.monitoring = False
        self.monitor_thread = None
        self.emotion_file = 'emotion_config.json'
        self.load_emotion_data()
        
        # Emotion response templates
        self.responses = {
            'happy': {
                'greetings': ["Great to see you in such a good mood!", "You sound wonderful today!"],
                'acknowledgments': ["Absolutely! Let's keep this positive momentum!", "Perfect! I'm excited to help!"],
                'completions': ["Done! Hope that keeps your day bright!", "All set! Keep that smile going!"]
            },
            'sad': {
                'greetings': ["I'm here for you. How can I help?", "Let me help make things easier."],
                'acknowledgments': ["I understand. Let me take care of that.", "Of course. I'll handle this gently."],
                'completions': ["All done. I hope this helps a little.", "Completed. Take care of yourself."]
            },
            'stressed': {
                'greetings': ["I can sense you're under pressure. Let me help.", "Take a deep breath. I'll handle this."],
                'acknowledgments': ["Got it. I'll take care of this quickly.", "I'll make this as smooth as possible."],
                'completions': ["Done efficiently. One less thing on your plate!", "Completed quickly. Hope that helps."]
            },
            'angry': {
                'greetings': ["I understand you're frustrated. Let me help.", "I'm here to help make things right."],
                'acknowledgments': ["I understand your frustration. I'll handle this carefully.", "Got it. Let me fix this properly."],
                'completions': ["Completed. I hope this helps resolve the issue.", "Done correctly. Let me know if you need more help."]
            },
            'excited': {
                'greetings': ["I love your enthusiasm! What are we doing today?", "Your energy is incredible!"],
                'acknowledgments': ["Yes! I'm as excited as you are!", "Absolutely! This is going to be fantastic!"],
                'completions': ["Done! That was as exciting as I hoped!", "Completed with enthusiasm! What's next?"]
            },
            'neutral': {
                'greetings': ["Hello! How can I help you today?", "Hi there! I'm ready to help."],
                'acknowledgments': ["Understood. I'll take care of that.", "Got it. Working on it now."],
                'completions': ["Task completed successfully.", "All done! Anything else?"]
            }
        }
    
    def detect_emotion_from_text(self, text):
        """AI-powered emotion detection using Groq"""
        try:
            from groq import Groq
            from engine.groq_config import GROQ_API_KEY
            
            client = Groq(api_key=GROQ_API_KEY)
            
            prompt = f'Analyze emotion in: "{text}". Return only one word: happy, sad, stressed, angry, excited, or neutral.'
            
            response = client.chat.completions.create(
                messages=[{"role": "user", "content": prompt}],
                model="llama-3.1-8b-instant",
                max_tokens=10
            )
            
            emotion = response.choices[0].message.content.strip().lower()
            
            # Validate emotion
            valid_emotions = ['happy', 'sad', 'stressed', 'angry', 'excited', 'neutral']
            return emotion if emotion in valid_emotions else 'neutral'
            
        except Exception as e:
            print(f"Groq emotion detection error: {e}")
            # Fallback to keyword detection
            text = text.lower()
            if any(word in text for word in ['great', 'awesome', 'fantastic', 'love', 'happy']):
                return 'happy'
            elif any(word in text for word in ['sad', 'down', 'upset', 'cry']):
                return 'sad'
            elif any(word in text for word in ['stress', 'busy', 'overwhelmed', 'pressure']):
                return 'stressed'
            elif any(word in text for word in ['angry', 'mad', 'frustrated']):
                return 'angry'
            elif any(word in text for word in ['amazing', 'incredible', 'wow', 'excited']):
                return 'excited'
            else:
                return 'neutral'
    
    def load_emotion_data(self):
        """Load emotion data from file"""
        try:
            if os.path.exists(self.emotion_file):
                with open(self.emotion_file, 'r') as f:
                    data = json.load(f)
                    self.current_emotion = data.get('last_emotion', 'neutral')
                    self.emotion_history = data.get('emotion_history', [])
                    self.enabled = data.get('enabled', False)
                pass  # Silent loading
        except Exception as e:
            print(f"Error loading emotion data: {e}")
    
    def save_emotion_data(self):
        """Save emotion data to file"""
        try:
            data = {
                'enabled': self.enabled,
                'sensitivity': 0.7,
                'last_emotion': self.current_emotion,
                'timestamp': datetime.now().isoformat(),
                'emotion_history': self.emotion_history
            }
            with open(self.emotion_file, 'w') as f:
                json.dump(data, f)
            pass  # Silent saving
        except Exception as e:
            print(f"Error saving emotion data: {e}")
    
    def update_emotion(self, emotion):
        """Update current emotion"""
        self.current_emotion = emotion
        self.emotion_history.append({
            'emotion': emotion,
            'timestamp': datetime.now().isoformat()
        })
        if len(self.emotion_history) > 10:
            self.emotion_history = self.emotion_history[-10:]
        self.save_emotion_data()
    
    def get_adaptive_response(self, base_text, emotion="neutral"):
        """Fully rephrase sentence with same meaning and emotional tone"""
        if not self.enabled:
            return base_text
        
        try:
            from groq import Groq
            from engine.groq_config import GROQ_API_KEY
            
            client = Groq(api_key=GROQ_API_KEY)
            
            prompt = f'''Rephrase this message for someone feeling {self.current_emotion}: "{base_text}"

Rules:
- Keep EXACT same meaning and information
- Change wording to match {self.current_emotion} tone
- Return ONLY the rephrased sentence
- No explanations or alternatives
- Keep similar length

Examples:
Original: "File uploaded successfully"
Happy: "Your file has been successfully uploaded! üéâ"
Sad: "I've managed to upload your file for you"

Rephrase: "{base_text}"'''
            
            response = client.chat.completions.create(
                messages=[{"role": "user", "content": prompt}],
                model="llama-3.1-8b-instant",
                max_tokens=100,
                temperature=0.8
            )
            
            adapted_text = response.choices[0].message.content.strip()
            
            # Extract only the first sentence, remove any explanations
            if adapted_text:
                # Split by common separators and take first part
                first_sentence = adapted_text.split('\n')[0].split('.')[0]
                if '"' in first_sentence:
                    # Extract text between quotes if present
                    import re
                    quoted = re.findall(r'"([^"]+)"', first_sentence)
                    if quoted:
                        return quoted[0]
                return first_sentence if first_sentence else base_text
            return base_text
            
        except Exception as e:
            print(f"Groq rephrasing error: {e}")
            return base_text
    
    def get_encouraging_response(self):
        """Get AI-powered encouraging message"""
        try:
            from groq import Groq
            from engine.groq_config import GROQ_API_KEY
            
            client = Groq(api_key=GROQ_API_KEY)
            
            prompt = f'''Generate a warm, encouraging message for someone feeling {self.current_emotion}.
            
Make it:
            - Personal and caring
            - Natural and conversational
            - Specifically tailored to {self.current_emotion} emotion
            - 10-20 words maximum
            - Avoid clich√©s, be genuine and supportive'''
            
            response = client.chat.completions.create(
                messages=[{"role": "user", "content": prompt}],
                model="llama-3.1-8b-instant",
                max_tokens=60
            )
            
            return response.choices[0].message.content.strip()
            
        except Exception as e:
            print(f"Groq encouragement error: {e}")
            return "I'm here for you."  # Simple fallback
    
    def get_humor_response(self):
        """Get AI-powered appropriate humor"""
        try:
            from groq import Groq
            from engine.groq_config import GROQ_API_KEY
            
            client = Groq(api_key=GROQ_API_KEY)
            
            prompt = f'''Tell a gentle, appropriate joke for someone feeling {self.current_emotion}.
            
Make it:
            - Light and uplifting
            - Appropriate for their {self.current_emotion} mood
            - Clean and family-friendly
            - Under 25 words
            - Genuinely funny but sensitive to their emotional state'''
            
            response = client.chat.completions.create(
                messages=[{"role": "user", "content": prompt}],
                model="llama-3.1-8b-instant",
                max_tokens=80
            )
            
            return response.choices[0].message.content.strip()
            
        except Exception as e:
            print(f"Groq humor error: {e}")
            return "Here's a smile for you! üòä"  # Simple fallback
    
    def start_real_time_monitoring(self):
        """Start continuous emotion monitoring"""
        if self.monitoring:
            return
        
        self.monitoring = True
        self.monitor_thread = threading.Thread(target=self._monitor_loop, daemon=True)
        self.monitor_thread.start()
        print("Real-time emotion monitoring started")
    
    def stop_real_time_monitoring(self):
        """Stop continuous emotion monitoring"""
        self.monitoring = False
        if self.monitor_thread:
            self.monitor_thread.join(timeout=1)
        
        # Clean up temp file
        if hasattr(self, 'temp_audio_file'):
            try:
                import os
                os.unlink(self.temp_audio_file)
                delattr(self, 'temp_audio_file')
            except:
                pass
        
        print("Real-time emotion monitoring stopped")
    
    def _monitor_loop(self):
        """Background monitoring loop"""
        try:
            import cv2
            import pyaudio
            import numpy as np
            
            # Initialize camera and audio
            cap = cv2.VideoCapture(0)
            p = pyaudio.PyAudio()
            
            stream = p.open(
                format=pyaudio.paFloat32,
                channels=1,
                rate=22050,
                input=True,
                frames_per_buffer=1024
            )
            
            while self.monitoring:
                try:
                    # Analyze voice tone continuously with larger buffer for better accuracy
                    audio_data = stream.read(2048, exception_on_overflow=False)  # Larger buffer
                    audio_array = np.frombuffer(audio_data, dtype=np.float32)
                    
                    # Accumulate audio for better analysis
                    if not hasattr(self, 'audio_buffer'):
                        self.audio_buffer = []
                    
                    self.audio_buffer.extend(audio_array)
                    
                    # Analyze when we have enough data (2 seconds for better accuracy)
                    if len(self.audio_buffer) >= 44100:  # 2 seconds at 22050 Hz
                        analysis_data = np.array(self.audio_buffer[-44100:])  # Last 2 seconds
                        
                        # Only analyze if significant audio and enough time passed
                        if not hasattr(self, 'last_analysis_time'):
                            self.last_analysis_time = 0
                        
                        current_time = time.time()
                        if (np.max(np.abs(analysis_data)) > 0.01 and 
                            current_time - self.last_analysis_time >= 5):  # Analyze every 5 seconds max
                            
                            voice_emotion = self._analyze_voice_tone(analysis_data)
                            if voice_emotion != 'neutral' and voice_emotion != self.current_emotion:
                                old_emotion = self.current_emotion
                                self.update_emotion(voice_emotion)
                                print(f"Voice emotion: {old_emotion} ‚Üí {voice_emotion}")
                            
                            self.last_analysis_time = current_time
                        
                        # Keep only last 3 seconds of audio
                        if len(self.audio_buffer) > 66150:
                            self.audio_buffer = self.audio_buffer[-66150:]
                    
                    # Analyze face emotion every 30 minutes
                    current_time = time.time()
                    if not hasattr(self, 'last_face_check'):
                        self.last_face_check = current_time
                    
                    if current_time - self.last_face_check >= 1800:  # 30 minutes = 1800 seconds
                        ret, frame = cap.read()
                        if ret:
                            emotion = self._analyze_face_emotion(frame)
                            if emotion != 'neutral' and emotion != self.current_emotion:
                                old_emotion = self.current_emotion
                                self.update_emotion(emotion)
                                print(f"Face emotion (30min check): {old_emotion} ‚Üí {emotion}")
                        self.last_face_check = current_time
                    
                    time.sleep(0.05)  # Check voice every 0.05 seconds for better responsiveness
                    
                except Exception as e:
                    print(f"Monitoring error: {e}")
                    time.sleep(1)
            
            cap.release()
            stream.stop_stream()
            stream.close()
            p.terminate()
            
        except Exception as e:
            print(f"Monitor setup error: {e}")
    
    def _analyze_face_emotion(self, frame):
        """Advanced face emotion analysis without API calls"""
        try:
            import cv2
            
            # Convert to grayscale
            gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
            
            # Face detection
            face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')
            faces = face_cascade.detectMultiScale(gray, 1.1, 4)
            
            if len(faces) > 0:
                x, y, w, h = faces[0]
                face_roi = gray[y:y+h, x:x+w]
                
                # Advanced facial feature analysis
                brightness = np.mean(face_roi)
                contrast = np.std(face_roi)
                
                # Edge detection for expression analysis
                edges = cv2.Canny(face_roi, 50, 150)
                edge_density = np.sum(edges > 0) / (w * h)
                
                # Advanced emotion classification
                if brightness > 130 and edge_density < 0.1:
                    return 'happy'
                elif brightness < 70:
                    return 'sad'
                elif edge_density > 0.15:
                    return 'stressed'
                elif contrast > 80:
                    return 'angry'
                else:
                    return 'neutral'
            
            # Fallback for no face detected
            brightness = np.mean(gray)
            contrast = np.std(gray)
            
            if brightness > 130 and contrast > 45:
                return 'happy'
            elif brightness < 70:
                return 'sad'
            elif contrast > 70:
                return 'stressed'
            else:
                return 'neutral'
                
        except Exception as e:
            return 'neutral'
    
    def _analyze_voice_tone(self, audio_data):
        """Advanced voice emotion detection using audio features"""
        try:
            # Calculate advanced audio features
            energy = np.sum(audio_data**2) / len(audio_data)
            zcr = np.sum(np.diff(np.sign(audio_data)) != 0) / len(audio_data)
            
            # Calculate pitch variation (spectral features)
            fft = np.fft.fft(audio_data)
            magnitude = np.abs(fft)
            spectral_centroid = np.sum(magnitude * np.arange(len(magnitude))) / np.sum(magnitude)
            
            # Advanced emotion classification
            if energy > 0.01 and zcr < 0.1 and spectral_centroid > 5000:
                return 'excited'
            elif energy > 0.003 and zcr < 0.15 and spectral_centroid > 3000:
                return 'happy'
            elif energy < 0.001 or spectral_centroid < 1000:
                return 'sad'
            elif zcr > 0.25 and energy > 0.002:
                return 'stressed'
            elif energy > 0.005 and zcr > 0.2:
                return 'angry'
            else:
                return 'neutral'
                
        except Exception as e:
            # Simple fallback
            energy = np.sum(audio_data**2) / len(audio_data)
            if energy > 0.01:
                return 'excited'
            elif energy > 0.003:
                return 'happy'
            elif energy < 0.001:
                return 'sad'
            else:
                return 'neutral'
    
    def get_voice_settings(self):
        """Get TTS settings based on emotion"""
        settings = {
            'happy': {'rate': 200, 'volume': 0.9},
            'excited': {'rate': 220, 'volume': 1.0},
            'sad': {'rate': 140, 'volume': 0.6},
            'stressed': {'rate': 160, 'volume': 0.7},
            'angry': {'rate': 180, 'volume': 0.8},
            'calm': {'rate': 150, 'volume': 0.8},
            'neutral': {'rate': 174, 'volume': 0.9}
        }
        # Silent voice settings
        return settings.get(self.current_emotion, settings['neutral'])
    
    def enable(self):
        self.enabled = True
        self.save_emotion_data()
        self.start_real_time_monitoring()
        return "Emotion detection enabled. I'll now monitor your mood and adapt in real-time."
    
    def disable(self):
        self.enabled = False
        self.save_emotion_data()
        self.stop_real_time_monitoring()
        return "Emotion detection disabled."
    
    def get_status(self):
        if self.enabled:
            return f"Emotion detection active. Current emotion: {self.current_emotion}. Real-time monitoring: {'ON' if self.monitoring else 'OFF'}"
        return "Emotion detection disabled"

# Global emotion system
emotion_system = EmotionSystem()

# Scheduler System
class TaskScheduler:
    def __init__(self):
        self.scheduled_tasks = []
        self.scheduler_thread = None
        self.running = False
        self.tasks_file = 'scheduled_tasks.json'
        self.load_tasks()
    
    def load_tasks(self):
        try:
            if os.path.exists(self.tasks_file):
                with open(self.tasks_file, 'r') as f:
                    self.scheduled_tasks = json.load(f)
        except:
            self.scheduled_tasks = []
    
    def save_tasks(self):
        try:
            with open(self.tasks_file, 'w') as f:
                json.dump(self.scheduled_tasks, f)
        except Exception as e:
            print(f"Save tasks error: {e}")
    
    def schedule_task(self, task_command, schedule_time):
        try:
            task = {
                'command': task_command,
                'time': schedule_time,
                'created': datetime.now().isoformat(),
                'executed': False
            }
            self.scheduled_tasks.append(task)
            self.save_tasks()
            
            # Parse time and schedule
            time_lower = schedule_time.lower().strip()
            
            if 'am' in time_lower or 'pm' in time_lower:
                # Handle AM/PM format (e.g., "2am", "2:30pm")
                clean_time = time_lower.replace(' ', '')
                schedule.every().day.at(clean_time).do(self._execute_task, task_command)
            elif 'second' in time_lower or 'sec' in time_lower:
                # Handle seconds (e.g., "30 seconds", "5sec")
                import re
                match = re.search(r'(\d+)', time_lower)
                if match:
                    secs = int(match.group(1))
                    schedule.every(secs).seconds.do(self._execute_task, task_command)
            elif 'minute' in time_lower or 'min' in time_lower:
                # Handle minutes (e.g., "5 minutes", "10min")
                import re
                match = re.search(r'(\d+)', time_lower)
                if match:
                    mins = int(match.group(1))
                    schedule.every(mins).minutes.do(self._execute_task, task_command)
            elif 'hour' in time_lower or 'hr' in time_lower:
                # Handle hours (e.g., "2 hours", "1hr")
                import re
                match = re.search(r'(\d+)', time_lower)
                if match:
                    hrs = int(match.group(1))
                    schedule.every(hrs).hours.do(self._execute_task, task_command)
            else:
                # Try to parse as time format (e.g., "14:30", "2:00")
                try:
                    schedule.every().day.at(time_lower).do(self._execute_task, task_command)
                except:
                    return f"Invalid time format: {schedule_time}"
            
            self._start_scheduler()
            return f"Task scheduled: {task_command} at {schedule_time}"
        except Exception as e:
            return f"Schedule error: {e}"
    
    def _execute_task(self, command):
        try:
            print(f"Executing scheduled task: {command}")
            if 'open notepad' in command:
                subprocess.Popen(['notepad.exe'])
                print(f"Opened notepad")
            elif 'open' in command:
                app = command.replace('open ', '')
                subprocess.Popen([app])
                print(f"Opened {app}")
            else:
                # Execute as dual AI command
                from engine.dual_ai import dual_ai
                response = dual_ai.execute(command)
                print(f"Dual AI response: {response}")
                # Speak the response
                try:
                    speak(response)
                except:
                    print("Could not speak response")
            return schedule.CancelJob  # Cancel this job after execution
        except Exception as e:
            print(f"Task execution error: {e}")
            return schedule.CancelJob  # Cancel even on error
    
    def _start_scheduler(self):
        if not self.running:
            self.running = True
            self.scheduler_thread = threading.Thread(target=self._scheduler_loop, daemon=True)
            self.scheduler_thread.start()
    
    def _scheduler_loop(self):
        while self.running:
            schedule.run_pending()
            time.sleep(1)  # Check every second for better precision
    
    def list_tasks(self):
        if not self.scheduled_tasks:
            return "No scheduled tasks"
        tasks = "Scheduled tasks: "
        for task in self.scheduled_tasks[-5:]:
            tasks += f"{task['command']} at {task['time']}, "
        return tasks

# Global scheduler
task_scheduler = TaskScheduler()

# Continuous listening variables
continuous_active = False
continuous_listener = None
listening_paused = False
jarvis_muted = False

def speak(text):
    global jarvis_muted
    text = str(text)
    
    # Check if Jarvis is muted
    if jarvis_muted:
        print(f"[MUTED] Jarvis: {text}")
        return
    
    # Transform text with personality manager
    try:
        from engine.personality_manager import personality_manager
        text = personality_manager.transform_response(text)
    except Exception as e:
        print(f"Personality transform error: {e}")
    
    # Apply emotion-based adaptation
    try:
        text = emotion_system.get_adaptive_response(text)
    except Exception as e:
        print(f"Emotion adaptation error: {e}")
    
    # Get emotion-based voice settings
    voice_settings = emotion_system.get_voice_settings() if emotion_system.enabled else {'rate': 174, 'volume': 0.9}
    
    # Get current language from multilingual support
    try:
        from engine.multilingual_support import multilingual
        current_language = multilingual.current_language
    except:
        current_language = 'english'
    
    # Update command history with response
    try:
        if hasattr(command_history, 'history') and command_history.history:
            last_entry = command_history.history[-1]
            if last_entry.get('jarvis_response') == "Processing...":
                last_entry['jarvis_response'] = text
                command_history.save_history()
    except Exception as e:
        print(f"History update error: {e}")
    
    try:
        eel.DisplayMessage(text)
    except:
        print(f"Jarvis: {text}")
    
    # Handle TTS based on language
    try:
        # For non-English languages, use gTTS
        if current_language != 'english':
            try:
                from gtts import gTTS
                import pygame
                import io
                import os
                
                # Get language code for gTTS
                lang_codes = {
                    'kannada': 'kn',
                    'hindi': 'hi',
                    'bengali': 'bn',
                    'gujarati': 'gu',
                    'malayalam': 'ml',
                    'marathi': 'mr',
                    'tamil': 'ta',
                    'telugu': 'te',
                    'urdu': 'ur'
                }
                
                lang_code = lang_codes.get(current_language, 'en')
                
                # Generate speech using gTTS
                tts = gTTS(text=text, lang=lang_code, slow=False)
                
                # Save to memory buffer
                mp3_buffer = io.BytesIO()
                tts.write_to_fp(mp3_buffer)
                mp3_buffer.seek(0)
                
                # Play using pygame
                pygame.mixer.init()
                pygame.mixer.music.load(mp3_buffer)
                pygame.mixer.music.play()
                
                # Wait for playback to complete
                while pygame.mixer.music.get_busy():
                    pygame.time.wait(100)
                
                pygame.mixer.quit()
                
            except Exception as e:
                print(f"gTTS error: {e}")
                # Fallback to voice gender control for non-English
                from engine.voice_gender_control import voice_control
                voice_control.speak_with_gender(text)
        else:
            # For English, use voice gender control with emotion settings
            from engine.voice_gender_control import voice_control
            success = voice_control.speak_with_gender(text)
            if not success:
                # Final fallback to basic pyttsx3 with emotion settings
                engine = pyttsx3.init('sapi5')
                voices = engine.getProperty('voices')
                engine.setProperty('voice', voices[0].id)
                engine.setProperty('rate', voice_settings['rate'])
                engine.setProperty('volume', voice_settings['volume'])
                engine.say(text)
                engine.runAndWait()
                
    except Exception as e:
        print(f"TTS error: {e}")
        # Final fallback to basic pyttsx3 with emotion settings
        try:
            engine = pyttsx3.init('sapi5')
            voices = engine.getProperty('voices')
            engine.setProperty('voice', voices[0].id)
            engine.setProperty('rate', voice_settings['rate'])
            engine.setProperty('volume', voice_settings['volume'])
            engine.say(text)
            engine.runAndWait()
        except:
            print(f"All TTS methods failed for: {text}")
    
    try:
        eel.receiverText(text)
    except:
        pass

def takecommand():
    global listening_paused
    
    # Check if listening is paused
    if listening_paused:
        print("Listening is paused")
        return ""
    
    r = sr.Recognizer()
    with sr.Microphone() as source:
        print('listening....')
        try:
            eel.DisplayMessage('listening....')
        except:
            pass
        r.pause_threshold = 1
        r.adjust_for_ambient_noise(source)
        
        try:
            audio = r.listen(source, timeout=5, phrase_time_limit=3)
        except sr.WaitTimeoutError:
            print("Listening timeout - no speech detected")
            return ""

    try:
        print('recognizing')
        try:
            eel.DisplayMessage('recognizing....')
        except:
            pass
        
        # Get current language for speech recognition
        try:
            from engine.multilingual_support import multilingual
            current_language = multilingual.current_language
        except:
            current_language = 'english'
        
        # Set recognition language based on current language
        try:
            from engine.multilingual_support import multilingual
            recognition_language = multilingual.get_speech_recognition_language()
        except:
            recognition_language = 'en-IN'
        
        query = r.recognize_google(audio, language=recognition_language)
        print(f"user said: {query}")
        try:
            eel.DisplayMessage(query)
        except:
            pass
        time.sleep(1)
    except Exception as e:
        print(f"Recognition error: {e}")
        return ""
    
    return query.lower()

# Expose takecommand for chatbot use
@eel.expose
def chatbot_listen():
    return takecommand()

def parse_multiple_commands(query):
    """Parse multiple commands from a single query"""
    import re
    
    # Common separators for multiple commands
    separators = [
        r'\s+and\s+then\s+',
        r'\s+then\s+',
        r'\s+and\s+',
        r'\s*,\s*and\s+',
        r'\s*,\s*then\s+',
        r'\s*,\s*'
    ]
    
    # Try each separator to split the query
    commands = [query.strip()]
    
    for separator in separators:
        temp_commands = []
        for cmd in commands:
            split_cmds = re.split(separator, cmd, flags=re.IGNORECASE)
            if len(split_cmds) > 1:
                temp_commands.extend([c.strip() for c in split_cmds if c.strip()])
            else:
                temp_commands.append(cmd)
        commands = temp_commands
        if len(commands) > 1:
            break
    
    # Filter out empty commands and very short ones
    commands = [cmd for cmd in commands if cmd and len(cmd.strip()) > 2]
    
    return commands

@eel.expose
def allCommands(message=1):
    is_voice_input = False
    if message == 1:
        query = takecommand()
        print(query)
        eel.senderText(query)
        is_voice_input = True
    else:
        query = message
        try:
            eel.senderText(query)
        except:
            print(f"User: {query}")
        is_voice_input = False
    
    # Store the user command immediately
    if query and query.strip():
        command_history.add_command(query, "Processing...", is_voice_input)
    
    # Check for aura mode at the beginning
    if "aura" in query.lower():
        try:
            from engine.ultimate_ai_executor import ultimate_ai
            print(f"üåü AURA Mode Activated for: {query}")
          
            
            # Remove "aura" from query and execute with ultimate AI
            clean_query = query.lower().replace("aura", "").strip()
            if clean_query:
                # Execute and get AI-generated response from ultimate AI
                response = ultimate_ai.execute(clean_query)
                if response:
                    speak(response)  # Speak the response from ultimate AI
                    
                    # Wait 1 second then show next move prediction
                    time.sleep(1)
                    
                    # Get next move suggestion from ultimate AI
                    try:
                        suggestions = ultimate_ai.predict_next_move(clean_query)
                        if suggestions and len(suggestions) > 0:
                            suggestion = suggestions[0]
                            print(f"\nü§ñ AI Suggestion: {suggestion}")
                            
                            # Get simple yes/no confirmation
                            speak(f"Execute {suggestion}?")
                            confirmation = takecommand()  # Get voice input directly
                            
                            if confirmation and ("yes" in confirmation.lower() or "y" in confirmation.lower()):
                                print(f"üöÄ Executing: {suggestion}")
                                speak("Executing suggestion")
                                # Execute suggestion using full Ultimate AI system
                                ultimate_ai.execute(suggestion)
                            else:
                                print("üëç Skipping suggestion")
                                speak("Skipping suggestion")
                    except Exception as e:
                        print(f"Next move error: {e}")
                else:
                    speak("Command completed")
            else:
                speak("Please specify what you want me to do with aura mode")
            
            try:
                eel.ShowHood()
            except:
                pass
            return
            
        except Exception as e:
            print(f"Ultimate AI Error: {e}")
            speak("Aura mode failed. Switching to standard mode.")
            # Continue with normal processing
    
    try:
        print(f"Processing query: '{query}'")
        
        # Detect emotion from user input only if it came from voice
        if emotion_system.enabled and is_voice_input:
            detected_emotion = emotion_system.detect_emotion_from_text(query)
            emotion_system.update_emotion(detected_emotion)
            print(f"Detected emotion: {detected_emotion}")
        elif emotion_system.enabled and not is_voice_input:
            print("Command line input - skipping emotion detection")
        
        # Parse multiple commands
        commands = parse_multiple_commands(query)
        
        if len(commands) > 1:
            print(f"Multiple commands detected: {commands}")
            speak(f"Executing {len(commands)} commands")
            
            # Execute each command sequentially
            for i, cmd in enumerate(commands, 1):
                print(f"Executing command {i}/{len(commands)}: {cmd}")
                try:
                    # Add small delay between commands
                    if i > 1:
                        time.sleep(0.5)
                    
                    # Process each command individually
                    process_single_command(cmd.strip())
                    
                except Exception as e:
                    print(f"Error executing command '{cmd}': {e}")
                    try:
                        speak(f"Error with command {i}")
                    except:
                        print(f"Could not speak error for command {i}")
            
            try:
                speak("All commands completed")
            except:
                print("All commands completed")                
            try:
                eel.ShowHood()
            except:
                pass
            return
        
        # Single command - use existing logic
        process_single_command(query)
        
    except Exception as e:
        print(f"Error in allCommands: {e}")
        speak("Something went wrong")
    
    try:
        eel.ShowHood()
    except:
        pass

def start_continuous_listen():
    """Start continuous listening mode"""
    global continuous_active, continuous_listener
    try:
        if continuous_listener and continuous_active:
            return "Continuous listening already active"
        
        continuous_active = True
        
        def continuous_loop():
            recognizer = sr.Recognizer()
            microphone = sr.Microphone()
            
            with microphone as source:
                recognizer.adjust_for_ambient_noise(source)
            print("‚úÖ Ready for continuous listening")
            
            while continuous_active:
                try:
                    # Check if listening is paused
                    if listening_paused:
                        print("‚è∏Ô∏è Listening paused...")
                        try:
                            eel.updateListenStatus("‚è∏Ô∏è Listening paused...")
                        except:
                            pass
                        time.sleep(1)
                        continue
                    
                    print("üéß Listening...")
                    try:
                        eel.updateListenStatus("üé§ Listening...")
                    except:
                        pass
                    
                    with microphone as source:
                        audio = recognizer.listen(source, timeout=1, phrase_time_limit=3)
                    
                    print("üîç Recognizing...")
                    try:
                        eel.updateListenStatus("üîç Recognizing...")
                    except:
                        pass
                    
                    text = recognizer.recognize_google(audio).lower()
                    if text and len(text.strip()) > 2:
                        print(f"‚úÖ Recognized: {text}")
                        try:
                            eel.updateListenStatus(f"‚úÖ Recognized: {text}")
                            eel.senderText(text)
                        except:
                            pass
                        
                        # Parse and process multiple commands
                        commands = parse_multiple_commands(text)
                        
                        if len(commands) > 1:
                            print(f"Multiple commands detected: {commands}")
                            speak(f"Executing {len(commands)} commands")
                            
                            for i, cmd in enumerate(commands, 1):
                                print(f"Executing command {i}/{len(commands)}: {cmd}")
                                try:
                                    if i > 1:
                                        time.sleep(0.5)
                                    process_single_command(cmd.strip())
                                except Exception as e:
                                    print(f"Error executing command '{cmd}': {e}")
                            
                            speak("All commands completed")
                        else:
                            # Single command
                            process_single_command(text)
                        
                        # Return to listening after response
                        time.sleep(1)
                        try:
                            eel.updateListenStatus("üé§ Listening...")
                        except:
                            pass
                        
                except sr.WaitTimeoutError:
                    print("‚è∞ Timeout - continuing to listen...")
                except sr.UnknownValueError:
                    print("‚ùì Could not understand - continuing to listen...")
                except Exception as e:
                    print(f"‚ùå Continuous listen error: {e}")
                    time.sleep(1)
        
        continuous_listener = threading.Thread(target=continuous_loop, daemon=True)
        continuous_listener.start()
        
        print("[START] Initializing continuous listening thread...")
        return "Continuous listening started - speak commands directly"
        
    except Exception as e:
        return f"Error starting continuous listening: {str(e)}"

def stop_continuous_listen():
    """Stop continuous listening mode"""
    global continuous_active, continuous_listener
    try:
        continuous_active = False
        continuous_listener = None
        return "Continuous listening stopped"
    except Exception as e:
        return f"Error stopping continuous listening: {str(e)}"

def get_continuous_listen_status():
    """Get continuous listening status"""
    global continuous_active
    try:
        if continuous_active:
            return "Continuous listening is active"
        return "Continuous listening is inactive"
    except Exception as e:
        return f"Error checking status: {str(e)}"

def pause_listening():
    """Pause listening mode"""
    global listening_paused
    try:
        listening_paused = True
        save_ui_setting('listening_paused', True)
        print("üé§ Microphone paused")
        return "Listening paused - microphone stopped"
    except Exception as e:
        return f"Error pausing listening: {str(e)}"

def resume_listening():
    """Resume listening mode"""
    global listening_paused
    try:
        listening_paused = False
        save_ui_setting('listening_paused', False)
        print("üé§ Microphone resumed")
        return "Listening resumed - microphone active"
    except Exception as e:
        return f"Error resuming listening: {str(e)}"

def mute_jarvis():
    """Mute Jarvis voice"""
    global jarvis_muted
    try:
        jarvis_muted = True
        save_ui_setting('jarvis_muted', True)
        print("Jarvis muted")
        return "Jarvis muted"
    except Exception as e:
        return f"Error muting Jarvis: {str(e)}"

def unmute_jarvis():
    """Unmute Jarvis voice"""
    global jarvis_muted
    try:
        jarvis_muted = False
        save_ui_setting('jarvis_muted', False)
        print("Jarvis unmuted")
        return "Jarvis unmuted"
    except Exception as e:
        return f"Error unmuting Jarvis: {str(e)}"

def save_ui_setting(key, value):
    """Save setting to ui_config.json"""
    try:
        import json
        config_file = 'ui_config.json'
        
        # Load existing config
        try:
            with open(config_file, 'r') as f:
                config = json.load(f)
        except:
            config = {}
        
        # Update setting
        config[key] = value
        
        # Save config
        with open(config_file, 'w') as f:
            json.dump(config, f)
    except Exception as e:
        print(f"Error saving UI setting: {e}")

def load_ui_settings():
    """Load settings from ui_config.json"""
    global listening_paused, jarvis_muted
    try:
        import json
        with open('ui_config.json', 'r') as f:
            config = json.load(f)
        
        listening_paused = config.get('listening_paused', False)
        jarvis_muted = config.get('jarvis_muted', False)
    except Exception as e:
        print(f"Error loading UI settings: {e}")
        listening_paused = False
        jarvis_muted = False

def process_single_command(query):
    """Process a single command using existing logic"""
    global jarvis_muted
    try:
        print(f"Processing single command: '{query}'")
    
    
        
        # Handle unmute command first to bypass mute check
        if "unmute jarvis" in query or "unmute voice" in query:
       
            jarvis_muted = False
            save_ui_setting('jarvis_muted', False)
            print("Jarvis unmuted")
            speak("Jarvis unmuted")
            try:
                eel.ShowHood()
            except:
                pass
            return
        
        # Direct message command with app, name, and message in one command
        if ("send message to" in query and (" on whatsapp " in query or " on mobile " in query)) or \
           ("whatsapp message to" in query) or ("sms to" in query):
        
            try:
                import re
                from engine.features import findContact, whatsApp, sendMessage
                
                # Extract app, name, and message from query
                app_type = "whatsapp" if ("whatsapp" in query or " on whatsapp " in query) else "mobile"
                
                # Extract contact name and message
                if " on whatsapp " in query:
                    # Pattern: "send message to [name] on whatsapp [message]"
                    match = re.search(r'send message to (\w+) on whatsapp (.+)', query)
                elif " on mobile " in query:
                    # Pattern: "send message to [name] on mobile [message]"
                    match = re.search(r'send message to (\w+) on mobile (.+)', query)
                elif "whatsapp message to" in query:
                    # Pattern: "whatsapp message to [name] [message]"
                    match = re.search(r'whatsapp message to (\w+) (.+)', query)
                elif "sms to" in query:
                    # Pattern: "sms to [name] [message]"
                    match = re.search(r'sms to (\w+) (.+)', query)
                    app_type = "mobile"
                else:
                    match = None
                
                if match:
                    contact_name = match.group(1)
                    message_text = match.group(2)
                    
                    # Find contact
                    contact_no, name = findContact(contact_name)
                    if contact_no != 0:
                        if app_type == "whatsapp":
                            whatsApp(contact_no, message_text, 'message', name)
                        else:
                            sendMessage(message_text, contact_no, name)
                    else:
                        speak(f"Contact {contact_name} not found")
                else:
                    speak("Please use format: send message to name on whatsapp your message")
                    
            except Exception as e:
                print(f"Direct message error: {e}")
                speak("Failed to send message")
            try:
                eel.ShowHood()
            except:
                pass
            return
        
        # Contact-based calling and messaging (existing method)
        elif "send message" in query or "phone call" in query or "video call" in query or "call" in query:
    
            from engine.features import findContact, whatsApp, makeCall, sendMessage
            contact_no, name = findContact(query)
            if contact_no != 0:
                speak("Which mode you want to use whatsapp or mobile")
                preference = takecommand()
                print(preference)

                if "mobile" in preference:
                    if "send message" in query or "send sms" in query: 
                        speak("what message to send")
                        message = takecommand()
                        sendMessage(message, contact_no, name)
                    elif "phone call" in query or "call" in query:
                        makeCall(name, contact_no)
                    else:
                        speak("please try again")
                elif "whatsapp" in preference:
                    message = ""
                    schedule_time = None
                    
                    if "send message" in query:
                        message = 'message'
                        
                        # Check for scheduling keywords
                        if " in " in query and any(word in query for word in ["second", "minute", "hour", "sec", "min", "hr"]):
                            # Extract schedule time from query
                            import re
                            time_match = re.search(r'in\s+(\d+\s*(?:second|minute|hour|sec|min|hr)s?)', query)
                            if time_match:
                                schedule_time = time_match.group(1)
                                speak(f"what message to send? It will be scheduled for {schedule_time}")
                            else:
                                speak("what message to send")
                        else:
                            speak("what message to send")
                        
                        query = takecommand()
                                        
                    elif "phone call" in query or "call" in query:
                        message = 'call'
                    else:
                        message = 'video call'
                                        
                    whatsApp(contact_no, query, message, name, schedule_time)
            eel.ShowHood()
            return
        
        # SMS Test Commands
        elif "test sms" in query or "sms test" in query:
            from engine.features import testSMS
            testSMS()
            eel.ShowHood()
            return
        
        # Phone Commands (must have "on phone" suffix)
        elif "on phone" in query:
            from engine.phone import handle_phone_commands
            if handle_phone_commands(query):
                eel.ShowHood()
                return
        
        # Voice gender switching commands - HIGHER PRIORITY than language switching
        elif any(phrase in query.lower() for phrase in ["switch to male", "switch to female", "male voice", "female voice", "current voice", "voice status"]):
        
            try:
                from engine.voice_gender_control import voice_control
                query_lower = query.lower()
                
                if "female voice" in query_lower or "switch to female" in query_lower:
                    response = voice_control.switch_to_female()
                    speak(response)
                    print(f"Voice switched to female: {response}")
                elif "male voice" in query_lower or "switch to male" in query_lower:
                    response = voice_control.switch_to_male()
                    speak(response)
                    print(f"Voice switched to male: {response}")
                elif "current voice" in query_lower or "voice status" in query_lower:
                    gender = voice_control.get_current_gender()
                    speak(f"Current voice is set to {gender}")
                    print(f"Current voice gender: {gender}")
                    
            except Exception as e:
                print(f"Voice switch error: {e}")
                speak("Voice switching failed")
            print("Voice gender command completed, returning")
            return
        
        # Language switching commands (exclude voice gender commands)
        elif ("switch to" in query or "change language" in query) and not any(voice_term in query.lower() for voice_term in ["male", "female", "voice"]):
            try:
                from engine.multilingual_support import multilingual
                response = multilingual.process_multilingual_command(query)
                speak(response)
            except Exception as e:
                print(f"Language switch error: {e}")
                speak("Language switching is not available")
            eel.ShowHood()
            return
        
        # Add contact command
        elif "add contact" in query:
            try:
                import re
                import sqlite3
                
                # Extract name and number from query
                match = re.search(r'add contact (\w+) (\d+)', query)
                if match:
                    name = match.group(1)
                    number = match.group(2)
                    
                    # Add to database
                    con = sqlite3.connect("jarvis.db")
                    cursor = con.cursor()
                    cursor.execute('INSERT INTO contacts (name, mobile_no) VALUES (?, ?)', (name, number))
                    con.commit()
                    con.close()
                    
                    speak(f"Contact {name} with number {number} added successfully")
                else:
                    speak("Please say add contact name number")
                    
            except Exception as e:
                print(f"Add contact error: {e}")
                speak("Failed to add contact")
            eel.ShowHood()
            return
        
        # Delete contact command
        elif "delete contact" in query:
            try:
                import re
                import sqlite3
                
                # Extract name from query
                match = re.search(r'delete contact (\w+)', query)
                if match:
                    name = match.group(1)
                    
                    con = sqlite3.connect("jarvis.db")
                    cursor = con.cursor()
                    
                    # Check if contact exists
                    cursor.execute('SELECT name FROM contacts WHERE LOWER(name) LIKE ?', ('%' + name.lower() + '%',))
                    result = cursor.fetchone()
                    
                    if result:
                        cursor.execute('DELETE FROM contacts WHERE LOWER(name) LIKE ?', ('%' + name.lower() + '%',))
                        con.commit()
                        speak(f"Contact {name} deleted successfully")
                    else:
                        speak(f"Contact {name} not found")
                    
                    con.close()
                else:
                    speak("Please say delete contact name")
                    
            except Exception as e:
                print(f"Delete contact error: {e}")
                speak("Failed to delete contact")
            eel.ShowHood()
            return
        
        # View contacts command
        elif "view contacts" in query or "show contacts" in query or "list contacts" in query:
            try:
                import sqlite3
                
                con = sqlite3.connect("jarvis.db")
                cursor = con.cursor()
                cursor.execute('SELECT name, mobile_no FROM contacts')
                results = cursor.fetchall()
                con.close()
                
                if results:
                    contact_list = "Your contacts are: "
                    for contact in results:
                        contact_list += f"{contact[0]} {contact[1]}, "
                    speak(contact_list)
                else:
                    speak("No contacts found")
                    
            except Exception as e:
                print(f"View contacts error: {e}")
                speak("Failed to view contacts")
            eel.ShowHood()
            return
        
        # Emotion detection commands
        elif "start emotion" in query or "enable emotion" in query:
            response = emotion_system.enable()
            speak(response)
            try:
                eel.ShowHood()
            except:
                pass
            return
        elif "stop emotion" in query or "disable emotion" in query:
            response = emotion_system.disable()
            speak(response)
            try:
                eel.ShowHood()
            except:
                pass
            return
        elif "emotion status" in query or "current emotion" in query:
            response = emotion_system.get_status()
            speak(response)
            try:
                eel.ShowHood()
            except:
                pass
            return
        elif "encourage me" in query or "cheer me up" in query:
            encouragement = emotion_system.get_encouraging_response()
            speak(encouragement)
            try:
                eel.ShowHood()
            except:
                pass
            return
        elif "make me laugh" in query or "tell joke" in query:
            humor = emotion_system.get_humor_response()
            speak(humor)
            try:
                eel.ShowHood()
            except:
                pass
            return
        
        # Calendar event scheduling (for events with "at" time)
        elif "add event" in query or ("add" in query and "event" in query):
            try:
                from engine.voice_advanced_ai import get_voice_advanced_response
                response = get_voice_advanced_response(query)
                speak(response)
            except Exception as e:
                speak(f"Calendar scheduling failed: {e}")
            eel.ShowHood()
            return
        
        # Task scheduling (for system tasks with "in" time)
        elif "schedule" in query and "in" in query and "event" not in query:
            try:
                import re
                # Extract command and time
                parts = query.split(" in ", 1)
                command = parts[0].replace("schedule ", "")
                time_part = parts[1]
                
                response = task_scheduler.schedule_task(command, time_part)
                speak(response)
            except Exception as e:
                speak(f"Task scheduling failed: {e}")
            eel.ShowHood()
            return
        elif "list scheduled" in query or "show scheduled" in query:
            response = task_scheduler.list_tasks()
            speak(response)
            eel.ShowHood()
            return
        
        # Calendar commands
        elif "show calendar" in query or "check calendar" in query or "my events" in query:
            try:
                from engine.voice_advanced_ai import get_voice_advanced_response
                response = get_voice_advanced_response(query)
                speak(response)
            except Exception as e:
                speak(f"Calendar display failed: {e}")
            eel.ShowHood()
            return
        
        # Previous command queries - execute must come first
        elif "execute previous command" in query or "run previous command" in query or "repeat last command" in query:
            try:
                recent = command_history.get_recent_commands(10)
                # Find the last command that's not an "execute" or "what is" command
                prev_cmd = None
                for cmd in reversed(recent):
                    if ("execute previous" not in cmd['user_input'].lower() and 
                        "run previous" not in cmd['user_input'].lower() and
                        "repeat last" not in cmd['user_input'].lower() and
                        "what is previous" not in cmd['user_input'].lower() and
                        "last command" not in cmd['user_input'].lower() and
                        "previous command" not in cmd['user_input'].lower()):
                        prev_cmd = cmd['user_input']
                        break
                
                if prev_cmd:
                    speak(f"Executing previous command: {prev_cmd}")
                    process_single_command(prev_cmd)
                else:
                    speak("No previous command to execute")
            except:
                speak("Cannot execute previous command")
            try:
                eel.ShowHood()
            except:
                pass
            return
        elif "what is previous command" in query or "last command" in query or "previous command" in query:
            try:
                recent = command_history.get_recent_commands(10)
                # Find the last command that's not a query command
                prev_cmd = None
                for cmd in reversed(recent):
                    if ("what is previous" not in cmd['user_input'].lower() and 
                        "last command" not in cmd['user_input'].lower() and
                        "previous command" not in cmd['user_input'].lower()):
                        prev_cmd = cmd['user_input']
                        break
                
                if prev_cmd:
                    speak(f"Your previous command was: {prev_cmd}")
                else:
                    speak("No previous command found")
            except:
                speak("Cannot retrieve previous command")
            try:
                eel.ShowHood()
            except:
                pass
            return
        
        # Continuous listening commands
        elif "start continuous" in query or "continuous listen" in query:
            response = start_continuous_listen()
            speak(response)
            eel.ShowHood()
            return
        elif "stop continuous" in query:
            response = stop_continuous_listen()
            speak(response)
            eel.ShowHood()
            return
        elif "continuous status" in query:
            response = get_continuous_listen_status()
            speak(response)
            eel.ShowHood()
            return
        
        # Pause/Resume listening commands
        elif "pause listening" in query:
            response = pause_listening()
            speak(response)
            eel.ShowHood()
            return
        elif "resume listening" in query:
            response = resume_listening()
            speak(response)
            eel.ShowHood()
            return
        
        # Mute/Unmute Jarvis commands
        elif "mute jarvis" in query or "mute voice" in query:
            response = mute_jarvis()
            # Don't speak when muting
            print(response)
            eel.ShowHood()
            return
        # Unmute is handled at the beginning of the function
        
        # Direct website search commands - "open search for ml"
        elif "open" in query and "search for" in query:
            try:
                import webbrowser
                import pyautogui
                import time
                
                # Extract website and search terms
                parts = query.split("search for", 1)
                website_part = parts[0].replace("open", "").strip().lower()
                search_terms = parts[1].strip()
                
                import urllib.parse
                
                # Direct search URLs for specific websites
                search_urls = {
                    'youtube': f'https://www.youtube.com/results?search_query={urllib.parse.quote(search_terms)}',
                    'amazon': f'https://www.amazon.in/s?k={urllib.parse.quote(search_terms)}',
                    'flipkart': f'https://www.flipkart.com/search?q={urllib.parse.quote(search_terms)}',
                    'myntra': f'https://www.myntra.com/{urllib.parse.quote(search_terms)}',
                    'ajio': f'https://www.ajio.com/search/?text={urllib.parse.quote(search_terms)}',
                    'meesho': f'https://www.meesho.com/search?q={urllib.parse.quote(search_terms)}',
                    'wikipedia': f'https://en.wikipedia.org/w/index.php?search={urllib.parse.quote(search_terms)}',
                    'youtube music': f'https://music.youtube.com/search?q={urllib.parse.quote(search_terms)}',
                    'stackoverflow': f'https://stackoverflow.com/search?q={urllib.parse.quote(search_terms)}',
                    'github': f'https://github.com/search?q={urllib.parse.quote(search_terms)}',
                    'npm': f'https://www.npmjs.com/search?q={urllib.parse.quote(search_terms)}',
                    'coursera': f'https://www.coursera.org/search?query={urllib.parse.quote(search_terms)}',
                    'udemy': f'https://www.udemy.com/courses/search/?q={urllib.parse.quote(search_terms)}',
                    'perplexity': f'https://www.perplexity.ai/search?q={urllib.parse.quote(search_terms)}',
                    'linkedin': f'https://www.linkedin.com/search/results/all/?keywords={urllib.parse.quote(search_terms)}',
                    'linkedin jobs': f'https://www.linkedin.com/jobs/search/?keywords={urllib.parse.quote(search_terms)}',
                    'google': f'https://www.google.com/search?q={urllib.parse.quote(search_terms)}',
                    'facebook': f'https://www.facebook.com/search/top/?q={urllib.parse.quote(search_terms)}',
                    'twitter': f'https://twitter.com/search?q={urllib.parse.quote(search_terms)}',
                    'instagram': f'https://www.instagram.com/explore/tags/{urllib.parse.quote(search_terms)}',
                    'reddit': f'https://www.reddit.com/search/?q={urllib.parse.quote(search_terms)}',
                    'netflix': f'https://www.netflix.com/search?q={urllib.parse.quote(search_terms)}',
                    'ebay': f'https://www.ebay.com/sch/i.html?_nkw={urllib.parse.quote(search_terms)}',
                    'pinterest': f'https://www.pinterest.com/search/pins/?q={urllib.parse.quote(search_terms)}',
                    'quora': f'https://www.quora.com/search?q={urllib.parse.quote(search_terms)}',
                    'medium': f'https://medium.com/search?q={urllib.parse.quote(search_terms)}',
                    'dribbble': f'https://dribbble.com/search/{urllib.parse.quote(search_terms)}',
                    'behance': f'https://www.behance.net/search/projects?search={urllib.parse.quote(search_terms)}',
                    'unsplash': f'https://unsplash.com/s/photos/{urllib.parse.quote(search_terms)}',
                    'pixabay': f'https://pixabay.com/images/search/{urllib.parse.quote(search_terms)}',
                    'freepik': f'https://www.freepik.com/search?query={urllib.parse.quote(search_terms)}',
                    'codepen': f'https://codepen.io/search/pens?q={urllib.parse.quote(search_terms)}',
                    'devto': f'https://dev.to/search?q={urllib.parse.quote(search_terms)}',
                    'hashnode': f'https://hashnode.com/search?q={urllib.parse.quote(search_terms)}',
                    'producthunt': f'https://www.producthunt.com/search?q={urllib.parse.quote(search_terms)}',
                    'hackernews': f'https://hn.algolia.com/?q={urllib.parse.quote(search_terms)}',
                    'duckduckgo': f'https://duckduckgo.com/?q={urllib.parse.quote(search_terms)}',
                    'bing': f'https://www.bing.com/search?q={urllib.parse.quote(search_terms)}',
                    'yandex': f'https://yandex.com/search/?text={urllib.parse.quote(search_terms)}',
                    'maps': f'https://www.google.com/maps/search/{urllib.parse.quote(search_terms)}',
                    'zomato': f'https://www.zomato.com/search?q={urllib.parse.quote(search_terms)}',
                    'swiggy': f'https://www.swiggy.com/search?q={urllib.parse.quote(search_terms)}',
                    'bookmyshow': f'https://in.bookmyshow.com/explore/search/{urllib.parse.quote(search_terms)}',
                    'makemytrip': f'https://www.makemytrip.com/search?q={urllib.parse.quote(search_terms)}',
                    'airbnb': f'https://www.airbnb.com/s/{urllib.parse.quote(search_terms)}',
                    'booking': f'https://www.booking.com/searchresults.html?ss={urllib.parse.quote(search_terms)}',
                    'justdial': f'https://www.justdial.com/search/all/{urllib.parse.quote(search_terms)}',
                    'bigbasket': f'https://www.bigbasket.com/ps/?q={urllib.parse.quote(search_terms)}',
                    'nykaa': f'https://www.nykaa.com/search/result/?q={urllib.parse.quote(search_terms)}',
                    'lenskart': f'https://www.lenskart.com/search?q={urllib.parse.quote(search_terms)}',
                    'pharmeasy': f'https://pharmeasy.in/search/all?name={urllib.parse.quote(search_terms)}',
                    'practo': f'https://www.practo.com/search/doctors?results_type=doctor&q={urllib.parse.quote(search_terms)}',
                    'hotstar': f'https://www.hotstar.com/in/search?q={urllib.parse.quote(search_terms)}',
                    'spotify': f'https://open.spotify.com/search/{urllib.parse.quote(search_terms)}',
                    'gaana': f'https://gaana.com/search/{urllib.parse.quote(search_terms)}'
                }
                
                # Regular websites (open and type)
                regular_sites = {
                    'chatgpt': 'https://chat.openai.com',
                    'gemini': 'https://gemini.google.com',
                    'claude': 'https://claude.ai',
                    'bard': 'https://bard.google.com',
                    'copilot': 'https://copilot.microsoft.com'
                }
                
                # Check if website has direct search URL
                if website_part in search_urls:
                    webbrowser.open(search_urls[website_part])
                    speak(f"Searching for {search_terms}")
                elif website_part in regular_sites:
                    webbrowser.open(regular_sites[website_part])
                    speak(f"Opening and typing {search_terms}")
                    time.sleep(3)
                    pyautogui.typewrite(search_terms)
                    pyautogui.press('enter')
                else:
                    # Fallback for unknown websites
                    website_url = f"https://{website_part}.com"
                    webbrowser.open(website_url)
                    speak(f"Opening and typing {search_terms}")
                    time.sleep(3)
                    pyautogui.typewrite(search_terms)
                    pyautogui.press('enter')
                
            except Exception as e:
                print(f"Website search error: {e}")
                speak("Failed to open website")
            try:
                eel.ShowHood()
            except:
                pass
            return
        
        # General web search with AI
           
        # Browser and Website Management Commands - handle before app management
        elif any(word in query.lower() for word in ['open ', 'launch ', 'run ']) and any(word in query.lower() for word in ['browser', 'web', 'website', 'site']):
            try:
                from engine.new_features import get_new_feature_response
                response = get_new_feature_response(query)
                speak(response)
            except Exception as e:
                print(f"Browser/website opener error: {e}")
                speak("Failed to open browser or website")
            try:
                eel.ShowHood()
            except:
                pass
            return
        
        elif any(word in query.lower() for word in ['close ', 'quit ', 'exit ', 'kill ']) and any(word in query.lower() for word in ['browser', 'web', 'website', 'site']):
            try:
                from engine.new_features import get_new_feature_response
                response = get_new_feature_response(query)
                speak(response)
            except Exception as e:
                print(f"Browser/website closer error: {e}")
                speak("Failed to close browser or website")
            try:
                eel.ShowHood()
            except:
                pass
            return
        

        
        # Direct calculator command - HIGH PRIORITY
        elif "open calculator" in query.lower():
            try:
                import subprocess
                subprocess.Popen('calc', shell=True)
                speak("Calculator opened")
            except Exception as e:
                print(f"Calculator error: {e}")
                speak("Failed to open calculator")
            try:
                eel.ShowHood()
            except:
                pass
            return
        
        # Universal App Management Commands - handle before dual AI
        elif any(word in query.lower() for word in ['open ', 'launch ', 'run ']) and not any(word in query.lower() for word in ['file', 'folder']):
            try:
                from engine.new_features import get_new_feature_response
                response = get_new_feature_response(query)
                speak(response)
            except Exception as e:
                print(f"App opener error: {e}")
                speak("Failed to open application")
            try:
                eel.ShowHood()
            except:
                pass
            return
        
        elif any(word in query.lower() for word in ['close ', 'quit ', 'exit ', 'kill ']) and not any(word in query.lower() for word in ['file', 'folder', 'browser', 'website']):
            try:
                from engine.new_features import get_new_feature_response
                response = get_new_feature_response(query)
                speak(response)
            except Exception as e:
                print(f"App closer error: {e}")
                speak("Failed to close application")
            try:
                eel.ShowHood()
            except:
                pass
            return
        

        
        # Everything else handled by Dual AI (reliable functions only)
        else:
         
            try:
                from engine.dual_ai import dual_ai
                # Use dual_ai.execute instead of get_simple_response for multilingual support
                response = dual_ai.execute(query)
                print(f"Dual AI response: {response}")
                speak(response)
            except Exception as e:
                print(f"Dual AI Error: {e}")
                # Get error message in current language
                try:
                    from engine.multilingual_support import multilingual
                    speak(multilingual.get_response('processing'))
                except:
                    speak("I'm processing your request")
                    
    except Exception as e:
        print(f"Error in process_single_command: {e}")
        speak("Command failed")

# Load UI settings on startup
load_ui_settings()
import json
import os
from datetime import datetime

class CommandHistory:
    def __init__(self):
        self.history_file = 'command_history.json'
        self.history = []
        self.load_history()
    
    def load_history(self):
        """Load command history from file"""
        try:
            if os.path.exists(self.history_file):
                with open(self.history_file, 'r', encoding='utf-8') as f:
                    self.history = json.load(f)
        except Exception as e:
            print(f"Error loading command history: {e}")
            self.history = []
    
    def save_history(self):
        """Save command history to file"""
        try:
            with open(self.history_file, 'w', encoding='utf-8') as f:
                json.dump(self.history, f, indent=2, ensure_ascii=False)
        except Exception as e:
            print(f"Error saving command history: {e}")
    
    def add_command(self, user_input, jarvis_response, is_voice=False):
        """Add a command to history"""
        try:
            command_entry = {
                'timestamp': datetime.now().isoformat(),
                'user_input': user_input,
                'jarvis_response': jarvis_response,
                'input_type': 'voice' if is_voice else 'text'
            }
            
            self.history.append(command_entry)
            
            # Keep only last 100 commands to prevent file from getting too large
            if len(self.history) > 100:
                self.history = self.history[-100:]
            
            self.save_history()
        except Exception as e:
            print(f"Error adding command to history: {e}")
    
    def get_recent_commands(self, count=10):
        """Get recent commands"""
        return self.history[-count:] if len(self.history) >= count else self.history
    
    def search_commands(self, query="", date_filter="", input_type=""):
        """Search commands by query, date, or type"""
        filtered = self.history
        
        if query:
            filtered = [cmd for cmd in filtered if query.lower() in cmd['user_input'].lower()]
        
        if date_filter:
            from datetime import datetime, timedelta
            today = datetime.now()
            if date_filter == "today":
                start_date = today.replace(hour=0, minute=0, second=0, microsecond=0)
            elif date_filter == "week":
                start_date = today - timedelta(days=7)
            elif date_filter == "month":
                start_date = today - timedelta(days=30)
            else:
                return filtered
            
            filtered = [cmd for cmd in filtered if datetime.fromisoformat(cmd['timestamp']) >= start_date]
        
        if input_type:
            filtered = [cmd for cmd in filtered if cmd['input_type'] == input_type]
        
        return filtered
    
    def get_statistics(self):
        """Get command statistics"""
        if not self.history:
            return {"total": 0, "voice": 0, "text": 0, "most_used": [], "success_rate": 0}
        
        total = len(self.history)
        voice_count = sum(1 for cmd in self.history if cmd['input_type'] == 'voice')
        text_count = total - voice_count
        
        # Count command frequency
        command_freq = {}
        successful = 0
        
        for cmd in self.history:
            base_cmd = cmd['user_input'].strip().lower().split()[0] if cmd['user_input'].strip() else "unknown"
            command_freq[base_cmd] = command_freq.get(base_cmd, 0) + 1
            
            if cmd['jarvis_response'] and "error" not in cmd['jarvis_response'].lower() and "failed" not in cmd['jarvis_response'].lower():
                successful += 1
        
        # Get top 5 most used commands
        most_used = sorted(command_freq.items(), key=lambda x: x[1], reverse=True)[:5]
        success_rate = round((successful / total) * 100, 1) if total > 0 else 0
        
        return {
            "total": total,
            "voice": voice_count,
            "text": text_count,
            "most_used": most_used,
            "success_rate": success_rate
        }
    
    def clear_history(self):
        """Clear all command history"""
        self.history = []
        self.save_history()

# Global instance
command_history = CommandHistory()
ASSISTANT_NAME = "jarvis"
import csv
import sqlite3

con = sqlite3.connect("jarvis.db")
cursor = con.cursor()

query = "CREATE TABLE IF NOT EXISTS sys_command(id integer primary key, name VARCHAR(100), path VARCHAR(1000))"
cursor.execute(query)

# query = "INSERT INTO sys_command VALUES (null,'one note', 'C:\\Program Files\\Microsoft Office\\root\\Office16\\ONENOTE.exe')"
# cursor.execute(query)
# con.commit()

# query = "CREATE TABLE IF NOT EXISTS web_command(id integer primary key, name VARCHAR(100), url VARCHAR(1000))"
# cursor.execute(query)

# query = "INSERT INTO web_command VALUES (null,'youtube', 'https://www.youtube.com/')"
# cursor.execute(query)
# con.commit()


# testing module
# app_name = "android studio"
# cursor.execute('SELECT path FROM sys_command WHERE name IN (?)', (app_name,))
# results = cursor.fetchall()
# print(results[0][0])

# Create a table with the desired columns
#cursor.execute('''CREATE TABLE IF NOT EXISTS contacts (id integer primary key, name VARCHAR(200), mobile_no VARCHAR(255), email VARCHAR(255) NULL)''')


# Specify the column indices you want to import (0-based index)
# Example: Importing the 1st and 3rd columns
# desired_columns_indices = [0, 30]

# # Read data from CSV and insert into SQLite table for the desired columns
# with open('contacts.csv', 'r', encoding='utf-8') as csvfile:
#     csvreader = csv.reader(csvfile)
#     for row in csvreader:
#         selected_data = [row[i] for i in desired_columns_indices]
#         cursor.execute(''' INSERT INTO contacts (id, 'name', 'mobile_no') VALUES (null, ?, ?);''', tuple(selected_data))

# # Commit changes and close connection
# con.commit()
# con.close()

# query = "INSERT INTO contacts VALUES (null,'pawan', '1234567890', 'null')"
# cursor.execute(query)
# con.commit()

# query = 'kunal'
# query = query.strip().lower()

# cursor.execute("SELECT mobile_no FROM contacts WHERE LOWER(name) LIKE ? OR LOWER(name) LIKE ?", ('%' + query + '%', query + '%'))
# results = cursor.fetchall()
# print(results[0][0])
"""
Dictation methods for dual_ai.py
"""

def dictate_to_file(self, query=""):
    """Voice-to-text dictation to file"""
    try:
        import speech_recognition as sr
        import re
        import os
        from datetime import datetime
        
        # Extract filename from query
        filename = "dictation.txt"  # default
        mode = "write"  # default
        
        file_match = re.search(r'to file\s+([^\s]+)', query.lower())
        if file_match:
            filename = file_match.group(1).strip()
            if not filename.endswith('.txt'):
                filename += '.txt'
    
        if "append" in query.lower():
            mode = "append"
    
        # Initialize recognizer
        r = sr.Recognizer()
    
        # Start recording
        with sr.Microphone() as source:
            print("üé§ Adjusting for ambient noise...")
            r.adjust_for_ambient_noise(source)
            print(f"üé§ Dictating to {filename}. Say 'stop dictation' to finish...")
        
            text_content = ""
        
            while True:
                try:
                    # Listen for audio
                    audio = r.listen(source, timeout=1, phrase_time_limit=5)
                
                    # Convert to text
                    text = r.recognize_google(audio)
                
                    # Check for stop command
                    if "stop dictation" in text.lower():
                        break
                
                    # Process punctuation commands
                    text = self._process_punctuation_commands(text)
                
                    text_content += text + " "
                    print(f"üìù {text}")
                
                except sr.WaitTimeoutError:
                    continue
                except sr.UnknownValueError:
                    continue
                except sr.RequestError as e:
                    return f"Speech recognition error: {e}"
    
        # Save to file
        if text_content.strip():
            if mode == "append" and os.path.exists(filename):
                with open(filename, 'a', encoding='utf-8') as f:
                    f.write("\n" + text_content.strip())
            else:
                with open(filename, 'w', encoding='utf-8') as f:
                    f.write(text_content.strip())
        
            return f"üìù Dictation saved to {filename} ({len(text_content.split())} words)"
        else:
            return "No speech detected"
        
    except ImportError:
        return "Speech recognition not installed. Run: pip install SpeechRecognition pyaudio"
    except Exception as e:
        return f"Dictation failed: {e}"

def dictate_to_document(self, query=""):
    """Advanced voice-to-text for formatted documents"""
    try:
        import speech_recognition as sr
        import re
        from datetime import datetime
    
        # Determine document type
        doc_type = "word"
        if "google docs" in query.lower():
            doc_type = "gdocs"
        elif "email" in query.lower():
            doc_type = "email"
    
        # Initialize recognizer
        r = sr.Recognizer()
    
        # Start recording
        with sr.Microphone() as source:
            print("üé§ Adjusting for ambient noise...")
            r.adjust_for_ambient_noise(source)
            print(f"üé§ Dictating to {doc_type}. Say formatting commands like 'bold this', 'new paragraph'...")
        
            document_content = []
            current_text = ""
        
            while True:
                try:
                    # Listen for audio
                    audio = r.listen(source, timeout=1, phrase_time_limit=5)
                
                    # Convert to text
                    text = r.recognize_google(audio)
                
                    # Check for stop command
                    if "stop dictation" in text.lower():
                        break
                
                    # Process formatting commands
                    if self._is_formatting_command(text):
                        formatted_text = self._process_formatting_command(text, current_text)
                        document_content.append(formatted_text)
                        current_text = ""
                    else:
                        # Process punctuation commands
                        text = self._process_punctuation_commands(text)
                        current_text += text + " "
                        print(f"üìù {text}")
                
                except sr.WaitTimeoutError:
                    continue
                except sr.UnknownValueError:
                    continue
                except sr.RequestError as e:
                    return f"Speech recognition error: {e}"
    
        # Add remaining text
        if current_text.strip():
            document_content.append(current_text.strip())
    
        # Save formatted document
        if document_content:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        
            if doc_type == "email":
                filename = f"email_draft_{timestamp}.txt"
                content = self._format_as_email(document_content)
            elif doc_type == "gdocs":
                filename = f"gdocs_draft_{timestamp}.txt"
                content = self._format_as_document(document_content)
            else:
                filename = f"document_{timestamp}.docx"
                content = self._format_as_document(document_content)
        
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(content)
        
            word_count = len(' '.join(document_content).split())
            return f"üìÑ Document saved to {filename} ({word_count} words)\nFormatting commands processed"
        else:
            return "No content dictated"
        
    except ImportError:
        return "Speech recognition not installed. Run: pip install SpeechRecognition pyaudio"
    except Exception as e:
        return f"Document dictation failed: {e}"

def process_punctuation_commands(self, text):
    """Process voice punctuation commands"""
    punctuation_map = {
        'period': '.',
        'comma': ',',
        'question mark': '?',
        'exclamation point': '!',
        'colon': ':',
        'semicolon': ';',
        'new line': '\n',
        'new paragraph': '\n\n'
    }

    for command, punctuation in punctuation_map.items():
        text = text.replace(command, punctuation)

    return text

def is_formatting_command(self, text):
    """Check if text contains formatting commands"""
    formatting_commands = [
        'bold this', 'italic this', 'underline this',
        'bullet point', 'numbered list', 'new paragraph',
        'heading', 'title', 'center this'
    ]

    return any(cmd in text.lower() for cmd in formatting_commands)

def process_formatting_command(self, command, text):
    """Process formatting commands and return formatted text"""
    command_lower = command.lower()

    if 'bold this' in command_lower:
        return f"**{text.strip()}**"
    elif 'italic this' in command_lower:
        return f"*{text.strip()}*"
    elif 'underline this' in command_lower:
        return f"_{text.strip()}_"
    elif 'bullet point' in command_lower:
        return f"‚Ä¢ {text.strip()}"
    elif 'numbered list' in command_lower:
        return f"1. {text.strip()}"
    elif 'heading' in command_lower:
        return f"# {text.strip()}"
    elif 'title' in command_lower:
        return f"## {text.strip()}"
    elif 'center this' in command_lower:
        return f"<center>{text.strip()}</center>"
    else:
        return text

def format_as_email(self, content_list):
    """Format content as email"""
    email_content = "Subject: [Your Subject]\n\n"
    email_content += "Dear [Recipient],\n\n"

    for content in content_list:
        email_content += content + "\n\n"

    email_content += "Best regards,\n[Your Name]"
    return email_content

def format_as_document(self, content_list):
    """Format content as document"""
    document_content = ""

    for content in content_list:
        document_content += content + "\n\n"

    return document_content.strip()
import subprocess
import pyautogui
import psutil
from datetime import datetime, timedelta
import json
import os
import ctypes
import shutil
import socket
import time
import random
import requests
import winreg
import base64
import hashlib
import sqlite3
from collections import Counter
from typing import Optional, Dict, Any, List
import zipfile
import re
import warnings
from tkinter import simpledialog
import re, subprocess, urllib.parse
warnings.filterwarnings("ignore")
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'

# Import multilingual support
try:
    from engine.multilingual_support import multilingual
except:
    multilingual = None

class DualAI:
    def __init__(self):
        """Initialize DualAI with dictation state"""
        self.ai_provider = self._get_ai_provider()
        self._init_ai_models()
        self.active_alarm = None
        # Load saved alarm
        try:
            import json
            from datetime import datetime
            with open('alarm.json', 'r') as f:
                data = json.load(f)
                saved_time = datetime.fromisoformat(data['time'])
                if saved_time > datetime.now():
                    self.active_alarm = saved_time
                    self._start_alarm_thread(saved_time)
        except:
            pass
        # Initialize multilingual support
        from engine.multilingual_support import multilingual
        self.multilingual = multilingual
        
        # Initialize personality manager
        try:
            from engine.personality_manager import personality_manager
            self.personality_manager = personality_manager
        except:
            self.personality_manager = None
        
        # All system functions
        self.functions = {
            # Power
            'shutdown': lambda: subprocess.run('shutdown /s /t 5', shell=True),
            'restart': lambda: subprocess.run('shutdown /r /t 5', shell=True),
             'sleep': lambda: subprocess.run('powershell -command "Add-Type -AssemblyName System.Windows.Forms; [System.Windows.Forms.Application]::SetSuspendState([System.Windows.Forms.PowerState]::Suspend, $false, $false)"',shell=True),
            'lock': lambda: subprocess.run('rundll32.exe user32.dll,LockWorkStation', shell=True),
            'hibernate': lambda: subprocess.run('shutdown /h', shell=True),
            
            # Apps
            'calculator': lambda: subprocess.Popen('calc', shell=True),
            'notepad': lambda: subprocess.Popen('notepad', shell=True),
            'chrome': lambda: subprocess.Popen('start chrome', shell=True),
            'edge': lambda: subprocess.Popen('start msedge', shell=True),
            'explorer': lambda: subprocess.Popen('explorer', shell=True),
            'settings': lambda: subprocess.Popen('start ms-settings:', shell=True),
            'taskmanager': lambda: subprocess.Popen('taskmgr', shell=True),
            'cmd': lambda: subprocess.Popen('cmd', shell=True),
            'paint': lambda: subprocess.Popen('mspaint', shell=True),
            'firefox': lambda: subprocess.Popen('start firefox', shell=True),
            'word': lambda: subprocess.Popen('start winword', shell=True),
            'excel': lambda: subprocess.Popen('start excel', shell=True),
            'powerpoint': self._ai_presentation,
            'vlc': lambda: subprocess.Popen('start vlc', shell=True),
            'vscode': lambda: subprocess.Popen('start code', shell=True),
            'spotify': lambda: subprocess.Popen('start spotify:', shell=True),
            'steam': lambda: subprocess.Popen('start steam', shell=True),
            
            # Websites
            'google': lambda: subprocess.Popen('start chrome https://www.google.com', shell=True),
            'youtube': lambda: subprocess.Popen('start chrome https://www.youtube.com', shell=True),
            'wikipedia': lambda: subprocess.Popen('start chrome https://www.wikipedia.org', shell=True),
            'stackoverflow': lambda: subprocess.Popen('start chrome https://stackoverflow.com', shell=True),
            'github': lambda: subprocess.Popen('start chrome https://github.com', shell=True),
            'amazon': lambda: subprocess.Popen('start chrome https://www.amazon.in', shell=True),
            'flipkart': lambda: subprocess.Popen('start chrome https://www.flipkart.com', shell=True),
            'instagram': lambda: subprocess.Popen('start chrome https://www.instagram.com', shell=True),
            'facebook': lambda: subprocess.Popen('start chrome https://www.facebook.com', shell=True),
            'twitter': lambda: subprocess.Popen('start chrome https://www.twitter.com', shell=True),
            'linkedin': lambda: subprocess.Popen('start chrome https://www.linkedin.com', shell=True),
            'whatsapp_web': lambda: subprocess.Popen('start chrome https://web.whatsapp.com', shell=True),
            'gmail': lambda: subprocess.Popen('start chrome https://mail.google.com', shell=True),
            'netflix': lambda: subprocess.Popen('start chrome https://www.netflix.com', shell=True),
            
            # Volume
            'volume_up': lambda: pyautogui.press('volumeup'),
            'volume_down': lambda: pyautogui.press('volumedown'),
            'mute': lambda: pyautogui.press('volumemute'),
            
            # Screen
            'screenshot': lambda: pyautogui.screenshot().save(f'screenshot_{datetime.now().strftime("%Y%m%d_%H%M%S")}.png'),
            'show desktop': lambda: pyautogui.hotkey('win', 'd'),
            'minimize_all': lambda: pyautogui.hotkey('win', 'm'),
            'brightness_up': self._brightness_up,
            'brightness_down': self._brightness_down,
            
            # Keyboard
            'alt_tab': lambda: pyautogui.hotkey('alt', 'tab'),
            'copy': lambda: pyautogui.hotkey('ctrl', 'c'),
            'paste': lambda: pyautogui.hotkey('ctrl', 'v'),
            'save': lambda: pyautogui.hotkey('ctrl', 's'),
            'undo': lambda: pyautogui.hotkey('ctrl', 'z'),
            'select_all': lambda: pyautogui.hotkey('ctrl', 'a'),
            
            # Close apps
            'close_chrome': lambda: subprocess.run('taskkill /f /im chrome.exe', shell=True),
            'close_edge': lambda: subprocess.run('taskkill /f /im msedge.exe', shell=True),
            'close_notepad': lambda: subprocess.run('taskkill /f /im notepad.exe', shell=True),
            
            # Folders
            'downloads': lambda: subprocess.run(f'explorer "{os.path.join(os.path.expanduser("~"), "Downloads")}"', shell=True),
            'documents': lambda: subprocess.run(f'explorer "{os.path.join(os.path.expanduser("~"), "Documents")}"', shell=True),
            'pictures': lambda: subprocess.run(f'explorer "{os.path.join(os.path.expanduser("~"), "Pictures")}"', shell=True),
            'videos': lambda: subprocess.run(f'explorer "{os.path.join(os.path.expanduser("~"), "Videos")}"', shell=True),
            'music': lambda: subprocess.run(f'explorer "{os.path.join(os.path.expanduser("~"), "Music")}"', shell=True),
            'desktop': lambda: subprocess.run(f'explorer "{os.path.join(os.path.expanduser("~"), "Desktop")}"', shell=True),
            'appdata': lambda: subprocess.run(f'explorer "{os.path.join(os.path.expanduser("~"), "AppData")}"', shell=True),
            'temp': lambda: subprocess.run('explorer "%TEMP%"', shell=True),
            'programfiles': lambda: subprocess.run('explorer "C:\\Program Files"', shell=True),
            'programfilesx86': lambda: subprocess.run('explorer "C:\\Program Files (x86)"', shell=True),
            'windows': lambda: subprocess.run('explorer "C:\\Windows"', shell=True),
            'system32': lambda: subprocess.run('explorer "C:\\Windows\\System32"', shell=True),
            'startup': lambda: subprocess.run(f'explorer "{os.path.join(os.path.expanduser("~"), "AppData", "Roaming", "Microsoft", "Windows", "Start Menu", "Programs", "Startup")}"', shell=True),
            'recent': lambda: subprocess.run(f'explorer "{os.path.join(os.path.expanduser("~"), "AppData", "Roaming", "Microsoft", "Windows", "Recent")}"', shell=True),
            'open_path': self._open_path,

        
            'open_file': self._open_path,
            'open_folder': self._open_path,
            'launch_file': self._open_path,
            'launch_folder': self._open_path,
            'show_me': self._open_path,
            'find_file': self._open_path,
            'locate_file': self._open_path,
            
            # Random generators
            'dice': self._roll_dice,
            'coin': self._flip_coin,
            'roll_dice': self._roll_dice,
            'flip_coin': self._flip_coin,
            'age_calculator': self._age_calculator,
            'calculate_age': self._age_calculator,
            
            # System info
            'cpu': lambda: psutil.cpu_percent(interval=1),
            'memory': lambda: psutil.virtual_memory().percent,
            'battery': lambda: psutil.sensors_battery().percent if psutil.sensors_battery() else None,
            'time': lambda: datetime.now().strftime('%I:%M %p'),
            'date': lambda: datetime.now().strftime('%A, %B %d, %Y'),
            
            # AI Control
            'switch_to_gemini': self._switch_to_gemini,
            'switch_to_groq': self._switch_to_groq,
            'current_ai': self._get_current_ai,
            'switch_language_hindi': self._switch_to_hindi,
            'switch_language_kannada': self._switch_to_kannada,
            'switch_language_english': self._switch_to_english,
            
            # Calendar
            'schedule': self._schedule_event,
            'show_calendar': self._show_calendar,
            
            # Advanced AI Features
            'daily_briefing': self._daily_briefing,
            'predictive_assistance': self._predictive_assistance,
            'context_memory_store': self._context_memory_store,
            'context_memory_recall': self._context_memory_recall,
            'recall': self._context_memory_recall,
            
            # Security & Authentication
            'file_vault_encrypt': self._file_vault_encrypt,
            'file_vault_decrypt': self._file_vault_decrypt,
            'anomaly_detection': self._anomaly_detection,
            'phishing_scan': self._phishing_scan,
            'parental_control': self._parental_control,
            
            # Cloud & Multi-Device
            'cloud_backup': self._cloud_backup,
            'email_summarize': self._email_summarize,
            'sync_devices': self._sync_devices,
            
            # AI Productivity
            'realtime_transcription': self._realtime_transcription,
            'summarize_meeting': self._summarize_meeting,
            'smart_clipboard': self._smart_clipboard,
            'document_qa': self._document_qa,
            'ai_presentation': self._ai_presentation,
            
            # Smart Home
            'smart_home_control': self._smart_home_control,
            'set_home_scene': self._set_home_scene,
            'security_camera': self._security_camera,
            'energy_monitoring': self._energy_monitoring,
            
            # Entertainment Plus
            'ai_dj_mode': self._ai_dj_mode,
            'trivia_game': self._trivia_game,
            'storytelling': self._storytelling,
            'fitness_coach': self._fitness_coach,
            
            # Health & Wellness
            'posture_detection': self._posture_detection,
            'eye_care_mode': self._eye_care_mode,
            'daily_health_log': self._daily_health_log,
            'mood_tracker': self._mood_tracker,
            'meditation_prompt': self._meditation_prompt,
            
            # System Monitoring
            # 'system_monitor_live': self._system_monitor_live,
            'auto_fix_system': self._auto_fix_system,
            
            # All Advanced AI Features Integration
            'manage_package': self._manage_package,
            'docker_control': self._docker_control,
            'context_memory_store': self._context_memory_store,
            'context_memory_recall': self._context_memory_recall,
            'adaptive_learning': self._adaptive_learning,
            'check_proactive': self._check_proactive,
            'enable_proactive_mode': self._enable_proactive_mode,
            'enable proactive mode': self._enable_proactive_mode,
            'disable_proactive_mode': self._disable_proactive_mode,
            'disable proactive mode': self._disable_proactive_mode,
            'manual_learn': self._manual_learn,
            'file_vault_encrypt': self._file_vault_encrypt,
            'file_vault_decrypt': self._file_vault_decrypt,
            'anomaly_detection': self._anomaly_detection,
            'phishing_scan': self._phishing_scan,
            'parental_control': self._parental_control,
            'calendar_schedule': self._calendar_schedule,
            'cloud_backup': self._cloud_backup,
            'realtime_transcription': self._realtime_transcription,
            'summarize_meeting': self._summarize_meeting,
            'smart_clipboard': self._smart_clipboard,
            'document_qa': self._document_qa,
            'ai_presentation': self._ai_presentation,
            'smart_home_control': self._smart_home_control,
            'set_home_scene': self._set_home_scene,
            'security_camera': self._security_camera,
            'energy_monitoring': self._energy_monitoring,
            'ai_dj_mode': self._ai_dj_mode,
            'trivia_game': self._trivia_game,
            'storytelling': self._storytelling,
            'fitness_coach': self._fitness_coach,
            'debug_screen': self._debug_screen_code,
            'fix_my_code': self._debug_screen_code,
            'check_code': self._debug_screen_code,
            'code_agent': self._code_agent,
            'research_agent': self._research_agent,
            'organizer_agent': self._organizer_agent,
            'multi_agent_collab': self._multi_agent_collab,
            'scholar_search': self._scholar_search,
            'stock_updates': self._stock_updates,
            'crypto_updates': self._crypto_updates,
            'realtime_translation': self._realtime_translation,
            'posture_detection': self._posture_detection,
            'eye_care_mode': self._eye_care_mode,
            'daily_health_log': self._daily_health_log,
            'mood_tracker': self._mood_tracker,
            'meditation_prompt': self._meditation_prompt,
            
            # Face Auth
            'enable_face_auth': self._enable_face_auth,
            'disable_face_auth': self._disable_face_auth,
            'face_auth_status': self._get_face_auth_status,
            
            # Voice Gender Control
            'switch_to_male_voice': self._switch_to_male_voice,
            'switch_to_female_voice': self._switch_to_female_voice,
            'male_voice': self._switch_to_male_voice,
            'female_voice': self._switch_to_female_voice,
            'current_voice_gender': self._get_current_voice_gender,
            'voice_status': self._get_current_voice_gender,
            
            # Token Usage
            'token_usage': self._get_token_usage,
            'tokens_used': self._get_token_usage,
            'token_status': self._get_token_usage,
            'reset_tokens': self._reset_token_count,
            

            
            # Media Controls
            'play_pause': self._play_pause,
            'next_track': self._next_track,
            'previous_track': self._previous_track,
            'stop_media': self._stop_media,
            
            # Window Management
            'maximize_window': self._maximize_window,
            'minimize_window': self._minimize_window,
            'split_screen_left': self._split_screen_left,
            'split_screen_right': self._split_screen_right,
            'close_window': self._close_window,
            'switch_window': self._switch_window,
            
            # Text Operations
            'find_text': self._find_text,
            'replace_text': self._replace_text,
            'new_document': self._new_document,
            'print_document': self._print_document,
            'zoom_in': self._zoom_in,
            'zoom_out': self._zoom_out,
            
            # Security Features
            'clear_clipboard': self._clear_clipboard,
            'clear_history': self._clear_browser_history,
            'empty_recycle_bin': self._empty_recycle_bin,
            'lock_screen': self._lock_screen,
            
            # Automation
          
            'schedule_shutdown': self._schedule_shutdown,
            'auto_backup': self._backup_files,
            'clean_temp': self._clean_temp_files,
            
            # Entertainment
            'play_music': self._play_music,
            'random_wallpaper': self._change_wallpaper,
            'joke': self._tell_joke,
   
            'news': self._get_news,
            'quote': self._get_quote,
            
            # Voice Mouse Control
            'move_mouse_up': self._move_mouse_up,
            'move_mouse_down': self._move_mouse_down,
            'move_mouse_left': self._move_mouse_left,
            'move_mouse_right': self._move_mouse_right,
            'move_mouse_center': self._move_mouse_center,
            'left_click': self._left_click,
            'right_click': self._right_click,
            'double_click': self._double_click,
            'start_drag': self._start_drag,
            'drop_here': self._drop_here,
            'scroll_up': self._scroll_up,
            'scroll_down': self._scroll_down,
            'scroll_to_top': self._scroll_to_top,
            
            # Voice Keyboard Control
            'type_text': self._type_text,
            'press_enter': self._press_enter,
            'press_tab': self._press_tab,
            'press_escape': self._press_escape,
            'press_backspace': self._press_backspace,
            'press_delete': self._press_delete,
            'go_to_beginning': self._go_to_beginning,
            'go_to_end': self._go_to_end,
            
            # ALL ADVANCED FEATURES INTEGRATED
            # File Operations
            'create_folder': self._create_folder,
            'delete_file': self._delete_file,
            'search_files': self._search_files,
            'copy_file': self._copy_file,
            'move_file': self._move_file,
            'rename_file': self._rename_file_cmd,
            'zip_file': self._zip_file,
            'unzip_file': self._unzip_file,
            'file_size': self._get_file_size,
            'list_files': self._list_files,
            
            # Network & Internet
            'check_internet': self._ping_test,
            'ip_address': self._get_ip,
            'wifi_password': self._get_wifi_password,
            'network_speed': self._speed_test,
            
            # System Monitoring
            'disk_space': self._get_disk_space,
            'running_processes': self._list_processes,
            'system_uptime': self._get_uptime,
            'temperature': self._get_cpu_temp,
            
            # Advanced Window Management
            'next_window': self._next_window,
            'previous_window': self._previous_window,
            'close_all_windows': self._close_all_windows,
            'snap_left': self._snap_left,
            'snap_right': self._snap_right,
            'full_screen': self._full_screen,
            'restore_window': self._restore_window,
            
            # Advanced File Operations
            'open_recent_file': self._open_recent_file,
            'create_new_file': self._create_new_file,
            'rename_file': self._rename_file,
            'duplicate_file': self._duplicate_file,
            'compress_file': self._compress_file,
            'extract_archive': self._extract_archive,
            
            # Web Browsing Control
            'open_new_tab': self._open_new_tab,
            'close_current_tab': self._close_current_tab,
            'switch_to_next_tab': self._switch_to_next_tab,
            'switch_to_previous_tab': self._switch_to_previous_tab,
            'refresh_page': self._refresh_page,
            'go_back': self._go_back,
            'go_forward': self._go_forward,
            'bookmark_page': self._bookmark_page,
            'open_bookmarks': self._open_bookmarks,
            'search_web': self._search_web,
            
            # Advanced Media Control
            'skip_forward': self._skip_forward,
            'skip_backward': self._skip_backward,
            'increase_speed': self._increase_speed,
            'decrease_speed': self._decrease_speed,
            'toggle_fullscreen': self._toggle_fullscreen,
            'toggle_subtitles': self._toggle_subtitles,
            
            # Voice Dictation
            'start_dictation': self._start_dictation,
            'stop_dictation': self._stop_dictation,
  
            
            # Screen Control
            'take_screenshot_window': self._take_screenshot_window,
            'take_screenshot_area': self._take_screenshot_area,
            'start_screen_recording': self._start_screen_recording,
            'stop_screen_recording': self._stop_screen_recording,

            

            # Learning & Education
            'wikipedia_search': self._wikipedia_search,
            
            # Entertainment Plus
            'movie_recommend': self._movie_recommend,
         
            'game_launch': self._game_launch,
            'streaming_control': self._streaming_control,
            'playlist_manage': self._playlist_manage,
            
          
            
            # Built-in Entertainment
            'tell_joke': self._tell_joke,
            'get_quote': self._get_quote,
       
            'get_news': self._get_news,
            
            # YouTube Automation
            'youtube_play': self._youtube_play,
            'youtube_pause': self._youtube_pause,
            'youtube_next': self._youtube_next,
            'youtube_previous': self._youtube_previous,
            'youtube_fullscreen': self._youtube_fullscreen,
            'youtube_volume_up': self._youtube_volume_up,
            'youtube_volume_down': self._youtube_volume_down,
            'youtube_mute': self._youtube_mute,
            'youtube_speed_up': self._youtube_speed_up,
            'youtube_speed_down': self._youtube_speed_down,
            'youtube_skip_forward': self._youtube_skip_forward,
            'youtube_skip_backward': self._youtube_skip_backward,
            'youtube_search': self._youtube_search,
            'youtube_subscribe': self._youtube_subscribe,
            'youtube_like': self._youtube_like,
            'youtube_dislike': self._youtube_dislike,
            'youtube_comment': self._youtube_comment,
            'youtube_share': self._youtube_share,
            'youtube_theater_mode': self._youtube_theater_mode,
            'youtube_miniplayer': self._youtube_miniplayer,
            'youtube_captions': self._youtube_captions,
            'play_video': self._play_video,
            'play_movie': self._play_movie,
            'play_song': self._play_song,
            'search_and_play': self._search_and_play,
            
            # Multiple App/Website Opening
     
            
            # Chrome Automation
            'chrome_new_tab': self._chrome_new_tab,
            'chrome_close_tab': self._chrome_close_tab,
            'chrome_next_tab': self._chrome_next_tab,
            'chrome_previous_tab': self._chrome_previous_tab,
            'chrome_reload': self._chrome_reload,
            'chrome_back': self._chrome_back,
            'chrome_forward': self._chrome_forward,
            'chrome_home': self._chrome_home,
            'chrome_bookmark': self._chrome_bookmark,
            'chrome_history': self._chrome_history,
            'chrome_downloads': self._chrome_downloads,
            'chrome_incognito': self._chrome_incognito,
            'chrome_developer_tools': self._chrome_developer_tools,
            'chrome_zoom_in': self._chrome_zoom_in,
            'chrome_zoom_out': self._chrome_zoom_out,
            'chrome_zoom_reset': self._chrome_zoom_reset,
            'chrome_find': self._chrome_find,
            'chrome_print': self._chrome_print,
            'chrome_save_page': self._chrome_save_page,
            'chrome_view_source': self._chrome_view_source,
            'chrome_extensions': self._chrome_extensions,
            'chrome_settings': self._chrome_settings,
            'chrome_clear_data': self._chrome_clear_data,
            
            # Proactive mode commands
            'enable proactive mode': self._enable_proactive_mode,
            'disable proactive mode': self._disable_proactive_mode,
            
            # Gesture Control
            'start_gesture_control': self._start_gesture_control,
            'stop_gesture_control': self._stop_gesture_control,
            'hand_control': self._start_gesture_control,
            'eye_control': self._start_gesture_control,
            'head_control': self._start_gesture_control,
            'gesture_control': self._start_gesture_control,
            'start gesture control': self._start_gesture_control,
            'stop gesture control': self._stop_gesture_control,
            
            # Code Review Functions
            'code_review': self._code_review,
            'folder_review': self._folder_review,
            'file_review': self._file_review,
            'live_code_review': self._live_code_review,
            'start_live_review': self._start_live_review,
            'stop_live_review': self._stop_live_review,
            
            # Code Writer Functions
            'write_code': self._write_code,
            'create_project': self._create_project,
            'generate_code': self._write_code,
            'code_generator': self._write_code,
            'build_project': self._create_project,
            'make_project': self._create_project,
            
            # Mapping Functions
            'open_maps': self._open_maps,
            'find_location': self._find_location,
            'get_directions': self._get_directions,
            'nearby_places': self._nearby_places,
            'traffic_info': self._traffic_info,
            'map_satellite': self._map_satellite,
            'map_terrain': self._map_terrain,
            'save_location': self._save_location,
            'my_location': self._my_location,
            'dictate_to_file': self._dictate_to_file,
            'dictate_to_document': self._dictate_to_document,
            'start_dictation': self._start_dictation,
            'stop_dictation': self._stop_dictation,
            'dictate_anywhere': self._dictate_anywhere,
            
            # Advanced File Management
            'search_content': self._search_content,
            'find_similar': self._find_similar_files,
            'suggest_folder': self._suggest_folder,
            'map_relationships': self._map_file_relationships,
            
            # Google Search
            'search_google': self._search_google,
            'search_images': self._search_images,
            'search_gifs': self._search_gifs,
            'copy_webpage_link': self._copy_webpage_link,
            'translate_webpage': self._translate_webpage,
            'check_website_status': self._check_website_status,
            'play_radio': self._play_radio,
            'play_podcast': self._play_podcast,
            'weekday': self._get_weekday,
            'current_weekday': self._get_weekday,
            'traffic_updates': self._get_traffic,
            'public_holidays': self._get_holidays,
            'covid_stats': self._get_covid_stats,
            
            # Product Price Tracking
            'track_amazon_price': self._track_amazon_price,
            'track_flipkart_price': self._track_flipkart_price,
            'check_product_price': self._check_product_price,
            
            # DEBUG Product Price Tracking
            'track_amazon_price_debug': self._track_amazon_price_debug,
            'track_flipkart_price_debug': self._track_flipkart_price_debug,
            'check_product_price_debug': self._check_product_price_debug,
            
            # Timer & Stopwatch
            'countdown_timer': self._countdown_timer,
            'start_timer': self._countdown_timer,
            'set_timer': self._countdown_timer,
            'start_stopwatch': self._start_stopwatch,
            'stop_stopwatch': self._stop_stopwatch,
            'reset_stopwatch': self._reset_stopwatch,
            'show_elapsed': self._show_elapsed,
            
            # Mini Games
            'open_mini_game': self._open_mini_game,
            'play_game': self._open_mini_game,
            'launch_game': self._open_mini_game,
            
            # Travel Search
            'search_flights': self._search_flights,
            'search_hotels': self._search_hotels,
            'find_flights': self._search_flights,
            'find_hotels': self._search_hotels,
            
            # Streaming Search
            'find_movie_streaming': self._find_movie_streaming,
            'find_show_streaming': self._find_show_streaming,
            'where_to_watch': self._where_to_watch,
            'streaming_availability': self._streaming_availability,
            
            # Continuous Listening Functions
            
            
            
            # Smart Clipboard Assistant
            'clipboard_assistant': self._clipboard_assistant,
            'start_clipboard_assistant': self._start_clipboard_assistant,
            'stop_clipboard_assistant': self._stop_clipboard_assistant,
            'set_alarm': self._set_alarm,
            'cancel_alarm': self._cancel_alarm,
            
            # AI Image Generation
            'create_image': self._create_image,
            'generate_image': self._create_image,
            'make_image': self._create_image,
            'ai_image': self._create_image,
            
            # AI Video Generation
            'create_video': self._create_video,
            'generate_video': self._create_video,
            'make_video': self._create_video,
            'ai_video': self._create_video,
            
            # File Sorting
            'sort_files': self._sort_files,
            'ai_document': self._ai_document_maker,
            'create_document': self._ai_document_maker,
            'create_report': self._ai_document_maker,
            'create_letter': self._ai_document_maker,

        }
    
    # Ambient Awareness Methods
 
    def _get_ai_provider(self):
        try:
            with open('ai_config.json', 'r') as f:
                config = json.load(f)
                return config.get('ai_provider', 'groq')
        except:
            return 'groq'
    
    def _set_ai_provider(self, provider):
        try:
            config = {'ai_provider': provider}
            with open('ai_config.json', 'w') as f:
                json.dump(config, f)
            self.ai_provider = provider
            self._init_ai_models()
            return True
        except:
            return False
    
    def _init_ai_models(self):
        if self.ai_provider == 'groq':
            try:
                from groq import Groq
                from engine.groq_config import GROQ_API_KEY
                self.groq_client = Groq(api_key=GROQ_API_KEY)
                self.primary_model = "llama-3.1-8b-instant"
                self.fallback_model = "llama-3.3-70b-versatile"
                self.token_count = 0
                self.token_limit = 6000
                # Test the API key with a simple request
                test_response = self.groq_client.chat.completions.create(
                    model=self.primary_model,
                    messages=[{"role": "user", "content": "test"}],
                    max_tokens=1
                )
            except Exception as e:
                print(f"Groq failed: {e}, switching to Gemini")
                self.ai_provider = 'gemini'
                self._init_gemini()

        else:
            self._init_gemini()
        
        # Initialize Ollama as fallback
        self._init_ollama()
        
        # Initialize GPT4All as final fallback
        self._init_gpt4all()
    
    def _get_groq_model(self):
        """Get appropriate Groq model based on token usage"""
        if self.token_count >= self.token_limit:
            print(f"Token limit reached ({self.token_count}/{self.token_limit}), switching to 70B model")
            return self.fallback_model
        return self.primary_model
    
    def _reset_token_count(self):
        """Reset token count (call this every minute or when needed)"""
        self.token_count = 0
        return "Token count reset to 0"
    
    def _get_token_usage(self):
        """Get current token usage status"""
        if self.ai_provider == 'groq':
            percentage = (self.token_count / self.token_limit) * 100
            current_model = "70B" if self.token_count >= self.token_limit else "8B"
            return f"Tokens used: {self.token_count}/{self.token_limit} ({percentage:.1f}%) - Current model: {current_model}"
        else:
            return "Token tracking only available for Groq AI"
               
     
    
    def _init_gemini(self):
        try:
            import google.generativeai as genai
            from engine.gemini_config import GEMINI_API_KEY
            genai.configure(api_key=GEMINI_API_KEY)
            self.gemini_model = genai.GenerativeModel('gemini-2.0-flash')
            print("Using Gemini AI")
        except Exception as e:
            print(f"AI init error: {e}")
    
    def _init_ollama(self):
        """Initialize Ollama client for local Llama model"""
        try:
            from engine.ollama_client import ollama_client
            # Test connection
            success, message = ollama_client.test_connection()
            if success:
                self.ollama_client = ollama_client
                print(f"Ollama initialized: {message}")
            else:
                print(f"Ollama not available: {message}")
                self.ollama_client = None
        except Exception as e:
            print(f"Ollama init error: {e}")
            self.ollama_client = None
    
    def _init_gpt4all(self):
        """Initialize GPT4All as final fallback"""
        try:
            from gpt4all import GPT4All
            import os
            
            # Use model from GPT4All default directory
            model_path = r"C:\Users\Hp\AppData\Local\nomic.ai\GPT4All"
            available_models = [
                "Llama-3.2-1B-Instruct-Q4_0.gguf",
            ]
            
            model_name = None
            for model in available_models:
                if os.path.exists(os.path.join(model_path, model)):
                    model_name = model
                    break
            
            if model_name:
                self.local_model = GPT4All(
                    model_name,
                    model_path=model_path,
                    verbose=False,
                    device='cpu',
                    n_threads=6,
                    n_ctx=1024
                )
                print(f"SUCCESS: GPT4All {model_name} initialized (optimized)")
            else:
                print("No GPT4All models found in default directory")
                self.local_model = None
        except Exception as e:
            print(f"ERROR: GPT4All init failed: {e}")
            self.local_model = None
    
    def execute(self, query):
        try:
            # Store current query for functions that need it
            self._current_query = query
            
            # Handle timer/stopwatch commands - ABSOLUTE HIGHEST PRIORITY
            query_lower = query.lower().strip()
            if 'stopwatch' in query_lower:
                if 'start' in query_lower:
                    return self._start_stopwatch()
                elif 'stop' in query_lower:
                    return self._stop_stopwatch()
                elif 'reset' in query_lower:
                    return self._reset_stopwatch()
                elif 'show' in query_lower or 'elapsed' in query_lower:
                    return self._show_elapsed()
            elif any(word in query_lower for word in ['timer', 'countdown']) and any(num.isdigit() for num in query_lower.split()):
                return self._countdown_timer()
            
            # Handle game commands - VERY HIGH PRIORITY
            if 'play' in query_lower and any(game in query_lower for game in ['chess', 'snake', 'tetris', '2048', 'dino', 'mario', 'solitaire', 'sudoku', 'game']):
                return self._open_mini_game()
            
            # Handle image creation commands FIRST (highest priority)
            if any(cmd in query_lower for cmd in ['create image', 'generate image', 'make image', 'ai image']):
                return self._create_image()
            
            # Handle video creation commands (highest priority)
            if any(cmd in query_lower for cmd in ['create video', 'generate video', 'make video', 'ai video']):
                return self._create_video()
            
            # Handle clipboard assistant commands FIRST (highest priority)
            if 'clipboard assistant' in query_lower:
                if 'start' in query_lower:
                    return self._start_clipboard_assistant()
                elif 'stop' in query_lower:
                    return self._stop_clipboard_assistant()
                else:
                    return self._clipboard_assistant()
            
        
            
            # Handle voice gender switching commands FIRST (highest priority)
            
            # Exact voice command matching
            if 'female voice' in query_lower:
                return self._switch_to_female_voice()
            elif 'male voice' in query_lower:
                return self._switch_to_male_voice()
            elif 'switch to female' in query_lower:
                return self._switch_to_female_voice()
            elif 'switch to male' in query_lower:
                return self._switch_to_male_voice()
            elif 'current voice' in query_lower or 'voice status' in query_lower:
                return self._get_current_voice_gender()
            
            # Handle token usage commands
            if any(cmd in query_lower for cmd in ['token usage', 'tokens used', 'token status']):
                return self._get_token_usage()
            elif 'reset tokens' in query_lower:
                return self._reset_token_count()
            
            # Process multilingual commands AFTER English commands
            # Skip multilingual processing for basic English "open" commands
            if not query.lower().startswith('open ') and self.multilingual:
                # Check if it's a language switching command
                if any(word in query.lower() for word in ['switch to', 'change language', '‡§≠‡§æ‡§∑‡§æ', '‡¶≠‡¶æ‡¶∑‡¶æ', '‡™≠‡™æ‡¶∑‡™æ', '‡≤≠‡≤æ‡≤∑‡≥Ü', '‡¥≠‡¥æ‡¥∑', '‡§≠‡§æ‡§∑‡§æ', '‡ÆÆ‡Øä‡Æ¥‡Æø', '‡∞≠‡∞æ‡∞∑', 'ÿ≤ÿ®ÿßŸÜ']):
                    response = self.multilingual.process_multilingual_command(query)
                    return response
                
                # Process command in current language context only for non-English commands
                detected_lang = self.multilingual.detect_language(query)
                if detected_lang != 'english':
                    response = self.multilingual.process_command_in_language(query, self.multilingual.current_language)
                    if response != self.multilingual.get_response('processing'):
                        return response
            # Handle continuous listening commands FIRST
            query_clean = query.lower().strip()
          
            
            # Handle code review commands FIRST to prevent interference
            if query_clean == 'code review':
                return self._code_review()
            
            if query_clean == 'folder review' or query_clean == 'review':
                return self._folder_review()
            
                        # Check new features FIRST before any other processing
            new_feature_result = self._check_new_features(query)
            if new_feature_result:
                return new_feature_result
            
            if query_clean.startswith('folder review '):
                folder_name = query[14:].strip()
                return self._folder_review(folder_name)
            
            if "start dictation" in query_lower or "begin dictation" in query_lower or "start writing" in query_lower:
                return self._start_dictation(query)
            elif "stop dictation" in query_lower or "end dictation" in query_lower or "stop writing" in query_lower:
                return self._stop_dictation()
            elif "dictate document" in query_lower:
                return self._dictate_document(query)
            elif "dictate email" in query_lower:
                return self._dictate_document(query, "email")
            elif "dictate anywhere" in query_lower or "write anywhere" in query_lower:
                return self._dictate_anywhere(query)
            
            
            if query_clean.startswith('file review '):
                file_path = query[12:].strip()
                return self._file_review(file_path)
            
            if query_clean == 'start live review':
                return self._start_live_review()
            
            if query_clean == 'stop live review':
                return self._stop_live_review()
            
            if query_clean == 'live code review':
                return self._live_code_review()
            
            # Skip all other processing for review commands
            if 'review' in query_clean and not query_clean.startswith('folder review ') and not query_clean.startswith('live'):
                return self._folder_review()
            
            # Check for dynamic commands - HIGHEST PRIORITY
            import re
            
            # Volume/brightness with numbers - PROCESS IMMEDIATELY
            volume_match = re.search(r'(?:set )?volume (?:to )?([0-9]+)', query.lower())
            brightness_match = re.search(r'(?:set )?brightness (?:to )?([0-9]+)', query.lower())
            
            if volume_match:
                level = int(volume_match.group(1))
                self._set_volume(level)
                return f"Volume set to {level}%"
            
            if brightness_match:
                level = int(brightness_match.group(1))
                self._set_brightness(level)
                return f"Brightness set to {level}%"
            
            # Handle age calculation commands - HIGH PRIORITY
            if 'my age' in query.lower() or 'calculate my age' in query.lower() or 'age calculator' in query.lower():
                return self._age_calculator()
            
            # Handle code writer commands - HIGH PRIORITY
            if any(cmd in query.lower() for cmd in ['write code', 'generate code', 'create code', 'code generator', 'write python code', 'write javascript code', 'write java code', 'write c++ code', 'write c# code', 'write html code', 'write css code', 'write php code', 'write ruby code', 'write go code', 'write rust code', 'write swift code', 'write kotlin code']):
                return self._write_code()
            
            # Handle project creation commands - HIGH PRIORITY
            if any(cmd in query.lower() for cmd in ['create project', 'build project', 'make project']):
                return self._create_project()
            
            # Handle "create document" commands - HIGH PRIORITY
            if any(cmd in query.lower() for cmd in ['create document', 'create report', 'create letter']):
                return self._ai_document_maker()
            
            # Handle "create file" commands - HIGH PRIORITY
            if 'create file' in query.lower() or 'new file' in query.lower():
                result = self._create_new_file()
                return result
            
            # Handle "copy file" commands - HIGH PRIORITY
            if query.lower().startswith('copy ') and ' to ' in query.lower():
                result = self._copy_file()
                return result
            
            # Handle "move file" commands - HIGH PRIORITY
            if query.lower().startswith('move ') and ' to ' in query.lower():
                result = self._move_file()
                return result
            
            # Handle file operations
            if query.lower().startswith('rename '):
                return self._rename_file_cmd()
            if query.lower().startswith('delete ') and 'file' in query.lower():
                return self._delete_file()
            if 'zip' in query.lower() and 'file' in query.lower():
                return self._zip_file()
            if 'unzip' in query.lower() or 'extract' in query.lower():
                return self._unzip_file()
            if 'file size' in query.lower():
                return self._get_file_size()
            if 'list files' in query.lower():
                return self._list_files()
            if 'find file' in query.lower() or 'search file' in query.lower():
                return self._find_file()
            if 'duplicate' in query.lower() and 'file' in query.lower():
                return self._find_duplicates()
            if 'large file' in query.lower() or 'big file' in query.lower():
                return self._find_large_files()
            if 'empty folder' in query.lower():
                return self._find_empty_folders()
            if 'file info' in query.lower():
                return self._get_file_info()
            if 'backup' in query.lower() and 'folder' in query.lower():
                return self._backup_folder()
            if 'search content' in query.lower() or 'content search' in query.lower():
                return self._search_content()
            if 'find similar' in query.lower() or 'similar files' in query.lower():
                return self._find_similar_files()
            if 'suggest folder' in query.lower() or 'smart folder' in query.lower():
                return self._suggest_folder()
            if 'map relationships' in query.lower() or 'file relationships' in query.lower():
                return self._map_file_relationships()
           
            
            # Handle Google search commands
            if 'search google' in query.lower() or 'google search' in query.lower():
                return self._search_google()
            
            # Handle Wikipedia search commands (with typo handling)
            if 'wikipedia search' in query.lower() or 'wekipidea search' in query.lower() or 'wiki search' in query.lower():
                search_term = re.sub(r'(?:wikipedia|wekipidea|wiki)\s+search\s+(?:for\s+)?', '', query.lower()).strip()
                return self._wikipedia_search(search_term)
            
            # Handle image search commands
            if 'search images' in query.lower() or 'image search' in query.lower() or 'search for images' in query.lower():
                return self._search_images()
            
            # Handle GIF search commands
            if 'search gifs' in query.lower() or 'gif search' in query.lower() or 'search for gifs' in query.lower():
                return self._search_gifs()
            
            # Handle copy webpage link commands
            if 'copy link' in query.lower() or 'copy webpage link' in query.lower() or 'copy url' in query.lower():
                return self._copy_webpage_link()
            
            # Handle translate webpage commands
            if 'translate page' in query.lower() or 'translate webpage' in query.lower() or 'translate this page' in query.lower():
                return self._translate_webpage()
            
            # Handle website status check commands
            if 'check website' in query.lower() or 'website status' in query.lower() or 'is website up' in query.lower():
                return self._check_website_status()
            
            # Handle radio commands
            if 'play radio' in query.lower() or 'online radio' in query.lower() or 'radio station' in query.lower():
                return self._play_radio()
            
            # Handle podcast commands
            if 'play podcast' in query.lower() or 'online podcast' in query.lower() or 'listen podcast' in query.lower():
                return self._play_podcast()
            
            # Handle radio commands before YouTube search
            if 'radio' in query.lower() and ('play' in query.lower() or 'listen' in query.lower()):
                return self._play_radio()
            
            # Handle traffic commands - HIGH PRIORITY
            if 'traffic' in query.lower() and ('updates' in query.lower() or 'info' in query.lower() or 'conditions' in query.lower() or query.lower().strip() == 'traffic'):
                return self._get_traffic()
            

            

            
            # Handle travel search commands - HIGH PRIORITY
            if 'search' in query.lower():
                if 'flight' in query.lower() or 'flights' in query.lower():
                    return self._search_flights()
                elif 'hotel' in query.lower() or 'hotels' in query.lower():
                    return self._search_hotels()
            
            # Handle price tracking commands - HIGH PRIORITY
            if 'track' in query.lower() and 'price' in query.lower():
                if 'amazon' in query.lower():
                    return self._track_amazon_price_debug()
                elif 'flipkart' in query.lower():
                    return self._track_flipkart_price_debug()
                else:
                    return self._check_product_price_debug()
            
            # Handle reminder commands - HIGHEST PRIORITY
            if 'set reminder' in query.lower() or 'remind me' in query.lower() or 'task reminder' in query.lower():
                try:
                    from engine.new_features import task_reminder
                    return task_reminder(query)
                except Exception as e:
                    return f"Reminder feature error: {str(e)}"
            
            # Handle AI presentation commands - HIGHEST PRIORITY
            if any(phrase in query.lower() for phrase in ['make slides', 'create slides', 'create presentation', 'make presentation', 'slides of', 'presentation of', 'create ppt', 'make ppt']):
                return self._ai_presentation()
            
            # Handle "open" commands - HIGHEST PRIORITY
            if query.lower().startswith('open '):
                content = query[5:].strip().lower()  # Remove 'open '
                
                # Direct mappings for open commands
                direct_mappings = {
                    'facebook': 'facebook',
                    'instagram': 'instagram',
                    'google': 'google',
                    'youtube': 'youtube',
                    'gmail': 'gmail',
                    'twitter': 'twitter',
                    'linkedin': 'linkedin',
                    'whatsapp': 'whatsapp_web',
                    'netflix': 'netflix',
                    'amazon': 'amazon',
                    'flipkart': 'flipkart',
                    'wikipedia': 'wikipedia',
                    'stackoverflow': 'stackoverflow',
                    'github': 'github',
                    'notepad': 'notepad',
                    'calculator': 'calculator',
                    'chrome': 'chrome',
                    'edge': 'edge',
                    'firefox': 'firefox',
                    'word': 'word',
                    'excel': 'excel',
                    'powerpoint': 'powerpoint',
                    'vlc': 'vlc',
                    'vscode': 'vscode',
                    'spotify': 'spotify',
                    'steam': 'steam',
                    'explorer': 'explorer',
                    'settings': 'settings',
                    'taskmanager': 'taskmanager',
                    'cmd': 'cmd',
                    'paint': 'paint'
                }
                
                # Check for exact single command match first
                if content in direct_mappings:
                    func_name = direct_mappings[content]
                    try:
                        result = self.functions[func_name]()
                        return self._get_response(func_name, result)
                    except Exception as e:
                        return f"Error opening {content}"
                
            
                
                # If not found in direct mappings, try original function check
                if content in self.functions:
                    result = self.functions[content]()
                    return self._get_response(content, result)
            
            # Handle volume commands with better parsing
            if 'volume' in query.lower():
                if 'up' in query.lower() or 'increase' in query.lower():
                    result = self.functions['volume_up']()
                    return self._get_response('volume_up', result)
                elif 'down' in query.lower() or 'decrease' in query.lower():
                    result = self.functions['volume_down']()
                    return self._get_response('volume_down', result)
                elif 'mute' in query.lower():
                    result = self.functions['mute']()
                    return self._get_response('mute', result)
            
        
            
            # Handle brightness commands
            if 'brightness' in query.lower():
                if 'up' in query.lower() or 'increase' in query.lower():
                    result = self.functions['brightness_up']()
                    return self._get_response('brightness_up', result)
                elif 'down' in query.lower() or 'decrease' in query.lower():
                    result = self.functions['brightness_down']()
                    return self._get_response('brightness_down', result)
            
            # Chrome automation commands
            if query.lower().startswith('chrome '):
                chrome_cmd = query.lower().replace('chrome ', '').strip().replace(' ', '_')
                # Handle singular/plural variations
                if chrome_cmd == 'setting':
                    chrome_cmd = 'settings'
                chrome_function = f'chrome_{chrome_cmd}'
                if chrome_function in self.functions:
                    result = self.functions[chrome_function]()
                    return self._get_response(chrome_function, result)
            
            # YouTube automation commands  
            if query.lower().startswith('youtube '):
                youtube_cmd = query.lower().replace('youtube ', '').strip()
                # Handle common variations
                if 'next video' in youtube_cmd or 'next song' in youtube_cmd:
                    youtube_cmd = 'next'
                elif 'previous video' in youtube_cmd or 'previous song' in youtube_cmd:
                    youtube_cmd = 'previous'
                elif 'skip forward' in youtube_cmd:
                    youtube_cmd = 'skip_forward'
                elif 'skip backward' in youtube_cmd or 'skip back' in youtube_cmd:
                    youtube_cmd = 'skip_backward'
                
                youtube_cmd = youtube_cmd.replace(' ', '_')
                youtube_function = f'youtube_{youtube_cmd}'
                if youtube_function in self.functions:
                    result = self.functions[youtube_function]()
                    return self._get_response(youtube_function, result)
            
            # Email summarization with content
            if query.lower().startswith('summarize email '):
                email_content = query[16:].strip()  # Remove 'summarize email '
                try:
                    from engine.voice_advanced_ai import voice_advanced_ai
                    return voice_advanced_ai.email_summarize(email_content)
                except:
                    return "Error summarizing email"
            
            # Calendar commands - force use of voice_advanced_ai
            if 'show calendar' in query.lower() or 'check calendar' in query.lower() or 'add event' in query.lower():
                try:
                    from engine.voice_advanced_ai import get_voice_advanced_response
                    return get_voice_advanced_response(query)
                except:
                    pass
            
            # Package management commands
            if query.lower().startswith('install '):
                package = query[8:].strip()  # Remove 'install '
                try:
                    from engine.voice_advanced_ai import voice_advanced_ai
                    return voice_advanced_ai.install_package(package)
                except:
                    return "Error installing package"
            
            if query.lower() == 'list packages':
                try:
                    from engine.voice_advanced_ai import voice_advanced_ai
                    return voice_advanced_ai.list_packages()
                except:
                    return "Error listing packages"
            
            # Check for research agent before search patterns
            if 'research agent' in query.lower() or 'research help' in query.lower():
                return self._research_agent()
            
            # Health & Wellness dynamic commands
            if query.lower().startswith('health log '):
                entry = query[11:].strip()  # Remove 'health log '
                try:
                    from engine.voice_advanced_ai import voice_advanced_ai
                    return voice_advanced_ai.daily_health_log(entry)
                except:
                    return "Error logging health data"
            
            if query.lower().startswith('mood tracker ') or query.lower().startswith('track mood '):
                if query.lower().startswith('mood tracker '):
                    mood = query[13:].strip()  # Remove 'mood tracker '
                else:
                    mood = query[11:].strip()  # Remove 'track mood '
                try:
                    from engine.voice_advanced_ai import voice_advanced_ai
                    return voice_advanced_ai.mood_tracker(mood)
                except:
                    return "Error tracking mood"
            
            if query.lower().startswith('meditate ') or query.lower().startswith('meditation '):
                if query.lower().startswith('meditate '):
                    duration = query[9:].strip()  # Remove 'meditate '
                else:
                    duration = query[11:].strip()  # Remove 'meditation '
                try:
                    from engine.voice_advanced_ai import voice_advanced_ai
                    if duration and duration.isdigit():
                        return voice_advanced_ai.meditation_prompt(duration)
                    return voice_advanced_ai.meditation_prompt()
                except:
                    return "Error starting meditation"
            
            # Security & Authentication dynamic commands
            if query.lower().startswith('encrypt file '):
                file_path = query[13:].strip()  # Remove 'encrypt file '
                try:
                    from engine.voice_advanced_ai import voice_advanced_ai
                    return voice_advanced_ai.file_vault_encrypt(file_path)
                except:
                    return "Error encrypting file"
            
            if query.lower().startswith('decrypt file '):
                file_path = query[13:].strip()  # Remove 'decrypt file '
                try:
                    from engine.voice_advanced_ai import voice_advanced_ai
                    return voice_advanced_ai.file_vault_decrypt(file_path)
                except:
                    return "Error decrypting file"
            
            if query.lower().startswith('phishing scan '):
                url = query[14:].strip()  # Remove 'phishing scan '
                try:
                    from engine.voice_advanced_ai import voice_advanced_ai
                    return voice_advanced_ai.phishing_malware_scan_link(url)
                except:
                    return "Error scanning URL"
            
            if query.lower().startswith('parental control '):
                action = query[17:].strip()  # Remove 'parental control '
                try:
                    from engine.voice_advanced_ai import voice_advanced_ai
                    return voice_advanced_ai.parental_control_set(action)
                except:
                    return "Error with parental control"
            
            # Adaptive Learning dynamic commands
            if query.lower().startswith('adaptive learning '):
                action = query[18:].strip()  # Remove 'adaptive learning '
                try:
                    from engine.voice_advanced_ai import voice_advanced_ai
                    return voice_advanced_ai.adaptive_learning(action)
                except:
                    return "Error with adaptive learning"
            
            if query.lower().startswith('manual learn '):
                action = query[13:].strip()  # Remove 'manual learn '
                try:
                    from engine.voice_advanced_ai import voice_advanced_ai
                    return voice_advanced_ai.manual_learn(action)
                except:
                    return "Error with manual learning"
            
            if query.lower().startswith('teach jarvis '):
                action = query[14:].strip()  # Remove 'teach jarvis '
                try:
                    from engine.voice_advanced_ai import voice_advanced_ai
                    return voice_advanced_ai.manual_learn(action)
                except:
                    return "Error teaching Jarvis"
            

            
            # Dynamic search and play commands - more flexible detection
            play_patterns = [
                r'(?:play|search)\s+(?:video|movie|song|music|on youtube)?\s*(.+)',
                r'youtube\s+(?:play|search)\s+(.+)',
                r'(?:play|search)\s+(.+?)\s+(?:on youtube|video|song|music)',
                r'(?:play|search)\s+(.+)'
            ]
            
            for pattern in play_patterns:
                play_match = re.search(pattern, query.lower())
                if play_match:
                    search_term = play_match.group(1).strip()
                    # Only trigger YouTube search if "youtube", "search", or "play" is explicitly mentioned
                    if ('youtube' in query.lower() and 'search' in query.lower() or 'play' in query.lower()) and search_term:
                        # Exclude system commands
                        system_commands = ['notepad', 'calculator', 'chrome', 'word', 'excel']
                        if not any(cmd in search_term.lower() for cmd in system_commands):
                            return self._search_and_play(search_term)
                    break
            
            # Face auth commands - handle before general on/off
            if 'face auth' in query.lower() or 'face recognition' in query.lower():
                if 'enable' in query.lower() or 'turn on' in query.lower():
                    result = self._enable_face_auth()
                    return self._get_response('enable_face_auth', result)
                elif 'disable' in query.lower() or 'turn off' in query.lower():
                    result = self._disable_face_auth()
                    return self._get_response('disable_face_auth', result)
                elif 'status' in query.lower() or 'check' in query.lower():
                    result = self._get_face_auth_status()
                    return self._get_response('face_auth_status', result)
            
            # Dynamic on/off commands using AI
            on_off_match = re.search(r'(?:turn (on|off)|(?:enable|disable)) (.+)', query.lower())
            if on_off_match:
                action = on_off_match.group(1) if on_off_match.group(1) else ('on' if 'enable' in query.lower() else 'off')
                feature = on_off_match.group(2).strip()
                # Skip face auth as it's handled above
                if 'face' not in feature:
                    return self._handle_on_off(feature, action)
            
            if volume_match:
                level = int(volume_match.group(1))
                self._set_volume(level)
                return f"Volume set to {level}%"
            
            if brightness_match:
                level = int(brightness_match.group(1))
                self._set_brightness(level)
                return f"Brightness set to {level}%"
            

            
            if self._is_question(query):
                return self._answer_question(query)
            
            # Enhanced command matching with better natural language processing
            query_lower = query.lower().strip()
            
            # First try exact matches
            if query_lower in self.functions:
                func_name = query_lower
                print(f"Exact match found: {func_name}")
            else:
                # Try natural language understanding with enhanced matching
                func_name = self.understand_natural_speech(query)
                print(f"Natural language result: {func_name}")
                
                # If still no match, try fuzzy matching for common commands
                if not func_name:
                    func_name = self._fuzzy_match_command(query_lower)
                    print(f"Fuzzy match result: {func_name}")
                
                
                if not func_name:
                  
                    # try:
                    #     from engine.voice_advanced_ai import get_voice_advanced_response
                    #     advanced_response = get_voice_advanced_response(query)
                    #     print(f"Advanced AI response: '{advanced_response}'")
                    #     if advanced_response and "Voice command not recognized" not in advanced_response and "Error:" not in advanced_response:
                    #         print("Returning advanced AI response")
                    #         return advanced_response
                    # except Exception as e:
                    #     print(f"Advanced AI failed: {e}")
                    #     pass
                    
                    # Final fallback to AI model for function selection
                    # Check new features first
                    try:
                        from engine.new_features import get_new_feature_response
                        new_feature_result = get_new_feature_response(query)
                        if new_feature_result:
                            return new_feature_result
                    except:
                        pass
                    
                    # AI mapping for both dual_ai and new_features
                    print("Starting AI mapping process...")
                    all_functions = list(self.functions.keys())
                    try:
                        from engine.new_features import _new_features_instance
                        if _new_features_instance:
                            all_functions.extend(list(_new_features_instance.features.keys()))
                    except:
                        pass
                    
                    prompt = f'''TASK: Find exact function name for user command.

USER COMMAND: "{query}"
AVAILABLE FUNCTIONS: {all_functions}

MATCH EXAMPLES:
"mouse to center" = move_mouse_center
"turn off computer" = shutdown
"make louder" = volume_up
"take picture" = screenshot
"remind me" = task_reminder

INSTRUCTIONS:
- Return ONLY the exact function name from the list
- If no match found, return: none
- No explanations, no extra text

RESPONSE:'''
                    
                    try:
                        raw_response = self.get_ai_response(prompt)
                        print(f"Raw AI response: '{raw_response}'")
                        # Clean and validate the AI response
                        func_name = self._clean_ai_response(raw_response, all_functions)
                      
                        if func_name:
                            print(f"AI mapping successful: '{query}' -> {func_name}")
                        else:
                            print(f"AI mapping failed for: '{query}' (raw response: '{raw_response}')")
                    except Exception as e:
                        print(f"AI API error: {e}")
                        # Reset token count if we hit rate limits
                        if 'rate limit' in str(e).lower():
                            print("Rate limit hit, resetting token count")
                            self._reset_token_count()
                        func_name = None
                        

            # Check dual_ai functions first
            if func_name and func_name in self.functions:
                print(f"Executing dual_ai function: {func_name}")
                result = self.functions[func_name]()
                # For advanced features, return the actual result
                advanced_result_features = ['joke', 'quote', 'disk_space', 'ip_address', 'system_uptime', 'temperature', 'running_processes', 'check_internet', 'wifi_password', 'network_speed', 'create_folder', 'create_new_file', 'delete_file', 'search_files', 'set_reminder', 'schedule_shutdown', 'auto_backup', 'clean_temp', 'move_mouse_up', 'move_mouse_down', 'move_mouse_left', 'move_mouse_right', 'move_mouse_center', 'left_click', 'right_click', 'double_click', 'start_drag', 'drop_here', 'scroll_up', 'scroll_down', 'scroll_to_top', 'type_text', 'press_enter', 'press_tab', 'press_escape', 'press_backspace', 'press_delete', 'go_to_beginning', 'go_to_end', 'play_video', 'play_movie', 'play_song', 'search_and_play', 'open_multiple', 'daily_briefing', 'predictive_assistance', 'context_memory_recall', 'show_calendar', 'schedule', 'email_summarize', 'sync_devices', 'auto_fix_system', 'manage_package', 'docker_control', 'adaptive_learning', 'check_proactive', 'enable_proactive_mode', 'disable_proactive_mode', 'manual_learn', 'file_vault_encrypt', 'file_vault_decrypt', 'anomaly_detection', 'phishing_scan', 'parental_control', 'calendar_schedule', 'cloud_backup', 'realtime_transcription', 'summarize_meeting', 'smart_clipboard', 'document_qa', 'ai_presentation', 'smart_home_control', 'set_home_scene', 'security_camera', 'energy_monitoring', 'ai_dj_mode', 'trivia_game', 'storytelling', 'fitness_coach', 'code_agent', 'research_agent', 'organizer_agent', 'multi_agent_collab', 'scholar_search', 'stock_updates', 'crypto_updates', 'realtime_translation', 'posture_detection', 'eye_care_mode', 'daily_health_log', 'mood_tracker', 'meditation_prompt', 'start_gesture_control', 'stop_gesture_control', 'weekday', 'current_weekday', 'traffic_updates', 'public_holidays', 'covid_stats', 'open_path', 'sort_files', 'create_document', 'create_report', 'create_letter', 'ai_document']
                if func_name in advanced_result_features:
                    return result
                response = self._get_response(func_name, result)
                return response
            # Check new_features functions
            elif func_name:
                try:
                    from engine.new_features import _new_features_instance
                    if _new_features_instance and func_name in _new_features_instance.features:
                        # Execute new features function with query parameter if needed
                        query_functions = ['weather_forecast', 'email_templates', 'meeting_scheduler', 'task_reminder', 'list_reminders', 'image_editor', 'audio_converter', 'video_downloader', 'voice_recorder', 'screen_recorder', 'water_reminder', 'exercise_timer', 'calorie_calculator', 'sleep_tracker', 'stress_meter', 'mood_tracker', 'heart_rate_monitor', 'medication_reminder', 'bmi_calculator', 'system_monitor', 'network_monitor', 'language_translator', 'dictionary_lookup', 'wikipedia_search', 'calculator_advanced', 'unit_converter', 'flashcard_system', 'quiz_generator', 'meme_generator', 'logo_generator', 'color_palette_generator', 'font_viewer', 'ascii_art_generator', 'barcode_generator', 'mind_map_creator', 'password_manager', 'startup_manager', 'git_helper', 'port_scanner', 'email_sender', 'financial_tools', 'speed_test', 'battery_health', 'thermal_monitor', 'quick_note_taker', 'large_file_scanner', 'file_search_engine', 'recent_files_tracker', 'open_app', 'close_app', 'open_website', 'close_website']
                        
                        if func_name in query_functions:
                            result = _new_features_instance.features[func_name](query)
                        else:
                            result = _new_features_instance.features[func_name]()
                        
                        return result if result else f"{func_name} completed"
                except:
                    pass
            
            # Final fallback
            print("Checking if question...")
            if self._is_question(query):
                print("Processing as question")
                response = self._answer_question(query)
                return response
            # Try multilingual processing as fallback
            print("Trying multilingual processing...")
            if self.multilingual:
                ml_response = self.multilingual.process_command_in_language(query, self.multilingual.current_language)
                print(f"Multilingual response: '{ml_response}'")
                if ml_response != self.multilingual.get_response('processing'):
                    print("Returning multilingual response")
                    return ml_response
            
            print("Returning 'Command not recognized'")
            return "Command not recognized"
                
        except Exception as e:
            print(f"Error: {e}")
            return "Command not recognized"
    
    def _clean_ai_response(self, response, valid_functions):
        """Clean and validate AI response to ensure it returns a valid function name"""
        if not response:
            return None
            
        # Clean the response - remove quotes, whitespace, and common prefixes
        cleaned = response.strip().strip('"').strip("'").strip()
        
        # Remove common AI response patterns
        patterns_to_remove = [
            'function name:', 'the function is:', 'answer:', 'result:', 
            'i suggest:', 'i recommend:', 'use:', 'call:', 'execute:'
        ]
        
        for pattern in patterns_to_remove:
            if cleaned.lower().startswith(pattern):
                cleaned = cleaned[len(pattern):].strip()
        
        # Handle multi-line responses - take only the first line
        cleaned = cleaned.split('\n')[0].strip()
        
        # Check if it's a valid function name
        if cleaned in valid_functions:
            return cleaned
        
        # Check for partial matches (case insensitive)
        cleaned_lower = cleaned.lower()
        for func in valid_functions:
            if func.lower() == cleaned_lower:
                return func
        
        # Check if response indicates no match
        no_match_indicators = ['none', 'no match', 'not found', 'unknown', 'null', 'n/a']
        if cleaned.lower() in no_match_indicators:
            return None
            
        return None

    def understand_natural_speech(self, query):
        """Complete natural language processing for ALL functions"""
        query = query.lower().strip()
        
        mappings = {
            'shutdown': ['shut down', 'turn off computer', 'power off', 'shutdown computer'],
            'restart': ['restart', 'reboot', 'restart computer', 'reboot system'],
            'sleep': ['sleep', 'put to sleep', 'sleep mode'],
            'lock': ['lock', 'lock screen', 'secure screen'],
            'hibernate': ['hibernate', 'deep sleep', 'hibernation'],
            'volume_up': ['volume up', 'louder', 'increase volume', 'make it louder', 'turn up sound', 'increase the volume'],
            'volume_down': ['volume down', 'quieter', 'decrease volume', 'make it quieter', 'turn down sound'],
            'mute': ['mute', 'silence', 'turn off sound', 'mute audio'],
            'screenshot': ['screenshot', 'take screenshot', 'capture screen', 'take a picture of screen'],
            'brightness_up': ['brightness up', 'brighter', 'increase brightness', 'brighten screen'],
            'brightness_down': ['brightness down', 'dimmer', 'decrease brightness', 'my screen is too bright'],
            'show desktop': ['show desktop', 'go to desktop', 'minimize all'],
            'calculator': ['calculator', 'calc', 'open calculator'],
            'notepad': ['notepad', 'text editor', 'open notepad'],
            'chrome': ['chrome', 'browser', 'open chrome', 'web browser'],
            'stop_ambient_awareness': ['stop ambient awareness', 'end ambient awareness'],
            'sort_files': ['sort files', 'sort by date', 'sort by time', 'sort by name', 'sort by size', 'arrange files', 'organize files', 'arrange files by size', 'arrange files by date', 'arrange files by name', 'sort files by size', 'sort files by date', 'sort files by name'],
            'ambient_status': ['ambient status', 'check ambient status'],
            'start_ambient_awareness': ['start ambient awareness', 'ambient awareness', 'start ambient', 'begin ambient awareness', 'activate ambient awareness'],
            'edge': ['edge', 'microsoft edge', 'open edge'],
            'firefox': ['firefox', 'open firefox', 'mozilla'],
            'word': ['word', 'microsoft word', 'document editor'],
            'excel': ['excel', 'spreadsheet', 'microsoft excel'],
            'powerpoint': ['powerpoint', 'presentation', 'slides'],
            'vlc': ['vlc', 'video player', 'media player'],
            'vscode': ['vscode', 'code editor', 'visual studio'],
            'spotify': ['spotify', 'music', 'music player'],

            'steam': ['steam', 'games', 'gaming'],
            'explorer': ['explorer', 'file manager'],
            'settings': ['settings', 'system settings', 'control panel'],
            'taskmanager': ['task manager', 'processes', 'taskmanager'],
            'cmd': ['command prompt', 'cmd', 'terminal'],
            'paint': ['paint', 'drawing', 'mspaint'],
            'google': ['google', 'search', 'google search'],
            'youtube': ['youtube', 'videos', 'watch videos'],
            'wikipedia': ['wikipedia', 'wiki', 'encyclopedia'],
            'stackoverflow': ['stackoverflow', 'programming help', 'coding help'],
            'github': ['github', 'git', 'code repository'],
            'amazon': ['amazon', 'shopping', 'buy online'],
            'flipkart': ['flipkart', 'shopping india'],
            'instagram': ['instagram', 'insta', 'photos'],
            'facebook': ['facebook', 'fb', 'social media'],
            'twitter': ['twitter', 'tweets', 'social'],
            'linkedin': ['linkedin', 'professional network'],
            'whatsapp_web': ['whatsapp', 'messaging', 'chat'],
            'gmail': ['gmail', 'email', 'mail'],
            'netflix': ['netflix', 'movies', 'streaming'],
            'copy': ['copy', 'copy text', 'copy this'],
            'paste': ['paste', 'paste text', 'paste here'],
            'save': ['save', 'save file', 'save document'],
            'undo': ['undo', 'undo last action', 'go back'],
            'select_all': ['select all', 'select everything'],
            'alt_tab': ['switch window', 'alt tab', 'change window'],
            'time': ['time', 'what time is it', 'current time', 'tell me the time','time now','what is time now'],
            'date': ['date', 'what date is it', 'current date', 'today'],
            'cpu': ['cpu usage', 'processor usage', 'cpu load'],
            'memory': ['memory usage', 'ram usage', 'memory load'],
            'battery': ['battery', 'battery level', 'battery percentage'],
            'downloads': [ 'download folder','downloads folder'],
            'documents': ['documents', 'my documents'],
            'pictures': ['pictures', 'photos', 'image folder'],
            'switch_to_gemini': ['switch to gemini', 'use gemini', 'gemini ai'],
            'switch_to_groq': ['switch to groq', 'use groq', 'groq ai'],
            'current_ai': ['current ai', 'which ai', 'ai status'],
            'switch_language_hindi': ['hindi', 'switch to hindi'],
            'switch_language_kannada': ['kannada', 'switch to kannada'],
            'switch_language_english': ['english', 'switch to english'],
            'close_chrome': ['close chrome', 'quit chrome'],
            'close_edge': ['close edge', 'quit edge'],
            'close_notepad': ['close notepad', 'quit notepad'],
            'switch_to_male_voice': ['male voice', 'switch to male'],
            'switch_to_female_voice': ['female voice', 'switch to female'],
            'current_voice_gender': ['voice status', 'current voice'],
            'context_memory_recall': ['what do you remember', 'recall memory', 'show memories'],
            'daily_briefing': ['daily briefing', 'morning briefing'],
            'predictive_assistance': ['predictive help', 'smart suggestions'],
            'schedule': ['schedule meeting', 'add event', 'book appointment'],
            'show_calendar': ['show calendar', 'check calendar'],
            'posture_detection': ['posture check', 'check posture'],
            'eye_care_mode': ['eye care', 'protect eyes'],
            'daily_health_log': ['health log', 'log health'],
            'mood_tracker': ['mood tracker', 'track mood'],
            'meditation_prompt': ['meditate', 'meditation', 'relax'],
            'trivia_game': ['trivia', 'quiz game', 'test knowledge'],
            'storytelling': ['tell story', 'story time'],
            'fitness_coach': ['fitness coach', 'workout guide'],
            'ai_dj_mode': ['dj mode', 'music mix'],
            'code_agent': ['code help', 'programming assistant'],
            'research_agent': ['research help', 'research assistant'],
            'organizer_agent': ['organize', 'task organizer'],
            'smart_home_control': ['smart home', 'home automation'],
            'set_home_scene': ['home scene', 'set scene'],
            'start_gesture_control': ['gesture control', 'hand control'],
            'stop_gesture_control': ['stop gestures', 'disable gestures'],
            'code_review': ['code review', 'review code', 'check code'],
            'folder_review': ['folder review', 'review folder'],
            'live_code_review': ['live review', 'real time review'],
            'joke': ['tell joke', 'joke', 'make me laugh'],
            'quote': ['quote', 'inspirational quote', 'wisdom'],
    
            'news': ['news', 'latest news', 'headlines'],
            'disk_space': ['disk space', 'storage space', 'free space'],
            'system_uptime': ['uptime', 'system uptime', 'how long running'],
            'temperature': ['temperature', 'cpu temperature', 'system temp'],
            'running_processes': ['processes', 'running programs', 'active processes', 'show running processes', 'list processes', 'running processes'],
            'check_internet': ['internet', 'check internet', 'connection test'],
            'ip_address': ['ip address', 'my ip', 'network address'],
            'wifi_password': ['wifi password', 'network password'],
            'network_speed': ['speed test', 'internet speed', 'connection speed'],
            'create_folder': ['create folder', 'new folder', 'make folder', 'folder create'],
            'create_new_file': ['create file', 'new file', 'make file', 'create new file'],
            'delete_file': ['delete file', 'remove file'],
            'search_files': ['search files', 'find files'],
            'copy_file': ['copy file', 'duplicate file', 'copy', 'file copy'],
            'move_file': ['move file', 'relocate file'],
            'maximize_window': ['maximize', 'maximize window', 'make bigger'],
            'minimize_window': ['minimize', 'minimize window', 'hide window'],
            'close_window': ['close window', 'close this'],
            'split_screen_left': ['split left', 'snap left', 'window left'],
            'split_screen_right': ['split right', 'snap right', 'window right'],
            'full_screen': ['full screen', 'fullscreen'],
            'play_pause': ['play', 'pause', 'play pause'],
            'next_track': ['next', 'next song', 'skip'],
            'previous_track': ['previous', 'previous song', 'back'],
            'stop_media': ['stop', 'stop playing'],
            'find_text': ['find', 'search text', 'find text'],
            'replace_text': ['replace', 'find replace'],
            'new_document': ['new document', 'new file'],
            'print_document': ['print', 'print document'],
            'zoom_in': ['zoom in', 'magnify', 'make bigger'],
            'zoom_out': ['zoom out', 'make smaller'],
            'clear_clipboard': ['clear clipboard', 'empty clipboard'],
            'clear_history': ['clear history', 'delete history'],
            'empty_recycle_bin': ['empty recycle bin', 'clear trash'],
            'lock_screen': ['lock screen', 'secure computer'],
       
            'schedule_shutdown': ['schedule shutdown', 'auto shutdown'],
            'auto_backup': ['backup', 'backup files'],
            'clean_temp': ['clean temp', 'delete temp files'],
            'play_music': ['play music', 'start music'],
            'random_wallpaper': ['change wallpaper', 'new wallpaper'],
            'move_mouse_up': ['mouse up', 'move mouse up', 'cursor up'],
            'move_mouse_down': ['mouse down', 'move mouse down', 'cursor down'],
            'move_mouse_left': ['mouse left', 'move mouse left', 'cursor left'],
            'move_mouse_right': ['mouse right', 'move mouse right', 'cursor right'],
            'move_mouse_center': ['mouse center', 'center mouse'],
            'left_click': ['left click', 'click', 'mouse click'],
            'right_click': ['right click', 'context menu'],
            'double_click': ['double click', 'double tap'],
            'scroll_up': ['scroll up', 'page up'],
            'scroll_down': ['scroll down', 'page down'],
            'press_enter': ['press enter', 'hit enter', 'enter key'],
            'press_tab': ['press tab', 'tab key'],
            'press_escape': ['press escape', 'escape key'],
            'press_backspace': ['backspace', 'delete back'],
            'press_delete': ['delete key', 'delete forward'],
            'youtube_play': ['youtube play', 'play video'],
            'youtube_pause': ['youtube pause', 'pause video'],
            'youtube_next': ['youtube next', 'next video'],
            'youtube_previous': ['youtube previous', 'previous video'],
            'youtube_fullscreen': ['youtube fullscreen', 'video fullscreen'],
            'youtube_volume_up': ['youtube louder', 'video volume up'],
            'youtube_volume_down': ['youtube quieter', 'video volume down'],
            'youtube_mute': ['youtube mute', 'mute video'],
            'youtube_speed_up': ['youtube faster', 'speed up video'],
            'youtube_speed_down': ['youtube slower', 'slow down video'],
            'youtube_skip_forward': ['youtube skip', 'skip ahead'],
            'youtube_skip_backward': ['youtube back', 'skip back'],
            'youtube_search': ['youtube search', 'search video'],
            'youtube_subscribe': ['youtube subscribe', 'subscribe channel'],
            'youtube_like': ['youtube like', 'like video'],
            'youtube_theater_mode': ['theater mode', 'cinema mode'],
            'youtube_captions': ['captions', 'subtitles'],
            'chrome_new_tab': ['new tab', 'open tab'],
            'chrome_close_tab': ['close tab', 'close current tab'],
            'chrome_next_tab': ['next tab', 'switch tab'],
            'chrome_previous_tab': ['previous tab', 'last tab'],
            'chrome_reload': ['reload', 'refresh'],
            'chrome_back': ['go back', 'back page'],
            'chrome_forward': ['go forward', 'forward page'],
            'chrome_bookmark': ['bookmark', 'save bookmark'],
            'chrome_history': ['history', 'browser history'],
            'chrome_downloads': ['downloads', 'download history'],
            'chrome_incognito': ['incognito', 'private browsing'],
            'chrome_settings': ['chrome settings', 'browser settings'],
            'enable_face_auth': ['enable face auth', 'face recognition on'],
            'disable_face_auth': ['disable face auth', 'face recognition off'],
            'face_auth_status': ['face auth status', 'check face auth'],
            # 'system_monitor_live': ['system monitor', 'live monitoring'],
            'auto_fix_system': ['auto fix', 'fix system'],
            'performance_monitor': ['performance monitor', 'system performance'],
            'enable_narrator': ['narrator on', 'enable narrator'],
            'disable_narrator': ['narrator off', 'disable narrator'],
            'enable_magnifier': ['magnifier on', 'enable magnifier'],
            'disable_magnifier': ['magnifier off', 'disable magnifier'],
            'high_contrast_mode': ['high contrast', 'contrast mode'],
            'connect_wifi': ['connect wifi', 'join network'],
            'disconnect_wifi': ['disconnect wifi', 'leave network'],
            'show_wifi_networks': ['wifi networks', 'available networks'],
            'enable_hotspot': ['hotspot on', 'mobile hotspot'],
            'disable_hotspot': ['hotspot off', 'disable hotspot'],
            'search_files_content': ['search in files', 'find in files'],
            'find_large_files': ['large files', 'big files'],
            'find_duplicate_files': ['duplicate files', 'find duplicates'],
            'smart_lights': ['smart lights', 'control lights'],
            'smart_fan': ['smart fan', 'control fan'],
            'smart_ac': ['smart ac', 'air conditioning'],
            'write_code': ['write code', 'generate code', 'create code', 'code generator', 'write python code', 'write javascript code', 'write java code', 'write html code', 'write css code', 'python code for', 'javascript code for', 'java code for', 'code for'],
            'create_project': ['create project', 'build project', 'make project', 'new project', 'project for'],
            'generate_code': ['generate code', 'write code'],
            'debug_code': ['debug code', 'fix code'],
            'translate_text': ['translate', 'translate text'],
            'summarize_text': ['summarize', 'summary'],
            'analyze_image': ['analyze image', 'image analysis'],
            'send_email': ['send email', 'compose email'],
            'schedule_meeting': ['schedule meeting', 'book meeting'],
            'create_task': ['create task', 'new task'],
            'convert_document': ['convert document', 'change format'],
            'merge_pdf': ['merge pdf', 'combine pdf'],
            'git_status': ['git status', 'check git'],
            'git_commit': ['git commit', 'commit changes'],
            'run_tests': ['run tests', 'execute tests'],
            'format_code': ['format code', 'beautify code'],
            'api_test': ['api test', 'test api'],
            'water_reminder': ['water reminder', 'drink water'],
            'break_reminder': ['break reminder', 'take break'],
            'fitness_track': ['fitness track', 'exercise log'],
            'wikipedia_search': ['wikipedia', 'wiki search'],
            'dictionary_lookup': ['dictionary', 'word meaning'],
            'unit_convert': ['convert units', 'unit conversion'],
            'math_calculate': ['calculate', 'math calculation'],
            'language_learn': ['learn language', 'language learning'],
            'movie_recommend': ['movie recommendation', 'suggest movie'],

            'game_launch': ['launch game', 'start game'],
            'streaming_control': ['streaming control', 'media streaming'],
            'playlist_manage': ['manage playlist', 'playlist control'],
            'workflow_automate': ['automate workflow', 'automation'],
            'batch_operations': ['batch operation', 'bulk operation'],
            'scheduled_tasks': ['scheduled task', 'task scheduler'],
            'system_maintenance': ['system maintenance', 'maintain system'],
            'auto_updates': ['auto updates', 'automatic updates'],
            'tell_joke': ['tell joke', 'joke', 'make me laugh'],
            'get_quote': ['quote', 'inspirational quote'],
      
            'get_news': ['news', 'latest news'],
            'play_video': ['play video', 'watch video'],
            'play_movie': ['play movie', 'watch movie'],
            'play_song': ['play song', 'play music'],
            'search_and_play': ['search and play', 'find and play'],
            'open_multiple': ['open multiple', 'open several'],
            
            # Mapping Commands
            'open_maps': ['open maps', 'show maps', 'google maps', 'maps'],
            'find_location': ['find location', 'search location', 'locate', 'where is'],
            'get_directions': ['directions', 'navigate to', 'route to', 'how to get to'],
            'nearby_places': ['nearby', 'find nearby', 'places near me', 'restaurants near me'],
            'traffic_info': ['traffic', 'traffic info', 'show traffic', 'traffic conditions'],
            'map_satellite': ['satellite view', 'satellite map', 'aerial view'],
            'map_terrain': ['terrain view', 'terrain map', 'topographic map'],
            'save_location': ['save location', 'bookmark location', 'remember this place'],
            'my_location': ['my location', 'current location', 'where am i'],
            'dictate_to_file': ['dictate to file', 'voice to file', 'speech to file'],
            'dictate_to_document': ['dictate document', 'voice document', 'speech document'],
            'hibernate_computer': ['hibernate computer', 'deep sleep'],
            'log_off': ['log off', 'sign out'],
            'switch_user': ['switch user', 'change user'],
            'enable_airplane_mode': ['airplane mode on', 'flight mode'],
            'disable_airplane_mode': ['airplane mode off', 'disable flight mode'],
            'start_screen_recording': ['start recording', 'record screen'],
            'stop_screen_recording': ['stop recording', 'end recording'],
            'start_dictation': ['start dictation', 'voice typing', 'dictate anywhere', 'open and dictate','start writting'],
            'stop_dictation': ['stop dictation', 'end dictation', 'stop lies', 'stop writing'],
            'dictate_anywhere': ['dictate anywhere', 'universal dictation', 'type anywhere'],
            'take_screenshot_window': ['window screenshot', 'capture window'],
            'take_screenshot_area': ['area screenshot', 'capture area'],
            'file_vault_encrypt': ['encrypt file', 'secure file'],
            'file_vault_decrypt': ['decrypt file', 'unlock file'],
            'anomaly_detection': ['scan for threats', 'security scan'],
            'phishing_scan': ['check for phishing', 'scan link'],
            'parental_control': ['parental control', 'child safety'],
            'cloud_backup': ['cloud backup', 'backup to cloud'],
            'email_summarize': ['summarize email', 'email summary'],
            'sync_devices': ['sync devices', 'synchronize'],
            'realtime_transcription': ['transcribe audio', 'voice to text'],
            'summarize_meeting': ['meeting summary', 'summarize discussion'],
            'smart_clipboard': ['smart clipboard', 'clipboard manager'],
            'document_qa': ['document questions', 'ask about document'],
            'ai_presentation': ['create presentation', 'make slides','create ppt'],
            'security_camera': ['security camera', 'surveillance'],
            'energy_monitoring': ['energy monitor', 'power usage'],
            'scholar_search': ['academic search', 'research papers'],
            'stock_updates': ['stock market', 'stock prices'],
            'crypto_updates': ['cryptocurrency', 'crypto prices'],
            'realtime_translation': ['translate text', 'language translation'],
            'manage_package': ['install package', 'manage software'],
            'docker_control': ['docker control', 'container management'],
            'adaptive_learning': ['learn from me', 'adapt to me'],
            'check_proactive': ['check suggestions', 'proactive help'],
            'enable_proactive_mode': ['enable proactive', 'turn on suggestions'],
            'disable_proactive_mode': ['disable proactive', 'turn off suggestions'],
            'manual_learn': ['teach you', 'manual learning'],
            'calendar_schedule': ['calendar event', 'schedule appointment'],
            'debug_screen': ['debug code', 'fix my code'],
            'fix_my_code': ['fix my code', 'repair code'],
            'check_code': ['check code', 'review code'],
            'multi_agent_collab': ['multi agent', 'agent collaboration'],
            'start_live_review': ['start live review', 'begin monitoring'],
            'stop_live_review': ['stop live review', 'end monitoring'],
            'switch_language_kannada': ['kannada', 'switch to kannada'],
            'switch_language_english': ['english', 'switch to english'],
            'close_chrome': ['close chrome', 'quit chrome'],
            'close_edge': ['close edge', 'quit edge'],
            'close_notepad': ['close notepad', 'quit notepad'],
            'switch_to_male_voice': ['male voice', 'switch to male'],
            'switch_to_female_voice': ['female voice', 'switch to female'],
            'current_voice_gender': ['voice status', 'current voice'],
            'context_memory_recall': ['what do you remember', 'recall memory', 'show memories'],
            'daily_briefing': ['daily briefing', 'morning briefing'],
            'predictive_assistance': ['predictive help', 'smart suggestions'],
            'schedule': ['schedule meeting', 'add event', 'book appointment'],
            'show_calendar': ['show calendar', 'check calendar'],
            'posture_detection': ['posture check', 'check posture'],
            'eye_care_mode': ['eye care', 'protect eyes'],
            'daily_health_log': ['health log', 'log health'],
            'mood_tracker': ['mood tracker', 'track mood'],
            'meditation_prompt': ['meditate', 'meditation', 'relax'],
            'trivia_game': ['trivia', 'quiz game', 'test knowledge'],
            'storytelling': ['tell story', 'story time'],
            'fitness_coach': ['fitness coach', 'workout guide'],
            'ai_dj_mode': ['dj mode', 'music mix'],
            'code_agent': ['code help', 'programming assistant'],
            'research_agent': ['research help', 'research assistant'],
            'organizer_agent': ['organize', 'task organizer'],
            'smart_home_control': ['smart home', 'home automation'],
            'set_home_scene': ['home scene', 'set scene'],
            'start_gesture_control': ['gesture control', 'hand control'],
            'stop_gesture_control': ['stop gestures', 'disable gestures'],
            'code_review': ['code review', 'review code', 'check code'],
            'folder_review': ['folder review', 'review folder'],
            'live_code_review': ['live review', 'real time review'],
            'joke': ['tell joke', 'joke', 'make me laugh'],
            'quote': ['quote', 'inspirational quote', 'wisdom'],
        
            'news': ['news', 'latest news', 'headlines'],
            'dice': ['dice', 'roll dice', 'roll a dice', 'roll the dice'],
            'coin': ['coin', 'flip coin', 'coin flip', 'flip the coin'],
            'roll_dice': ['roll dice', 'roll a dice', 'roll the dice'],
            'flip_coin': ['flip coin', 'coin flip', 'flip the coin'],
            'age_calculator': ['age calculator', 'calculate age', 'my age', 'how old am i', 'calculate my age', 'age calculation'],
            'calculate_age': ['calculate age', 'age calculator', 'find my age', 'determine age', 'age finder'],
            
            # Complete Voice Advanced AI Features Mappings
            # 'system_monitor_live': ['system monitor', 'monitor system', 'live monitoring', 'system status', 'system dashboard'],
            'auto_fix_system': ['auto fix', 'fix system', 'system fix', 'repair system', 'system repair'],
            'install_package': ['install package', 'install software', 'add package', 'package install'],
            'list_packages': ['list packages', 'show packages', 'installed packages', 'package list'],
            'uninstall_package': ['uninstall package', 'remove package', 'delete package', 'package remove'],
            'manage_package': ['manage package', 'package manager', 'software manager', 'package management'],
            
            # Advanced Memory & Context
            'context_memory_store': ['remember this', 'store memory', 'save this', 'store this'],
            'context_memory_recall': ['what do you remember', 'recall memory', 'show memories', 'my memories', 'stored memories'],
            'daily_briefing': ['daily briefing', 'morning briefing', 'get briefing', 'today summary', 'daily summary'],
            
            # Advanced Calendar & Scheduling
            'calendar_schedule': ['schedule event', 'book appointment', 'add event', 'create meeting', 'schedule meeting'],
            'show_calendar': ['show calendar', 'check calendar', 'my events', 'what meetings', 'calendar view', 'upcoming events'],
            
            # Advanced Email & Communication
            'email_summarize': ['summarize email', 'email summary', 'email brief', 'email digest'],
            'sync_devices': ['sync devices', 'device sync', 'synchronize', 'sync data'],
            'cloud_backup': ['cloud backup', 'backup files', 'backup to cloud', 'cloud storage'],
            
            # Advanced AI Productivity
            'realtime_transcription': ['transcribe audio', 'voice to text', 'speech to text', 'audio transcription'],
            'summarize_meeting': ['meeting summary', 'summarize discussion', 'meeting notes', 'discussion summary'],
            'smart_clipboard': ['smart clipboard', 'clipboard manager', 'clipboard history', 'clipboard storage'],
            'clipboard_assistant': ['clipboard assistant', 'smart clipboard help', 'clipboard helper'],
            'start_clipboard_assistant': ['start clipboard assistant', 'monitor clipboard', 'clipboard monitoring'],
            'stop_clipboard_assistant': ['stop clipboard assistant', 'stop clipboard monitoring'],
            'set_alarm': ['set alarm', 'alarm for', 'wake me up', 'reminder at', 'alarm at'],
            'cancel_alarm': ['cancel alarm', 'stop alarm', 'turn off alarm', 'disable alarm', 'remove alarm'],
            'create_image': ['create image', 'generate image', 'make image', 'ai image', 'image generation', 'draw image'],
            'document_qa': ['document questions', 'ask document', 'document help', 'document assistant'],
            'ai_presentation': ['create presentation', 'make slides', 'presentation maker', 'ai presentation'],
            'ai_report': ['create report', 'make report', 'generate report', 'ai report'],
            
            # Advanced Smart Home
            'smart_home_control': ['smart home', 'home automation', 'control home', 'home control'],
            'set_home_scene': ['home scene', 'set scene', 'activate scene', 'scene control'],
            'security_camera': ['security camera', 'camera snapshot', 'surveillance', 'camera view'],
            'energy_monitoring': ['energy monitor', 'power usage', 'energy report', 'power monitoring'],
            
            # Advanced Entertainment Plus
            'ai_dj_mode': ['dj mode', 'music dj', 'ai dj', 'music mix', 'dj assistant'],
            'trivia_game': ['trivia game', 'play trivia', 'quiz game', 'trivia quiz', 'knowledge game'],
            'storytelling': ['tell story', 'story mode', 'story time', 'create story', 'story generator'],
            'fitness_coach': ['fitness coach', 'workout coach', 'exercise guide', 'fitness help', 'workout assistant'],
            
            # Advanced AI Agents
            'code_agent': ['code agent', 'coding help', 'programming assistant', 'code help', 'coding assistant'],
            'debug_screen': ['debug screen', 'debug code', 'fix my code', 'check code', 'code debugging'],
            'research_agent': ['research agent', 'research help', 'research assistant', 'research support'],
            'organizer_agent': ['organizer agent', 'organize tasks', 'task organizer', 'task manager'],
            'multi_agent_collab': ['multi agent', 'agent collaboration', 'multiple agents', 'agent teamwork'],
            
            # Advanced Web Intelligence
            'scholar_search': ['scholar search', 'academic search', 'research papers', 'scholarly articles'],
            'stock_updates': ['stock updates', 'stock market', 'stock prices', 'market news', 'financial updates'],
            'crypto_updates': ['crypto updates', 'cryptocurrency', 'crypto prices', 'bitcoin', 'crypto market'],
            'realtime_translation': ['translate text', 'real time translation', 'language translate', 'translation service'],
            
            # Advanced Health & Wellness
            'posture_detection': ['posture check', 'check posture', 'posture analysis', 'posture monitoring'],
            'eye_care_mode': ['eye care', 'protect eyes', 'eye break', 'eye health', 'eye protection'],
            'daily_health_log': ['health log', 'track health', 'health diary', 'wellness log', 'health tracking'],
            'mood_tracker': ['mood tracker', 'track mood', 'mood log', 'how am i feeling', 'mood monitoring'],
            'meditation_prompt': ['meditation', 'meditate', 'mindfulness', 'relax', 'meditation guide'],
            'open_path': ['open file', 'open folder', 'open path', 'launch file', 'launch folder', 'run file', 'run folder', 'open documents', 'open downloads', 'open desktop', 'open pictures', 'open music', 'open videos', 'open docs', 'open pics', 'open vids', 'show me', 'find file', 'find folder', 'locate file', 'locate folder', 'access file', 'access folder', 'browse to', 'navigate to', 'go to file', 'go to folder'],

            
            # Advanced Security & Authentication
            'file_vault_encrypt': ['encrypt file', 'secure file', 'protect file', 'file encryption'],
            'file_vault_decrypt': ['decrypt file', 'unlock file', 'unsecure file', 'file decryption'],
            'anomaly_detection': ['scan for threats', 'security scan', 'system scan', 'threat detection'],
            'phishing_scan': ['phishing scan', 'check link', 'scan url', 'link safety', 'url security'],
            'parental_control': ['parental control', 'child safety', 'family safety', 'content filtering'],
            
            # Advanced Learning & Adaptation
            'adaptive_learning': ['adaptive learning', 'learn from me', 'adapt to me', 'machine learning'],
            'check_proactive': ['check proactive', 'proactive suggestions', 'smart suggestions', 'ai suggestions'],
            'enable_proactive_mode': ['enable proactive', 'turn on suggestions', 'proactive mode on', 'smart mode on'],
            'disable_proactive_mode': ['disable proactive', 'turn off suggestions', 'proactive mode off', 'smart mode off'],
            'manual_learn': ['manual learn', 'teach jarvis', 'teach you', 'learn this', 'training mode'],
            'predictive_assistance': ['predictive help', 'smart suggestions', 'predict actions', 'ai predictions'],
            
            # Advanced Docker & Development
            'docker_control': ['docker control', 'docker help', 'container management', 'docker commands'],
            
            # Google Search
            'search_google': ['search google', 'google search', 'search on google', 'google it', 'search web'],
            'search_images': ['search images', 'image search', 'sehiiiiiiiarch for images', 'find images'],
            'search_gifs': ['search gifs', 'gif search', 'search for gifs', 'find gifs'],
            'copy_webpage_link': ['copy link', 'copy webpage link', 'copy url', 'copy page link'],
            'translate_webpage': ['translate page', 'translate webpage', 'translate this page', 'page translate'],
            'weekday': ['weekday', 'what day', 'current day', 'today day', 'day of week'],
            'traffic_updates': ['traffic updates', 'traffic conditions', 'traffic info', 'check traffic', 'traffic status'],
            'public_holidays': ['public holidays', 'holidays today', 'holiday check', 'is today holiday', 'holiday status'],
            'covid_stats': ['covid stats', 'covid updates', 'coronavirus stats', 'covid cases', 'covid data'],
            
            # Product Price Tracking
            'track_amazon_price': ['track amazon price', 'amazon price track', 'check amazon price', 'amazon price check', 'track price on amazon', 'price track amazon', 'track price of', 'amazon track price'],
            'track_flipkart_price': ['track flipkart price', 'flipkart price track', 'check flipkart price', 'flipkart price check', 'track price on flipkart', 'price track flipkart', 'flipkart track price'],
            'check_product_price': ['check product price', 'compare price', 'price comparison', 'product price', 'check price', 'price check'],
            
            # Travel Search
            'search_flights': ['search flights', 'find flights', 'book flights', 'flight search', 'flight booking', 'flights from', 'flights to'],
            'search_hotels': ['search hotels', 'find hotels', 'book hotels', 'hotel search', 'hotel booking', 'hotels in', 'hotels at'],
            
            # Streaming Search
            'find_movie_streaming': ['find movie streaming', 'where to watch movie', 'movie streaming', 'watch movie online'],
            'find_show_streaming': ['find show streaming', 'where to watch show', 'show streaming', 'watch show online'],
            'where_to_watch': ['where to watch', 'streaming availability', 'find streaming', 'watch online'],
            'streaming_availability': ['streaming availability', 'available on streaming', 'streaming platforms', 'watch platforms'],
            
            # Debug price tracking functions
            'track_amazon_price_debug': ['track amazon price debug', 'debug amazon price', 'amazon price debug'],
            'track_flipkart_price_debug': ['track flipkart price debug', 'debug flipkart price', 'flipkart price debug'],
            'check_product_price_debug': ['check product price debug', 'debug product price', 'price debug'],
            
            # File Sorting
            'sort_files': ['sort files', 'sort by date', 'sort by time', 'sort by name', 'sort by size', 'arrange files', 'organize files', 'arrange files by size', 'arrange files by date', 'arrange files by name', 'sort files by size', 'sort files by date', 'sort files by name']
                      
        }
        
        # Check for exact phrase matches first
        for func_name, phrases in mappings.items():
            for phrase in phrases:
                if phrase in query:
                    return func_name
        
        # Check for partial matches with higher priority functions
        priority_functions = [
            # 'system_monitor_live', 'auto_fix_system', 'code_agent', 'research_agent',
            'ai_presentation', 'smart_home_control', 'posture_detection', 'eye_care_mode',
            'meditation_prompt', 'trivia_game', 'storytelling', 'fitness_coach'
        ]
        
        for func_name in priority_functions:
            if func_name in mappings:
                for phrase in mappings[func_name]:
                    # Check for partial matches
                    phrase_words = phrase.split()
                    query_words = query.split()
                    if len(phrase_words) > 1 and any(word in query for word in phrase_words):
                        # Check if at least 2 words match for multi-word phrases
                        matches = sum(1 for word in phrase_words if word in query)
                        if matches >= min(2, len(phrase_words)):
                            return func_name
        
        return None
    
    def _fuzzy_match_command(self, query):
        """Fuzzy matching using existing natural speech mappings"""
        return self.understand_natural_speech(query)
    
    
    def execute_multiple_commands(self, commands):
        """Execute multiple commands sequentially"""
        results = []
        for i, command in enumerate(commands):
            try:
                result = self.execute(command.strip())
                results.append(f"Command {i+1}: {result}")
                # Small delay between commands for better execution
                if i < len(commands) - 1:
                    time.sleep(0.3)
            except Exception as e:
                results.append(f"Command {i+1} failed: {str(e)}")
        
        return " | ".join(results)
    
    def _is_question(self, query):
        question_words = ['who', 'what', 'when', 'where', 'why', 'how']
        return any(word in query.lower() for word in question_words) or query.strip().endswith('?')
    
    def get_ai_response(self, prompt):
        """Get AI response for function mapping with fallback mechanism"""
        try:
            if self.ai_provider == 'groq':
                # Get appropriate model based on token usage
                model = self._get_groq_model()
                
                response = self.groq_client.chat.completions.create(
                    messages=[{"role": "user", "content": prompt}],
                    model=model,
                    max_tokens=50
                )
                
                # Track token usage (approximate)
                self.token_count += len(prompt.split()) + len(response.choices[0].message.content.split())
                
                return response.choices[0].message.content.strip()
            else:
                response = self.gemini_model.generate_content(prompt)
                return response.text.strip()
                
        except Exception as e:
            print(f"AI response error: {e}")
            # If 8B model fails due to rate limit, try 70B model
            if self.ai_provider == 'groq' and 'rate limit' in str(e).lower():
                try:
                    print("Trying fallback to 70B model...")
                    response = self.groq_client.chat.completions.create(
                        messages=[{"role": "user", "content": prompt}],
                        model=self.fallback_model,
                        max_tokens=50
                    )
                    return response.choices[0].message.content.strip()
                except:
                    pass
            return None
    
    def _answer_question(self, query):
        try:
            # Check stored memories first for any personal questions
            if any(word in query.lower() for word in ['my ', 'what is my', 'who am i', 'do you remember', 'what do you know about me']):
                try:
                    from engine.voice_advanced_ai import voice_advanced_ai
                    memories = voice_advanced_ai.context_memory_recall()
                    
                    # Search through all stored memories
                    for key in memories.keys():
                        memory_data = voice_advanced_ai._memory_get_all(key)
                        if memory_data:
                            data_str = str(memory_data[0]).lower()
                            query_words = query.lower().split()
                            
                            # Check if any words from the query match the stored data
                            for word in query_words:
                                if len(word) > 2 and word in data_str:  # Skip short words
                                    return f"Based on what you told me: {memory_data[0]}"
                            
                            # Specific pattern matching
                            if 'name' in query.lower() and 'name is' in data_str:
                                name_part = str(memory_data[0]).split('name is')[-1].strip()
                                return f"Your name is {name_part}"
                            elif any(word in query.lower() for word in ['color', 'colour']) and 'color is' in data_str:
                                color_part = str(memory_data[0]).split('color is')[-1].strip()
                                return f"Your favorite color is {color_part}"
                            elif 'age' in query.lower() and 'age is' in data_str:
                                age_part = str(memory_data[0]).split('age is')[-1].strip()
                                return f"Your age is {age_part}"
                            elif 'live' in query.lower() and 'live in' in data_str:
                                location_part = str(memory_data[0]).split('live in')[-1].strip()
                                return f"You live in {location_part}"
                except:
                    pass
            
            prompt = f'You are Jarvis. Answer briefly: "{query}"'
            
            if self.ai_provider == 'groq':
                # Get appropriate model based on token usage
                model = self._get_groq_model()
                
                try:
                    response = self.groq_client.chat.completions.create(
                        messages=[{"role": "user", "content": prompt}],
                        model=model
                    )
                    
                    # Track token usage (approximate)
                    self.token_count += len(prompt.split()) + len(response.choices[0].message.content.split())
                    
                    return response.choices[0].message.content.strip()
                    
                except Exception as e:
                    # If rate limit reached, try fallback model
                    if 'rate limit' in str(e).lower() or self.token_count >= self.token_limit:
                        print(f"Switching to {self.fallback_model} due to rate limit")
                        try:
                            response = self.groq_client.chat.completions.create(
                                messages=[{"role": "user", "content": prompt}],
                                model=self.fallback_model
                            )
                            return response.choices[0].message.content.strip()
                        except:
                            return "I'm having trouble answering that."
                    raise e

            else:
                response = self.gemini_model.generate_content(prompt)
                return response.text.strip()
        except:
            return "I'm having trouble answering that."
    
    def _get_response(self, func, result):
        responses = {
            'shutdown': "Shutting down computer in 5 seconds.",
            'restart': "Restarting computer in 5 seconds.",
            'sleep': "Computer going to sleep.",
            'lock': "Screen locked.",
            'hibernate': "Computer hibernating.",
            'calculator': "Calculator opened.",
            'notepad': "Notepad opened.",
            'chrome': "Chrome opened.",
            'edge': "Edge opened.",
            'explorer': "File Explorer opened.",
            'settings': "Windows Settings opened.",
            'taskmanager': "Task Manager opened.",
            'cmd': "Command Prompt opened.",
            'paint': "Paint opened.",
            'firefox': "Firefox opened.",
            'word': "Microsoft Word opened.",
            'excel': "Microsoft Excel opened.",
            'powerpoint': "PowerPoint opened.",
            'vlc': "VLC Media Player opened.",
            'vscode': "VS Code opened.",
            'spotify': "Spotify opened.",
            'steam': "Steam opened.",
            'google': "Google opened.",
            'youtube': "YouTube opened.",
            'wikipedia': "Wikipedia opened.",
            'stackoverflow': "Stack Overflow opened.",
            'github': "GitHub opened.",
            'amazon': "Amazon opened.",
            'flipkart': "Flipkart opened.",
            'instagram': "Instagram opened.",
            'facebook': "Facebook opened.",
            'twitter': "Twitter opened.",
            'linkedin': "LinkedIn opened.",
            'whatsapp_web': "WhatsApp Web opened.",
            'gmail': "Gmail opened.",
            'netflix': "Netflix opened.",
            'volume_up': "Volume increased.",
            'volume_down': "Volume decreased.",
            'mute': "Audio muted.",
            'screenshot': "Screenshot saved.",
            'desktop': "Desktop shown.",
            'minimize_all': "All windows minimized.",
            'brightness_up': "Brightness increased.",
            'brightness_down': "Brightness decreased.",
            'set_volume_60': "Volume set to 60%.",
            'volume_60': "Volume set to 60%.",
            'set_brightness_60': "Brightness set to 60%.",
            'brightness_60': "Brightness set to 60%.",
            'alt_tab': "Switched windows.",
            'copy': "Text copied.",
            'paste': "Text pasted.",
            'save': "File saved.",
            'undo': "Action undone.",
            'select_all': "All selected.",
            'close_chrome': "Chrome closed.",
            'close_edge': "Edge closed.",
            'close_notepad': "Notepad closed.",
            'downloads': "Downloads folder opened.",
            'documents': "Documents folder opened.",
            'pictures': "Pictures folder opened.",
            'cpu': f"CPU usage: {result}%",
            'memory': f"Memory usage: {result}%",
            'battery': f"Battery: {result}%" if result else "No battery detected",
            'time': f"Current time: {result}",
            'date': f"Today is {result}",
            'switch_to_gemini': "Switched to Gemini AI.",
            'switch_to_groq': "Switched to Groq AI.",
            'current_ai': f"Currently using {self.ai_provider.title()} AI.",
            'enable_face_auth': "Face recognition enabled.",
            'disable_face_auth': "Face recognition disabled.",
            'face_auth_status': "Face recognition status checked.",
            'switch_to_male_voice': "Voice switched to male.",
            'switch_to_female_voice': "Voice switched to female.",
            'male_voice': "Voice switched to male.",
            'female_voice': "Voice switched to female.",
            'current_voice_gender': "Voice gender status checked.",
            'voice_status': "Voice gender status checked.",
            
            # Advanced Features Responses
            'create_folder': "Folder created.",
            'create_new_file': "File created successfully.",
            'delete_file': "File deleted.",
            'search_files': "File search completed.",
            'copy_file': "File copied successfully.",
            'move_file': "File moved.",
            'check_internet': "Internet connection checked.",
            'ip_address': "IP address retrieved.",
            'wifi_password': "WiFi information retrieved.",
            'network_speed': "Network speed tested.",
            'disk_space': "Disk space checked.",
            'running_processes': "Process list retrieved.",
            'system_uptime': "System uptime checked.",
            'temperature': "System temperature checked.",
            'play_pause': "Media play/pause toggled.",
            'next_track': "Next track.",
            'previous_track': "Previous track.",
            'stop_media': "Media stopped.",
            'maximize_window': "Window maximized.",
            'minimize_window': "Window minimized.",
            'split_screen_left': "Screen split left.",
            'split_screen_right': "Screen split right.",
            'close_window': "Window closed.",
            'switch_window': "Window switched.",
            'find_text': "Find dialog opened.",
            'replace_text': "Replace dialog opened.",
            'new_document': "New document created.",
            'print_document': "Print dialog opened.",
            'zoom_in': "Zoomed in.",
            'zoom_out': "Zoomed out.",
            'clear_clipboard': "Clipboard cleared.",
            'clear_history': "Browser history cleared.",
            'empty_recycle_bin': "Recycle bin emptied.",
            'lock_screen': "Screen locked.",
        
            'schedule_shutdown': "Shutdown scheduled.",
            'auto_backup': "Backup completed.",
            'clean_temp': "Temporary files cleaned.",
            'play_music': "Music started.",
            'random_wallpaper': "Wallpaper changed.",
   
            'news': "News opened.",
            'quote': "Here's an inspirational quote.",
            
            # YouTube Automation Responses
            'youtube_play': "YouTube video play/paused.",
            'youtube_pause': "YouTube video paused.",
            'youtube_next': "Next YouTube video.",
            'youtube_previous': "Previous YouTube video.",
            'youtube_fullscreen': "YouTube fullscreen toggled.",
            'youtube_volume_up': "YouTube volume increased.",
            'youtube_volume_down': "YouTube volume decreased.",
            'youtube_mute': "YouTube muted/unmuted.",
            'youtube_speed_up': "YouTube speed increased.",
            'youtube_speed_down': "YouTube speed decreased.",
            'youtube_skip_forward': "YouTube skipped forward.",
            'youtube_skip_backward': "YouTube skipped backward.",
            'youtube_search': "YouTube search activated.",
            'youtube_subscribe': "YouTube subscribe clicked.",
            'youtube_like': "YouTube like clicked.",
            'youtube_dislike': "YouTube dislike clicked.",
            'youtube_comment': "YouTube comment box activated.",
            'youtube_share': "YouTube share clicked.",
            'youtube_theater_mode': "YouTube theater mode toggled.",
            'youtube_miniplayer': "YouTube miniplayer toggled.",
            'youtube_captions': "YouTube captions toggled.",
            'play_video': "Video search and play completed.",
            'play_movie': "Movie search and play completed.",
            'play_song': "Song search and play completed.",
            'search_and_play': "Search and play completed.",
            'open_multiple': "Multiple apps/websites opened.",
            
            # Chrome Automation Responses
            'chrome_new_tab': "New Chrome tab opened.",
            'chrome_close_tab': "Chrome tab closed.",
            'chrome_next_tab': "Switched to next Chrome tab.",
            'chrome_previous_tab': "Switched to previous Chrome tab.",
            'chrome_reload': "Chrome page reloaded.",
            'chrome_back': "Chrome navigated back.",
            'chrome_forward': "Chrome navigated forward.",
            'chrome_home': "Chrome home page opened.",
            'chrome_bookmark': "Chrome bookmark added.",
            'chrome_history': "Chrome history opened.",
            'chrome_downloads': "Chrome downloads opened.",
            'chrome_incognito': "Chrome incognito window opened.",
            'chrome_developer_tools': "Chrome developer tools toggled.",
            'chrome_zoom_in': "Chrome zoomed in.",
            'chrome_zoom_out': "Chrome zoomed out.",
            'chrome_zoom_reset': "Chrome zoom reset.",
            'chrome_find': "Chrome find dialog opened.",
            'chrome_print': "Chrome print dialog opened.",
            'chrome_save_page': "Chrome page saved.",
            'chrome_view_source': "Chrome page source opened.",
            'chrome_extensions': "Chrome extensions opened.",
            'chrome_settings': "Chrome settings opened.",
            'chrome_clear_data': "Chrome clear data dialog opened.",
            
            # Mapping Responses
            'open_maps': "Google Maps opened.",
            'find_location': "Location search opened.",
            'get_directions': "Directions opened.",
            'nearby_places': "Nearby places search opened.",
            'traffic_info': "Traffic information displayed.",
            'map_satellite': "Satellite view activated.",
            'map_terrain': "Terrain view activated.",
            'save_location': "Location saved.",
            'my_location': "Current location displayed.",
            'dictate_to_file': "Dictation to file completed.",
            'dictate_to_document': "Document dictation completed.",
            
            # System Monitoring Responses
            # 'system_monitor_live': "System monitoring dashboard displayed.",
            'auto_fix_system': "System auto-fix completed.",
            
            # Gesture Control Responses
            'start_gesture_control': "Hand, eye, and head control started.",
            'stop_gesture_control': "Gesture control stopped.",
            
            # Continuous Listening Responses
            'start_continuous_listen': "Continuous listening started.",
            'stop_continuous_listen': "Continuous listening stopped.",
            'continuous_listen_status': "Continuous listening status checked.",
            'weekday': "Current weekday retrieved.",
            'current_weekday': "Current weekday retrieved.",
            'traffic_updates': "Traffic information retrieved.",
            'public_holidays': "Holiday information retrieved.",
            'covid_stats': "COVID-19 statistics retrieved.",
            
            # Product Price Tracking Responses
            'track_amazon_price': "Amazon price tracking opened.",
            'track_flipkart_price': "Flipkart price tracking opened.",
            'check_product_price': "Product price comparison opened.",
            
            # Travel Search Responses
            'search_flights': "Flight search opened.",
            'search_hotels': "Hotel search opened.",
            'find_flights': "Flight search opened.",
            'find_hotels': "Hotel search opened.",
            
            # Streaming Search Responses
            'find_movie_streaming': "Movie streaming search opened.",
            'find_show_streaming': "Show streaming search opened.",
            'where_to_watch': "Streaming availability search opened.",
            'streaming_availability': "Streaming platforms search opened.",
            
            # File/Folder Opening Response
            'open_path': "File or folder opened.",
            
            # Alarm Responses
            'set_alarm': "Alarm set successfully.",
            'cancel_alarm': "Alarm cancelled.",
            
            # Random Generator Responses
            'dice': f" Dice rolled: {result}",
            'coin': f" Coin flip: {result}",
            'roll_dice': f" Dice rolled: {result}",
            'flip_coin': f" Coin flip: {result}",
        }
        
     
        
        # Get base response
        base_response = responses.get(func, "Task completed.")
        
        # Apply personality transformation safely
        if self.personality_manager:
            try:
                transformed = self.personality_manager.transform_response(base_response, 'success')
                if transformed and transformed.strip():
                    return transformed
            except:
                pass
        
        return base_response
    
    def _switch_to_gemini(self):
        return "gemini" if self._set_ai_provider('gemini') else "error"
    
    def _switch_to_groq(self):
        return "groq" if self._set_ai_provider('groq') else "error"
    
    def _get_current_ai(self):
        return self.ai_provider
    
    def _switch_to_hindi(self):
        if self.multilingual and self.multilingual.set_language('hindi'):
            # Reload the multilingual instance
            from engine.multilingual_support import reload_multilingual
            reload_multilingual()
            self.multilingual = multilingual
            return "‡§≠‡§æ‡§∑‡§æ ‡§π‡§ø‡§Ç‡§¶‡•Ä ‡§Æ‡•á‡§Ç ‡§¨‡§¶‡§≤ ‡§ó‡§à‡•§"
        return "Language switched to Hindi."
    
    def _switch_to_kannada(self):
        if self.multilingual and self.multilingual.set_language('kannada'):
            # Reload the multilingual instance
            from engine.multilingual_support import reload_multilingual
            reload_multilingual()
            self.multilingual = multilingual
            return "‡≤≠‡≤æ‡≤∑‡≥Ü‡≤Ø‡≤®‡≥ç‡≤®‡≥Å ‡≤ï‡≤®‡≥ç‡≤®‡≤°‡≤ï‡≥ç‡≤ï‡≥Ü ‡≤¨‡≤¶‡≤≤‡≤æ‡≤Ø‡≤ø‡≤∏‡≤≤‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü‡•§"
        return "Language switched to Kannada."
    
    def _switch_to_english(self):
        if self.multilingual and self.multilingual.set_language('english'):
            # Reload the multilingual instance
            from engine.multilingual_support import reload_multilingual
            reload_multilingual()
            self.multilingual = multilingual
            return "Language switched to English."
        return "Language switched to English."
    
    def _enable_face_auth(self):
        try:
            from engine.face_auth_config import set_face_auth_status
            set_face_auth_status(True)
            return "enabled"
        except:
            return "error"
    
    def _disable_face_auth(self):
        try:
            from engine.face_auth_config import set_face_auth_status
            set_face_auth_status(False)
            return "disabled"
        except:
            return "error"
    
    def _get_face_auth_status(self):
        try:
            from engine.face_auth_config import get_face_auth_status
            return "enabled" if get_face_auth_status() else "disabled"
        except:
            return "error"
    
    def _set_volume(self, level):
        try:
            level = max(0, min(100, level))
            subprocess.run(f'powershell -c "$obj = new-object -com wscript.shell; $obj.SendKeys([char]173); for($i=0; $i -lt 50; $i++){{$obj.SendKeys([char]174)}}; for($i=0; $i -lt {level//2}; $i++){{$obj.SendKeys([char]175)}}"', shell=True)
            return str(level)
        except:
            return "error"
    
    def _set_brightness(self, level):
        try:
            level = max(0, min(100, level))
            subprocess.run(f'powershell -c "(Get-WmiObject -Namespace root/WMI -Class WmiMonitorBrightnessMethods).WmiSetBrightness(1,{level})"', shell=True)
            return str(level)
        except:
            return "error"
    
    def _handle_on_off(self, feature, action):
        """Handle dynamic on/off commands for any feature"""
        try:
            feature = feature.lower().strip()
            
            # WiFi - Quick toggle via Action Center
            if 'wifi' in feature or 'wi-fi' in feature:
                pyautogui.hotkey('win', 'a')  # Open Action Center
                pyautogui.sleep(0.5)
                pyautogui.press('space')  # Click WiFi tile
                pyautogui.press('escape')  # Close Action Center
                return f"WiFi toggled"
            
            # Bluetooth - Quick toggle via Action Center
            elif 'bluetooth' in feature:
                pyautogui.hotkey('win', 'a')   # Open Quick Settings
                time.sleep(0.5)
                # Sometimes focus is not on first tile, so ensure keyboard focus lands
                pyautogui.press('right')   # Move focus to Bluetooth (if needed)
                time.sleep(0.2)
                pyautogui.press('space')      # Toggle Bluetooth (first tile focus)
                time.sleep(0.2)

                pyautogui.press('escape')
                return f"bluetooth toggled"
            
            # Airplane Mode - Admin control
            elif 'airplane' in feature or 'flight' in feature:
                pyautogui.hotkey('win', 'a')   # Open Quick Settings
                time.sleep(0.5)
                # Sometimes focus is not on first tile, so ensure keyboard focus lands
                pyautogui.press('right')   # Move focus to Bluetooth (if needed)
                time.sleep(0.1)
                pyautogui.press('right')
                time.sleep(0.1) 
                pyautogui.press('space')      # Toggle Bluetooth (first tile focus)
                time.sleep(0.2)

                pyautogui.press('escape')
                return f"airplane toggled"
            
            elif 'battery saver' in feature or 'energy saver' in feature or 'save battery' in feature:
                    pyautogui.hotkey('win', 'a')   # Open Quick Settings
                    time.sleep(0.5)

                    pyautogui.press('down')        # Move to Battery Saver tile
                    time.sleep(0.1)

                    pyautogui.press('space')       # Toggle Battery Saver
                    time.sleep(0.2)

                    pyautogui.press('escape')      # Close panel
                    return "Battery Saver toggled"

            elif 'night' in feature or 'night mode' in feature or 'night light' in feature:
                pyautogui.hotkey('win', 'a')   # Open Quick Settings
                time.sleep(0.5)
                pyautogui.press('down')        # Move to the second row
                time.sleep(0.1)
                pyautogui.press('right')       # Move to Night Mode tile
                time.sleep(0.1)
                pyautogui.press('space')       # Toggle Night Mode
                time.sleep(0.2)
                pyautogui.press('escape')      # Close Quick Settings
                return "Night Mode toggled"

            elif 'hotspot' in feature or 'mobile hotspot' in feature or 'wi-fi hotspot' in feature:
                pyautogui.hotkey('win', 'a')   # Open Quick Settings
                time.sleep(0.5)
                pyautogui.press('down')        # Move to 2nd row
                time.sleep(0.1)
                pyautogui.press('down')        # Move to 3rd row (Hotspot row)
                time.sleep(0.1)
                pyautogui.press('right')       # Move to Hotspot tile
                time.sleep(0.1)
                pyautogui.press('space')       # Toggle Hotspot
                time.sleep(0.2)
                pyautogui.press('escape')      # Close Quick Settings
                return "Hotspot toggled"

            elif 'nearby' in feature or 'nearby share' in feature or 'share nearby' in feature:
                pyautogui.hotkey('win', 'a')   # Open Quick Settings
                time.sleep(0.5)
                pyautogui.press('down')        # Move to 2nd row
                time.sleep(0.1)
                pyautogui.press('down')        # Move to 3rd row
                time.sleep(0.1)
                pyautogui.press('right')       # Move to next tile
                time.sleep(0.1)
                pyautogui.press('right')       # Move to Nearby Share tile
                time.sleep(0.1)
                pyautogui.press('space')       # Toggle Nearby Share
                time.sleep(0.2)
                pyautogui.press('escape')      # Close Quick Settings
                return "Nearby Share toggled"

            
            # Location - Admin control
            elif 'location' in feature or 'gps' in feature:
                # Open Location Settings Page
                subprocess.Popen('start ms-settings:privacy-location', shell=True)
                time.sleep(1.8)  # wait for settings to open
              
                pyautogui.press('space')
                time.sleep(0.2)
               

                return "Location toggled"


            # Camera - Admin control
            elif 'camera' in feature:
                if action == 'on':
                    subprocess.run('powershell -c "Start-Process powershell -ArgumentList \'Set-ItemProperty -Path HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\CapabilityAccessManager\\ConsentStore\\webcam -Name Value -Value Allow\' -Verb RunAs"', shell=True)
                else:
                    subprocess.run('powershell -c "Start-Process powershell -ArgumentList \'Set-ItemProperty -Path HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\CapabilityAccessManager\\ConsentStore\\webcam -Name Value -Value Deny\' -Verb RunAs"', shell=True)
                return f"Camera {action}"
            
            # Microphone - Admin control
            elif 'microphone' in feature or 'mic' in feature:
                if action == 'on':
                    subprocess.run('powershell -c "Start-Process powershell -ArgumentList \'Set-ItemProperty -Path HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\CapabilityAccessManager\\ConsentStore\\microphone -Name Value -Value Allow\' -Verb RunAs"', shell=True)
                else:
                    subprocess.run('powershell -c "Start-Process powershell -ArgumentList \'Set-ItemProperty -Path HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\CapabilityAccessManager\\ConsentStore\\microphone -Name Value -Value Deny\' -Verb RunAs"', shell=True)
                return f"Microphone {action}"
            
            # Dark Mode
            elif 'dark mode' in feature or 'dark theme' in feature:
                if action == 'on':
                    subprocess.run('powershell -c "Set-ItemProperty -Path HKCU:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize -Name AppsUseLightTheme -Value 0"', shell=True)
                else:
                    subprocess.run('powershell -c "Set-ItemProperty -Path HKCU:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize -Name AppsUseLightTheme -Value 1"', shell=True)
                return f"Dark mode {action}"
  
            

                
        except Exception as e:
            return f"Error controlling {feature}: {str(e)}"
    

    
    # ===== ALL ADVANCED FEATURES METHODS =====
    
    # Voice Mouse Control
    def _move_mouse_up(self, pixels=50):
        try:
            x, y = pyautogui.position()
            pyautogui.moveTo(x, max(0, y - pixels))
            return f"Mouse moved up {pixels} pixels"
        except:
            return "Mouse movement failed"
    
    def _move_mouse_down(self, pixels=50):
        try:
            x, y = pyautogui.position()
            screen_height = pyautogui.size().height
            pyautogui.moveTo(x, min(screen_height, y + pixels))
            return f"Mouse moved down {pixels} pixels"
        except:
            return "Mouse movement failed"
    
    def _move_mouse_left(self, pixels=50):
        try:
            x, y = pyautogui.position()
            pyautogui.moveTo(max(0, x - pixels), y)
            return f"Mouse moved left {pixels} pixels"
        except:
            return "Mouse movement failed"
    
    def _move_mouse_right(self, pixels=50):
        try:
            x, y = pyautogui.position()
            screen_width = pyautogui.size().width
            pyautogui.moveTo(min(screen_width, x + pixels), y)
            return f"Mouse moved right {pixels} pixels"
        except:
            return "Mouse movement failed"
    
    def _move_mouse_center(self):
        try:
            screen_width, screen_height = pyautogui.size()
            pyautogui.moveTo(screen_width // 2, screen_height // 2)
            return "Mouse moved to center"
        except:
            return "Mouse movement failed"
    
    def _left_click(self):
        try:
            pyautogui.click()
            return "Left click performed"
        except:
            return "Click failed"
    
    def _right_click(self):
        try:
            pyautogui.rightClick()
            return "Right click performed"
        except:
            return "Right click failed"
    
    def _double_click(self):
        try:
            pyautogui.doubleClick()
            return "Double click performed"
        except:
            return "Double click failed"
    
    def _start_drag(self):
        try:
            pyautogui.mouseDown()
            return "Drag started"
        except:
            return "Drag start failed"
    
    def _drop_here(self):
        try:
            pyautogui.mouseUp()
            return "Drop completed"
        except:
            return "Drop failed"
    


    def _scroll_up(self, clicks=5):
        try:
            for _ in range(clicks):
                ctypes.windll.user32.mouse_event(0x0800, 0, 0, 120, 0)
            return f"Scrolled up {clicks}"
        except:
            return "Scroll failed"

    def _scroll_down(self, clicks=5):
        try:
            for _ in range(clicks):
                ctypes.windll.user32.mouse_event(0x0800, 0, 0, -120, 0)
            return f"Scrolled down {clicks}"
        except:
            return "Scroll failed"

    def _scroll_to_top(self):
        try:
            pyautogui.hotkey('ctrl', 'home')
            return "Scrolled to top"
        except:
            return "Scroll to top failed"
    
    # Voice Keyboard Control
    def _type_text(self, text=""):
        try:
            pyautogui.typewrite(text)
            return f"Typed: {text}"
        except:
            return "Text typing failed"
    
    def _press_enter(self):
        try:
            pyautogui.press('enter')
            return "Enter key pressed"
        except:
            return "Enter key failed"
    
    def _press_tab(self):
        try:
            pyautogui.press('tab')
            return "Tab key pressed"
        except:
            return "Tab key failed"
    
    def _press_escape(self):
        try:
            pyautogui.press('escape')
            return "Escape key pressed"
        except:
            return "Escape key failed"
    
    def _press_backspace(self):
        try:
            pyautogui.press('backspace')
            return "Backspace pressed"
        except:
            return "Backspace failed"
    
    def _press_delete(self):
        try:
            pyautogui.press('delete')
            return "Delete key pressed"
        except:
            return "Delete key failed"
    
    def _go_to_beginning(self):
        try:
            pyautogui.hotkey('ctrl', 'home')
            return "Moved to beginning"
        except:
            return "Go to beginning failed"
    
    def _go_to_end(self):
        try:
            pyautogui.hotkey('ctrl', 'end')
            return "Moved to end"
        except:
            return "Go to end failed"
    
    # File Operations
    def _create_folder(self, path="New Folder"):
        try:
            # Extract folder name and directory from query if provided
            if hasattr(self, '_current_query') and self._current_query:
                import re
                query = self._current_query.lower()
                
                # Extract folder name
                match = re.search(r'create folder\s+([^\s]+)', query)
                if match:
                    path = match.group(1)
                
                # Extract directory path
                target_dir = None
                dir_match = re.search(r'(?:on|in|to)\s+([^\s]+)', query)
                if dir_match:
                    dir_name = dir_match.group(1)
                    
                    # Common directory mappings
                    directory_map = {
                        'download': 'Downloads', 'downloads': 'Downloads', 'doenload': 'Downloads',
                        'document': 'Documents', 'documents': 'Documents',
                        'desktop': 'Desktop', 'picture': 'Pictures', 'pictures': 'Pictures',
                        'music': 'Music', 'video': 'Videos', 'videos': 'Videos'
                    }
                    
                    # Check if it's a known directory
                    if dir_name in directory_map:
                        target_dir = os.path.join(os.path.expanduser("~"), directory_map[dir_name])
                    else:
                        # Use as direct path
                        if os.path.isabs(dir_name):
                            target_dir = dir_name
                        else:
                            home_path = os.path.join(os.path.expanduser("~"), dir_name)
                            target_dir = home_path if os.path.exists(home_path) else os.path.abspath(dir_name)
                
                # Default to Desktop if no directory specified
                if not target_dir:
                    target_dir = os.path.join(os.path.expanduser("~"), "Desktop")
            else:
                target_dir = os.path.join(os.path.expanduser("~"), "Desktop")
            
            os.makedirs(target_dir, exist_ok=True)
            folder_path = os.path.join(target_dir, path)
            os.makedirs(folder_path, exist_ok=True)
            return f"Folder '{path}' created in {os.path.basename(target_dir)}"
        except Exception as e:
            return f"Failed to create folder: {str(e)}"
    
    def _create_new_file(self, filename="new_file.txt", content=""):
        try:
            # Extract filename and directory from query if provided
            if hasattr(self, '_current_query') and self._current_query:
                import re
                query = self._current_query.lower()
                
                # Extract filename
                match = re.search(r'create (?:new )?file\s+([^\s]+)', query)
                if match:
                    filename = match.group(1)
                    if '.' not in filename:
                        filename += '.txt'
                
                # Extract directory path
                target_dir = None
                dir_match = re.search(r'(?:on|in|to)\s+([^\s]+)', query)
                if dir_match:
                    dir_name = dir_match.group(1)
                    
                    # Common directory mappings
                    directory_map = {
                        'download': 'Downloads', 'downloads': 'Downloads', 'doenload': 'Downloads',
                        'document': 'Documents', 'documents': 'Documents',
                        'desktop': 'Desktop', 'picture': 'Pictures', 'pictures': 'Pictures',
                        'music': 'Music', 'video': 'Videos', 'videos': 'Videos'
                    }
                    
                    # Check if it's a known directory
                    if dir_name in directory_map:
                        target_dir = os.path.join(os.path.expanduser("~"), directory_map[dir_name])
                    else:
                        # Use as direct path
                        if os.path.isabs(dir_name):
                            target_dir = dir_name
                        else:
                            home_path = os.path.join(os.path.expanduser("~"), dir_name)
                            target_dir = home_path if os.path.exists(home_path) else os.path.abspath(dir_name)
                
                # Default to Desktop if no directory specified
                if not target_dir:
                    target_dir = os.path.join(os.path.expanduser("~"), "Desktop")
            else:
                target_dir = os.path.join(os.path.expanduser("~"), "Desktop")
            
            os.makedirs(target_dir, exist_ok=True)
            file_path = os.path.join(target_dir, filename)
            
            # Handle duplicates
            counter = 1
            original_path = file_path
            while os.path.exists(file_path):
                name, ext = os.path.splitext(original_path)
                file_path = f"{name}_{counter}{ext}"
                counter += 1
            
            # Create the file
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(content if content else "")
            
            return f"File '{os.path.basename(file_path)}' created at {file_path}"
            
        except Exception as e:
            return f"Error creating file: {str(e)}"
    
    def _delete_file(self, filename=""):
        try:
            # Extract filename and directory from query if provided
            if hasattr(self, '_current_query') and self._current_query:
                import re
                query = self._current_query.lower()
                
                # Extract filename
                match = re.search(r'delete file\s+([^\s]+)', query)
                if match:
                    filename = match.group(1)
                
                # Extract directory - support common directory names
                directory_map = {
                    'download': 'Downloads',
                    'downloads': 'Downloads', 
                    'doenload': 'Downloads',  # Handle typo
                    'document': 'Documents',
                    'documents': 'Documents',
                    'desktop': 'Desktop',
                    'picture': 'Pictures',
                    'pictures': 'Pictures',
                    'music': 'Music',
                    'video': 'Videos',
                    'videos': 'Videos'
                }
                
                target_dir = None
                for key, folder in directory_map.items():
                    if f'on {key}' in query or f'in {key}' in query or f'from {key}' in query:
                        target_dir = os.path.join(os.path.expanduser("~"), folder)
                        break
                
                # Default to Desktop if no directory specified
                if not target_dir:
                    target_dir = os.path.join(os.path.expanduser("~"), "Desktop")
            else:
                target_dir = os.path.join(os.path.expanduser("~"), "Desktop")
            
            file_path = os.path.join(target_dir, filename)
            if os.path.exists(file_path):
                os.remove(file_path)
                return f"File '{filename}' deleted from {os.path.basename(target_dir)}"
            return f"File '{filename}' not found in {os.path.basename(target_dir)}"
        except Exception as e:
            return f"Failed to delete file: {str(e)}"
    
    def _search_files(self, query=""):
        try:
            # Extract filename from query if provided
            if hasattr(self, '_current_query') and self._current_query:
                import re
                query_text = self._current_query.lower()
                
                # Extract filename from "search file filename" pattern
                match = re.search(r'search file\s+([^\s]+)', query_text)
                if match:
                    query = match.group(1)
            
            if not query:
                return "Please specify filename to search for"
            
            # Search in common directories
            search_dirs = [
                os.path.join(os.path.expanduser("~"), "Desktop"),
                os.path.join(os.path.expanduser("~"), "Downloads"),
                os.path.join(os.path.expanduser("~"), "Documents"),
                os.path.join(os.path.expanduser("~"), "Pictures"),
                os.path.join(os.path.expanduser("~"), "Videos"),
                os.path.join(os.path.expanduser("~"), "Music")
            ]
            
            matches = []
            for search_dir in search_dirs:
                if os.path.exists(search_dir):
                    for file in os.listdir(search_dir):
                        if query.lower() in file.lower():
                            matches.append(f"{file} (in {os.path.basename(search_dir)})")
            
            if matches:
                return f"Found {len(matches)} files: {', '.join(matches[:5])}{'...' if len(matches) > 5 else ''}"
            else:
                return f"No files found matching '{query}'"
        except Exception as e:
            return f"Error finding files: {str(e)}"
    
    def _copy_file(self, source="", destination=""):
        try:
            # Extract file copy details from query if provided
            if hasattr(self, '_current_query') and self._current_query:
                import re
                query = self._current_query.lower()
                
                # Parse "copy filename from_location to to_location" pattern
                copy_match = re.search(r'copy\s+([^\s]+)\s+([^\s]+)\s+to\s+([^\s]+)', query)
                if copy_match:
                    filename = copy_match.group(1)
                    from_location = copy_match.group(2)
                    to_location = copy_match.group(3)
                    
                    # Map common directory names
                    directory_map = {
                        'download': 'Downloads', 'downloads': 'Downloads',
                        'document': 'Documents', 'documents': 'Documents',
                        'desktop': 'Desktop', 'deckstop': 'Desktop',  # Handle typo
                        'picture': 'Pictures', 'pictures': 'Pictures',
                        'music': 'Music', 'video': 'Videos', 'videos': 'Videos'
                    }
                    
                    # Get source directory
                    if from_location in directory_map:
                        source_dir = os.path.join(os.path.expanduser("~"), directory_map[from_location])
                    else:
                        source_dir = os.path.join(os.path.expanduser("~"), "Desktop")
                    
                    # Get destination directory
                    if to_location in directory_map:
                        dest_dir = os.path.join(os.path.expanduser("~"), directory_map[to_location])
                    else:
                        dest_dir = os.path.join(os.path.expanduser("~"), "Downloads")
                    
                    source = os.path.join(source_dir, filename)
                    destination = os.path.join(dest_dir, filename)
                    
                    # Check if source file exists
                    if not os.path.exists(source):
                        return f"File '{filename}' not found in {os.path.basename(source_dir)}"
                    
                    # Create destination directory if it doesn't exist
                    os.makedirs(dest_dir, exist_ok=True)
                    
                    # Handle duplicate files
                    counter = 1
                    original_dest = destination
                    while os.path.exists(destination):
                        name, ext = os.path.splitext(original_dest)
                        destination = f"{name}_{counter}{ext}"
                        counter += 1
                    
                    # Copy the file
                    shutil.copy2(source, destination)
                    return f"File '{filename}' copied from {os.path.basename(source_dir)} to {os.path.basename(dest_dir)}"
            
            # Fallback to original parameters
            if source and destination:
                shutil.copy2(source, destination)
                return "File copied successfully"
            
            return "Please specify source and destination"
            
        except Exception as e:
            return f"Failed to copy file: {str(e)}"
    
    def _move_file(self, source="", destination=""):
        try:
            # Extract file move details from query if provided
            if hasattr(self, '_current_query') and self._current_query:
                import re
                query = self._current_query.lower()
                
                # Parse "move filename from_location to to_location" pattern
                move_match = re.search(r'move\s+([^\s]+)\s+(?:from\s+)?([^\s]+)\s+to\s+([^\s]+)', query)
                if move_match:
                    filename = move_match.group(1)
                    from_location = move_match.group(2)
                    to_location = move_match.group(3)
                    
                    # Map common directory names
                    directory_map = {
                        'download': 'Downloads', 'downloads': 'Downloads',
                        'document': 'Documents', 'documents': 'Documents',
                        'desktop': 'Desktop', 'deckstop': 'Desktop',  # Handle typo
                        'picture': 'Pictures', 'pictures': 'Pictures',
                        'music': 'Music', 'video': 'Videos', 'videos': 'Videos'
                    }
                    
                    # Get source directory
                    if from_location in directory_map:
                        source_dir = os.path.join(os.path.expanduser("~"), directory_map[from_location])
                    else:
                        source_dir = os.path.join(os.path.expanduser("~"), "Desktop")
                    
                    # Get destination directory
                    if to_location in directory_map:
                        dest_dir = os.path.join(os.path.expanduser("~"), directory_map[to_location])
                    else:
                        dest_dir = os.path.join(os.path.expanduser("~"), "Downloads")
                    
                    source = os.path.join(source_dir, filename)
                    destination = os.path.join(dest_dir, filename)
                    
                    # Check if source file exists
                    if not os.path.exists(source):
                        return f"File '{filename}' not found in {os.path.basename(source_dir)}"
                    
                    # Create destination directory if it doesn't exist
                    os.makedirs(dest_dir, exist_ok=True)
                    
                    # Handle duplicate files
                    counter = 1
                    original_dest = destination
                    while os.path.exists(destination):
                        name, ext = os.path.splitext(original_dest)
                        destination = f"{name}_{counter}{ext}"
                        counter += 1
                    
                    # Move the file
                    shutil.move(source, destination)
                    return f"File '{filename}' moved from {os.path.basename(source_dir)} to {os.path.basename(dest_dir)}"
            
            # Fallback to original parameters
            if source and destination:
                shutil.move(source, destination)
                return "File moved successfully"
            
            return "Please specify source and destination"
            
        except Exception as e:
            return f"Failed to move file: {str(e)}"
    
    def _rename_file_cmd(self):
        try:
            import re
            query = self._current_query.lower()
            match = re.search(r'rename\s+([^\s]+)\s+to\s+([^\s]+)(?:\s+in\s+([^\s]+))?', query)
            if match:
                old_name, new_name, location = match.groups()
                target_dir = self._get_directory(location) if location else os.path.join(os.path.expanduser("~"), "Desktop")
                old_path = os.path.join(target_dir, old_name)
                new_path = os.path.join(target_dir, new_name)
                if os.path.exists(old_path):
                    os.rename(old_path, new_path)
                    return f"Renamed '{old_name}' to '{new_name}' in {os.path.basename(target_dir)}"
                return f"File '{old_name}' not found in {os.path.basename(target_dir)}"
            return "Usage: rename oldname to newname [in folder]"
        except Exception as e:
            return f"Rename failed: {str(e)}"
    
    def _zip_file(self):
        try:
            import re
            query = self._current_query.lower()
            match = re.search(r'zip\s+(?:file\s+)?([^\s]+)(?:\s+in\s+([^\s]+))?', query)
            if match:
                filename, location = match.groups()
                target_dir = self._get_directory(location) if location else os.path.join(os.path.expanduser("~"), "Desktop")
                file_path = os.path.join(target_dir, filename)
                zip_path = file_path + '.zip'
                if os.path.exists(file_path):
                    with zipfile.ZipFile(zip_path, 'w') as zf:
                        zf.write(file_path, filename)
                    return f"Created {filename}.zip in {os.path.basename(target_dir)}"
                return f"File '{filename}' not found in {os.path.basename(target_dir)}"
            return "Usage: zip file filename [in folder]"
        except Exception as e:
            return f"Zip failed: {str(e)}"
    
    def _unzip_file(self):
        try:
            import re
            query = self._current_query.lower()
            match = re.search(r'(?:unzip|extract)\s+([^\s]+)(?:\s+in\s+([^\s]+))?', query)
            if match:
                filename, location = match.groups()
                if not filename.endswith('.zip'):
                    filename += '.zip'
                target_dir = self._get_directory(location) if location else os.path.join(os.path.expanduser("~"), "Desktop")
                zip_path = os.path.join(target_dir, filename)
                if os.path.exists(zip_path):
                    with zipfile.ZipFile(zip_path, 'r') as zf:
                        zf.extractall(target_dir)
                    return f"Extracted {filename} in {os.path.basename(target_dir)}"
                return f"Zip file '{filename}' not found in {os.path.basename(target_dir)}"
            return "Usage: unzip filename [in folder]"
        except Exception as e:
            return f"Unzip failed: {str(e)}"
    
    def _get_file_size(self):
        try:
            import re
            query = self._current_query.lower()
            match = re.search(r'(?:file\s+size|size\s+of)\s+([^\s]+)(?:\s+in\s+([^\s]+))?', query)
            if match:
                filename, location = match.groups()
                target_dir = self._get_directory(location) if location else os.path.join(os.path.expanduser("~"), "Desktop")
                file_path = os.path.join(target_dir, filename)
                if os.path.exists(file_path):
                    size = os.path.getsize(file_path)
                    if size < 1024:
                        return f"{filename}: {size} bytes"
                    elif size < 1024*1024:
                        return f"{filename}: {size/1024:.1f} KB"
                    else:
                        return f"{filename}: {size/(1024*1024):.1f} MB"
                return f"File '{filename}' not found in {os.path.basename(target_dir)}"
            return "Usage: file size filename [in folder]"
        except Exception as e:
            return f"Get file size failed: {str(e)}"
    
    def _list_files(self):
        try:
            import re
            query = self._current_query.lower()
            match = re.search(r'list\s+files(?:\s+in\s+([^\s]+))?', query)
            location = match.group(1) if match else None
            target_dir = self._get_directory(location) if location else os.path.join(os.path.expanduser("~"), "Desktop")
            files = [f for f in os.listdir(target_dir) if os.path.isfile(os.path.join(target_dir, f))]
            folders = [f for f in os.listdir(target_dir) if os.path.isdir(os.path.join(target_dir, f))]
            return f"{os.path.basename(target_dir)}: {len(files)} files, {len(folders)} folders. Recent: {', '.join(files[:3])}"
        except Exception as e:
            return f"List files failed: {str(e)}"
    
    def _get_directory(self, query_or_location):
        """Get directory path from query or location name"""
        if not query_or_location:
            return os.path.join(os.path.expanduser("~"), "Desktop")
        
        # If it's a query, extract directory from it
        if isinstance(query_or_location, str) and len(query_or_location) > 20:
            import re
            # Look for directory patterns in query
            dir_match = re.search(r'(?:in|on|from|to)\s+([^\s]+)', query_or_location.lower())
            if dir_match:
                location = dir_match.group(1)
            else:
                location = None
        else:
            location = query_or_location
        
        if not location:
            return os.path.join(os.path.expanduser("~"), "Desktop")
        
        directory_map = {
            'download': 'Downloads', 'downloads': 'Downloads',
            'document': 'Documents', 'documents': 'Documents',
            'desktop': 'Desktop', 'deckstop': 'Desktop',
            'picture': 'Pictures', 'pictures': 'Pictures',
            'music': 'Music', 'video': 'Videos', 'videos': 'Videos'
        }
        
        if location in directory_map:
            return os.path.join(os.path.expanduser("~"), directory_map[location])
        elif os.path.isabs(location):
            return location
        else:
            # Try as relative path from home directory
            home_path = os.path.join(os.path.expanduser("~"), location)
            if os.path.exists(home_path):
                return home_path
            # Fallback to Desktop
            return os.path.join(os.path.expanduser("~"), "Desktop")
    
    # Network & Internet
    def _ping_test(self):
        try:
            result = subprocess.run(['ping', '-n', '1', 'google.com'], 
                                  capture_output=True, text=True, timeout=5)
            return "Internet connected" if result.returncode == 0 else "No internet connection"
        except:
            return "Network check failed"
    
    def _get_ip(self):
        try:
            hostname = socket.gethostname()
            ip = socket.gethostbyname(hostname)
            return f"Your IP address is {ip}"
        except:
            return "Could not get IP address"
    
    def _get_wifi_password(self):
        try:
            result = subprocess.run(['netsh', 'wlan', 'show', 'profile'], 
                                  capture_output=True, text=True)
            profiles = [line.split(':')[1].strip() for line in result.stdout.split('\n') 
                       if 'All User Profile' in line]
            if profiles:
                return f"Found {len(profiles)} WiFi networks"
            return "No WiFi profiles found"
        except:
            return "Could not retrieve WiFi information"
    
    def _speed_test(self):
        try:
            response = requests.get('http://www.google.com', timeout=3)
            return f"Internet speed test completed in {response.elapsed.total_seconds():.2f} seconds"
        except:
            return "Speed test failed"
    
    # System Monitoring
    def _get_disk_space(self):
        try:
            disk = psutil.disk_usage('C:')
            free_gb = disk.free / (1024**3)
            total_gb = disk.total / (1024**3)
            return f"Disk space: {free_gb:.1f}GB free of {total_gb:.1f}GB total"
        except:
            return "Could not get disk space"
    
    def _list_processes(self):
        try:
            processes = len(psutil.pids())
            return f"Currently running {processes} processes"
        except:
            return "Could not get process information"
    
    def _get_uptime(self):
        try:
            boot_time = psutil.boot_time()
            uptime = time.time() - boot_time
            hours = int(uptime // 3600)
            minutes = int((uptime % 3600) // 60)
            return f"System uptime: {hours} hours, {minutes} minutes"
        except:
            return "Could not get uptime"
    
    def _get_cpu_temp(self):
        try:
            cpu_percent = psutil.cpu_percent(interval=1)
            return f"CPU usage: {cpu_percent}%"
        except:
            return "Could not get CPU information"
    
    # Entertainment
    def _tell_joke(self):
        jokes = [
            "Why don't scientists trust atoms? Because they make up everything!",
            "Why did the computer go to the doctor? Because it had a virus!",
            "Why don't programmers like nature? It has too many bugs!",
            "What do you call a computer that sings? A Dell!",
            "Why was the computer cold? It left its Windows open!"
        ]
        return random.choice(jokes)
    
    def _get_quote(self):
        quotes = [
            "The only way to do great work is to love what you do. - Steve Jobs",
            "Innovation distinguishes between a leader and a follower. - Steve Jobs",
            "Life is what happens to you while you're busy making other plans. - John Lennon",
            "The future belongs to those who believe in the beauty of their dreams. - Eleanor Roosevelt",
            "It is during our darkest moments that we must focus to see the light. - Aristotle"
        ]
        return random.choice(quotes)
    

    
    def _get_news(self):
        try:
            return "Opening news website for latest updates"
        except:
            return "Could not get news"
    
    # Placeholder methods for remaining features
    def _next_window(self):
        try:
            pyautogui.hotkey('alt', 'tab')
            return "Switched to next window"
        except:
            return "Window switch failed"
    
    def _previous_window(self):
        try:
            pyautogui.hotkey('alt', 'shift', 'tab')
            return "Switched to previous window"
        except:
            return "Window switch failed"
    
    def _close_all_windows(self):
        try:
            pyautogui.hotkey('win', 'd')
            return "All windows minimized"
        except:
            return "Minimize all failed"
    
    def _snap_left(self):
        try:
            pyautogui.hotkey('win', 'left')
            return "Window snapped left"
        except:
            return "Snap left failed"
    
    def _snap_right(self):
        try:
            pyautogui.hotkey('win', 'right')
            return "Window snapped right"
        except:
            return "Snap right failed"
    
    def _full_screen(self):
        try:
            pyautogui.press('f11')
            return "Full screen toggled"
        except:
            return "Full screen failed"
    
    def _restore_window(self):
        try:
            pyautogui.hotkey('win', 'up')
            return "Window restored"
        except:
            return "Window restore failed"
    
    def _open_recent_file(self):
        try:
            pyautogui.hotkey('ctrl', 'o')
            return "Recent file dialog opened"
        except:
            return "Open file failed"
    
    def _rename_file(self):
        try:
            pyautogui.press('f2')
            return "File rename activated"
        except:
            return "Rename failed"
    
    def _duplicate_file(self):
        try:
            pyautogui.hotkey('ctrl', 'c')
            pyautogui.hotkey('ctrl', 'v')
            return "File duplicated"
        except:
            return "Duplicate failed"
    
    def _compress_file(self):
        try:
            pyautogui.rightClick()
            time.sleep(0.5)
            pyautogui.typewrite('compress')
            return "File compression started"
        except:
            return "Compression failed"
    
    def _extract_archive(self):
        try:
            pyautogui.rightClick()
            time.sleep(0.5)
            pyautogui.typewrite('extract')
            return "Archive extraction started"
        except:
            return "Extraction failed"
    
    def _open_new_tab(self):
        try:
            pyautogui.hotkey('ctrl', 't')
            return "New tab opened"
        except:
            return "New tab failed"
    
    def _close_current_tab(self):
        try:
            pyautogui.hotkey('ctrl', 'w')
            return "Tab closed"
        except:
            return "Close tab failed"
    
    def _switch_to_next_tab(self):
        try:
            pyautogui.hotkey('ctrl', 'tab')
            return "Switched to next tab"
        except:
            return "Tab switch failed"
    
    def _switch_to_previous_tab(self):
        try:
            pyautogui.hotkey('ctrl', 'shift', 'tab')
            return "Switched to previous tab"
        except:
            return "Tab switch failed"
    
    def _refresh_page(self):
        try:
            pyautogui.press('f5')
            return "Page refreshed"
        except:
            return "Refresh failed"
    
    def _go_back(self):
        try:
            pyautogui.hotkey('alt', 'left')
            return "Navigated back"
        except:
            return "Back navigation failed"
    
    def _go_forward(self):
        try:
            pyautogui.hotkey('alt', 'right')
            return "Navigated forward"
        except:
            return "Forward navigation failed"
    
    def _bookmark_page(self):
        try:
            pyautogui.hotkey('ctrl', 'd')
            return "Page bookmarked"
        except:
            return "Bookmark failed"
    
    def _open_bookmarks(self):
        try:
            pyautogui.hotkey('ctrl', 'shift', 'b')
            return "Bookmarks opened"
        except:
            return "Bookmarks failed"
    
    def _search_web(self, query=""):
        try:
            pyautogui.hotkey('ctrl', 'l')
            pyautogui.typewrite(query)
            pyautogui.press('enter')
            return f"Searching for: {query}"
        except:
            return "Web search failed"
    
    def _skip_forward(self):
        try:
            pyautogui.hotkey('ctrl', 'right')
            return "Skipped forward"
        except:
            return "Skip forward failed"
    
    def _skip_backward(self):
        try:
            pyautogui.hotkey('ctrl', 'left')
            return "Skipped backward"
        except:
            return "Skip backward failed"
    
    def _increase_speed(self):
        try:
            pyautogui.hotkey('shift', '>')
            return "Speed increased"
        except:
            return "Speed increase failed"
    
    def _decrease_speed(self):
        try:
            pyautogui.hotkey('shift', '<')
            return "Speed decreased"
        except:
            return "Speed decrease failed"
    
    def _toggle_fullscreen(self):
        try:
            pyautogui.press('f')
            return "Fullscreen toggled"
        except:
            return "Fullscreen failed"
    
    def _toggle_subtitles(self):
        try:
            pyautogui.press('c')
            return "Subtitles toggled"
        except:
            return "Subtitles failed"
    
    def _dictate_email(self):
        try:
            subprocess.Popen('start mailto:', shell=True)
            return "Email dictation started"
        except:
            return "Email dictation failed"
    
    def _dictate_document(self):
        try:
            subprocess.Popen('notepad', shell=True)
            return "Document dictation started"
        except:
            return "Document dictation failed"
    
    def _take_screenshot_window(self):
        try:
            pyautogui.hotkey('alt', 'printscreen')
            return "Window screenshot taken"
        except:
            return "Window screenshot failed"
    
    def _take_screenshot_area(self):
        try:
            pyautogui.hotkey('win', 'shift', 's')
            return "Screenshot area selected"
        except:
            return "Area screenshot failed"
    
    def _start_screen_recording(self):
        try:
            pyautogui.hotkey('win', 'g')
            return "Screen recording started"
        except:
            return "Screen recording failed"
    
    def _stop_screen_recording(self):
        try:
            pyautogui.hotkey('win', 'alt', 'r')
            return "Screen recording stopped"
        except:
            return "Stop recording failed"
    
    def _wikipedia_search(self, query=""):
        try:
            import urllib.parse
            if not query:
                subprocess.Popen('start https://wikipedia.org', shell=True)
            else:
                url = f"https://en.wikipedia.org/wiki/Special:Search?search={urllib.parse.quote(query)}"
                subprocess.Popen(f'start {url}', shell=True)
            return "Wikipedia search opened"
        except:
            return "Wikipedia search failed"
    
    def _movie_recommend(self):
        try:
            subprocess.Popen('start https://www.imdb.com/chart/top', shell=True)
            return "Movie recommendations opened"
        except:
            return "Movie recommendations failed"
    
   
    
    def _game_launch(self):
        try:
            subprocess.Popen('start steam:', shell=True)
            return "Game launcher opened"
        except:
            return "Game launch failed"
    
    def _streaming_control(self):
        try:
            subprocess.Popen('start https://netflix.com', shell=True)
            return "Streaming service opened"
        except:
            return "Streaming control failed"
    
    def _playlist_manage(self):
        try:
            subprocess.Popen('start spotify:', shell=True)
            return "Playlist manager opened"
        except:
            return "Playlist management failed"

   
    
    # Additional missing methods
    def _play_music(self, genre="random"):
        try:
            subprocess.run('start spotify:', shell=True)
            time.sleep(3)
            pyautogui.press('space')
            return f"Playing {genre} music on Spotify"
        except:
            return "Could not play music"
    
    def _change_wallpaper(self):
        try:
            subprocess.run('start ms-settings:personalization-background', shell=True)
            return "Wallpaper settings opened"
        except:
            return "Could not change wallpaper"
    
   
    
    def _schedule_shutdown(self, time_str="1 hour"):
        try:
            minutes = 60
            if "minute" in time_str:
                minutes = int(''.join(filter(str.isdigit, time_str))) or 60
            elif "hour" in time_str:
                hours = int(''.join(filter(str.isdigit, time_str))) or 1
                minutes = hours * 60
            seconds = minutes * 60
            subprocess.run(f'shutdown /s /t {seconds}', shell=True)
            return f"Shutdown scheduled in {minutes} minutes"
        except:
            return "Could not schedule shutdown"
    
    def _backup_files(self):
        try:
            desktop = os.path.join(os.path.expanduser("~"), "Desktop")
            backup_folder = os.path.join(desktop, f"Backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}")
            documents = os.path.join(os.path.expanduser("~"), "Documents")
            os.makedirs(backup_folder, exist_ok=True)
            for file in os.listdir(documents)[:5]:
                try:
                    shutil.copy2(os.path.join(documents, file), backup_folder)
                except:
                    continue
            return f"Backup created in {backup_folder}"
        except:
            return "Backup failed"
    
    def _clean_temp_files(self):
        try:
            temp_folder = os.environ.get('TEMP')
            if temp_folder:
                files_deleted = 0
                for file in os.listdir(temp_folder):
                    try:
                        file_path = os.path.join(temp_folder, file)
                        if os.path.isfile(file_path):
                            os.remove(file_path)
                            files_deleted += 1
                    except:
                        continue
                return f"Cleaned {files_deleted} temporary files"
            return "Could not access temp folder"
        except:
            return "Temp cleanup failed"
    
    def _clear_clipboard(self): 
        try:
            pyautogui.copy('')
            return "Clipboard cleared"
        except:
            return "Clipboard clear failed"
    
    def _clear_browser_history(self):
        try:
            chrome_path = os.path.expanduser("~\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\History")
            if os.path.exists(chrome_path):
                subprocess.run(['taskkill', '/f', '/im', 'chrome.exe'], shell=True)
                time.sleep(2)
                os.remove(chrome_path)
            return "Browser history cleared"
        except:
            return "Could not clear browser history"
    
    def _empty_recycle_bin(self):
        try:
            subprocess.run('powershell -c "Clear-RecycleBin -Force"', shell=True)
            return "Recycle bin emptied"
        except:
            return "Could not empty recycle bin"
    
    def _lock_screen(self):
        try:
            subprocess.run('rundll32.exe user32.dll,LockWorkStation', shell=True)
            return "Screen locked"
        except:
            return "Screen lock failed"
    
    def _find_text(self): 
        try:
            pyautogui.hotkey('ctrl', 'f')
            return "Find dialog opened"
        except:
            return "Find text failed"
    
    def _replace_text(self): 
        try:
            pyautogui.hotkey('ctrl', 'h')
            return "Replace dialog opened"
        except:
            return "Replace text failed"
    
    def _new_document(self): 
        try:
            pyautogui.hotkey('ctrl', 'n')
            return "New document created"
        except:
            return "New document failed"
    
    def _print_document(self): 
        try:
            pyautogui.hotkey('ctrl', 'p')
            return "Print dialog opened"
        except:
            return "Print document failed"
    
    def _zoom_in(self): 
        try:
            pyautogui.hotkey('ctrl', 'plus')
            return "Zoomed in"
        except:
            return "Zoom in failed"
    
    def _zoom_out(self): 
        try:
            pyautogui.hotkey('ctrl', 'minus')
            return "Zoomed out"
        except:
            return "Zoom out failed"
    
    def _maximize_window(self): 
        try:
            pyautogui.hotkey('win', 'up')
            return "Window maximized"
        except:
            return "Maximize window failed"
    
    def _minimize_window(self): 
        try:
            pyautogui.hotkey('win', 'down')
            pyautogui.hotkey('win', 'down')
            return "Window minimized"
        except:
            return "Minimize window failed"
    
    def _split_screen_left(self): 
        try:
            pyautogui.hotkey('win', 'left')
            return "Screen split left"
        except:
            return "Split screen left failed"
    
    def _split_screen_right(self): 
        try:
            pyautogui.hotkey('win', 'right')
            return "Screen split right"
        except:
            return "Split screen right failed"
    
    def _close_window(self): 
        try:
            pyautogui.hotkey('alt', 'f4')
            return "Window closed"
        except:
            return "Close window failed"
    
    def _switch_window(self): 
        try:
            pyautogui.hotkey('alt', 'tab')
            return "Window switched"
        except:
            return "Switch window failed"
    
    def _play_pause(self): 
        try:
            pyautogui.press('space')
            return "Media play/pause toggled"
        except:
            return "Play/pause failed"
    
    def _next_track(self): 
        try:
            pyautogui.press('nexttrack')
            return "Next track"
        except:
            return "Next track failed"
    
    def _previous_track(self): 
        try:
            pyautogui.press('prevtrack')
            return "Previous track"
        except:
            return "Previous track failed"
    
    def _stop_media(self): 
        try:
            pyautogui.press('stop')
            return "Media stopped"
        except:
            return "Stop media failed"
    
    # YouTube Automation Methods
    def _youtube_play(self):
        try:
            # Try both space and k key for play/pause
            pyautogui.press('space')
            time.sleep(0.2)
            return "YouTube video play/paused"
        except:
            try:
                pyautogui.press('k')
                return "YouTube video play/paused"
            except:
                return "YouTube play failed"
    
    def _youtube_pause(self):
        try:
            pyautogui.press('space')
            return "YouTube video paused"
        except:
            try:
                pyautogui.press('k')
                return "YouTube video paused"
            except:
                return "YouTube pause failed"
    
    def _youtube_next(self):
        try:
            pyautogui.hotkey('shift', 'n')
            return "Next YouTube video"
        except:
            return "YouTube next failed"
    
    def _youtube_previous(self):
        try:
            pyautogui.hotkey('shift', 'p')
            return "Previous YouTube video"
        except:
            return "YouTube previous failed"
    
    def _youtube_fullscreen(self):
        try:
            pyautogui.press('f')
            return "YouTube fullscreen toggled"
        except:
            return "YouTube fullscreen failed"
    
    def _youtube_volume_up(self):
        try:
            pyautogui.press('up')
            return "YouTube volume increased"
        except:
            return "YouTube volume up failed"
    
    def _youtube_volume_down(self):
        try:
            pyautogui.press('down')
            return "YouTube volume decreased"
        except:
            return "YouTube volume down failed"
    
    def _youtube_mute(self):
        try:
            pyautogui.press('m')
            return "YouTube muted/unmuted"
        except:
            return "YouTube mute failed"
    
    def _youtube_speed_up(self):
        try:
            pyautogui.hotkey('shift', '>')
            return "YouTube speed increased"
        except:
            return "YouTube speed up failed"
    
    def _youtube_speed_down(self):
        try:
            pyautogui.hotkey('shift', '<')
            return "YouTube speed decreased"
        except:
            return "YouTube speed down failed"
    
    def _youtube_skip_forward(self):
        try:
            pyautogui.press('l')
            return "YouTube skipped forward 10 seconds"
        except:
            return "YouTube skip forward failed"
    
    def _youtube_skip_backward(self):
        try:
            pyautogui.press('j')
            return "YouTube skipped backward 10 seconds"
        except:
            return "YouTube skip backward failed"
    
    def _youtube_search(self):
        try:
            pyautogui.press('/')
            return "YouTube search activated"
        except:
            return "YouTube search failed"
    
    def _youtube_subscribe(self):
        try:
            pyautogui.click(1200, 400)  # Approximate subscribe button location
            return "YouTube subscribe clicked"
        except:
            return "YouTube subscribe failed"
    
    def _youtube_like(self):
        try:
            pyautogui.click(1100, 500)  # Approximate like button location
            return "YouTube like clicked"
        except:
            return "YouTube like failed"
    
    def _youtube_dislike(self):
        try:
            pyautogui.click(1150, 500)  # Approximate dislike button location
            return "YouTube dislike clicked"
        except:
            return "YouTube dislike failed"
    
    def _youtube_comment(self):
        try:
            pyautogui.scroll(-5)
            pyautogui.click(600, 700)  # Approximate comment box location
            return "YouTube comment box activated"
        except:
            return "YouTube comment failed"
    
    def _youtube_share(self):
        try:
            pyautogui.click(1200, 500)  # Approximate share button location
            return "YouTube share clicked"
        except:
            return "YouTube share failed"
    
    def _youtube_theater_mode(self):
        try:
            pyautogui.press('t')
            return "YouTube theater mode toggled"
        except:
            return "YouTube theater mode failed"
    
    def _youtube_miniplayer(self):
        try:
            pyautogui.press('i')
            return "YouTube miniplayer toggled"
        except:
            return "YouTube miniplayer failed"
    
    def _youtube_captions(self):
        try:
            pyautogui.press('c')
            return "YouTube captions toggled"
        except:
            return "YouTube captions failed"
    
    def _play_video(self, video_name=""):
        return self._search_and_play(video_name)
    
    def _play_movie(self, movie_name=""):
        return self._search_and_play(f"{movie_name} movie")
    
    def _play_song(self, song_name=""):
        return self._search_and_play(f"{song_name} song")
    
    def _search_and_play(self, search_term=""):
        try:
            if not search_term:
                return "Please specify what to search for"
            
            # Method 1: Try to get first video using requests and parse HTML
            try:
                import requests
                import re
                import webbrowser
                import urllib.parse
                
                # Search YouTube and get first video ID
                search_url = f"https://www.youtube.com/results?search_query={urllib.parse.quote(search_term)}"
                headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'}
                
                response = requests.get(search_url, headers=headers)
                
                # Find first video ID in the HTML
                video_id_match = re.search(r'"videoId":"([^"]+)"', response.text)
                if video_id_match:
                    video_id = video_id_match.group(1)
                    video_url = f"https://www.youtube.com/watch?v={video_id}"
                    webbrowser.open(video_url)
                    # Wait for page to load then press space to play
                    import threading
                    def auto_play():
                        time.sleep(5)
                        pyautogui.press('space')
                    threading.Thread(target=auto_play, daemon=True).start()
                    return f"Playing first result for: {search_term}"
                
            except:
                pass
            
            # Method 2: Fallback to search results
            import webbrowser
            import urllib.parse
            
            url = "https://www.youtube.com/results?search_query=" + urllib.parse.quote(search_term)
            webbrowser.open(url)
            return f"Opened YouTube search for: {search_term} (click first video to play)"
                
        except Exception as e:
            return f"Failed to play {search_term}: {str(e)}"
    
    def _search_and_play_simple(self, search_term):
        try:
            # Simple direct approach - open YouTube and search
            subprocess.run('start chrome https://www.youtube.com', shell=True)
            time.sleep(3)
            
            # Click search box
            pyautogui.click(640, 100)
            time.sleep(1)
            
            # Type and search
            pyautogui.typewrite(search_term)
            pyautogui.press('enter')
            time.sleep(4)
            
            # Click first video - try multiple positions
            positions = [(320, 300), (320, 350), (320, 400), (280, 350), (360, 350)]
            for x, y in positions:
                pyautogui.click(x, y)
                time.sleep(3)  # Wait for video page to load
                
                # Click play button on video player
                pyautogui.click(640, 360)  # Center of video player
                time.sleep(1)
                pyautogui.press('space')  # Ensure video starts playing
                break
            
            return f"Playing: {search_term}"
        except Exception as e:
            return f"Simple method failed: {str(e)}"
    
    def _play_direct_video(self, search_term):
        """Direct method using webbrowser"""
        try:
            import webbrowser
            import urllib.parse
            
            # Create YouTube search URL
            url = "https://www.youtube.com/results?search_query=" + urllib.parse.quote(search_term)
            webbrowser.open(url)
            
            return f"Opened YouTube search for: {search_term}"
                
        except Exception as e:
            return f"Direct video failed: {str(e)}"
    
    def _focus_chrome(self):
        """Helper method to ensure Chrome window is focused"""
        try:
            pyautogui.hotkey('alt', 'tab')
            time.sleep(0.2)
        except:
            pass
   
    
    # Chrome Automation Methods - Fixed and Improved
    def _chrome_new_tab(self):
        try:
            self._focus_chrome()
            pyautogui.hotkey('ctrl', 't')
            time.sleep(0.3)
            return "New Chrome tab opened"
        except Exception as e:
            return f"Chrome new tab failed: {str(e)}"
    
    def _chrome_close_tab(self):
        try:
            self._focus_chrome()
            pyautogui.hotkey('ctrl', 'w')
            time.sleep(0.3)
            return "Chrome tab closed"
        except Exception as e:
            return f"Chrome close tab failed: {str(e)}"
    
    def _chrome_next_tab(self):
        try:
            self._focus_chrome()
            pyautogui.hotkey('ctrl', 'pagedown')
            time.sleep(0.2)
            return "Switched to next Chrome tab"
        except:
            try:
                pyautogui.hotkey('ctrl', 'tab')
                return "Switched to next Chrome tab"
            except Exception as e:
                return f"Chrome next tab failed: {str(e)}"
    
    def _chrome_previous_tab(self):
        try:
            self._focus_chrome()
            pyautogui.hotkey('ctrl', 'pageup')
            time.sleep(0.2)
            return "Switched to previous Chrome tab"
        except:
            try:
                pyautogui.hotkey('ctrl', 'shift', 'tab')
                return "Switched to previous Chrome tab"
            except Exception as e:
                return f"Chrome previous tab failed: {str(e)}"
    
    def _chrome_reload(self):
        try:
            self._focus_chrome()
            pyautogui.hotkey('ctrl', 'r')
            time.sleep(0.3)
            return "Chrome page reloaded"
        except:
            try:
                pyautogui.press('f5')
                return "Chrome page reloaded"
            except Exception as e:
                return f"Chrome reload failed: {str(e)}"
    
    def _chrome_back(self):
        try:
            pyautogui.hotkey('alt', 'left')
            return "Chrome navigated back"
        except:
            return "Chrome back failed"
    
    def _chrome_forward(self):
        try:
            pyautogui.hotkey('alt', 'right')
            return "Chrome navigated forward"
        except:
            return "Chrome forward failed"
    
    def _chrome_home(self):
        try:
            pyautogui.hotkey('alt', 'home')
            return "Chrome home page opened"
        except:
            return "Chrome home failed"
    
    def _chrome_bookmark(self):
        try:
            pyautogui.hotkey('ctrl', 'd')
            return "Chrome bookmark added"
        except:
            return "Chrome bookmark failed"
    
    def _chrome_history(self):
        try:
            pyautogui.hotkey('ctrl', 'h')
            return "Chrome history opened"
        except:
            return "Chrome history failed"
    
    def _chrome_downloads(self):
        try:
            pyautogui.hotkey('ctrl', 'j')
            return "Chrome downloads opened"
        except:
            return "Chrome downloads failed"
    
    def _chrome_incognito(self):
        try:
            pyautogui.hotkey('ctrl', 'shift', 'n')
            return "Chrome incognito window opened"
        except:
            return "Chrome incognito failed"
    
    def _chrome_developer_tools(self):
        try:
            pyautogui.press('f12')
            return "Chrome developer tools toggled"
        except:
            return "Chrome developer tools failed"
    
    def _chrome_zoom_in(self):
        try:
            pyautogui.hotkey('ctrl', 'plus')
            return "Chrome zoomed in"
        except:
            return "Chrome zoom in failed"
    
    def _chrome_zoom_out(self):
        try:
            pyautogui.hotkey('ctrl', 'minus')
            return "Chrome zoomed out"
        except:
            return "Chrome zoom out failed"
    
    def _chrome_zoom_reset(self):
        try:
            pyautogui.hotkey('ctrl', '0')
            return "Chrome zoom reset"
        except:
            return "Chrome zoom reset failed"
    
    def _chrome_find(self):
        try:
            pyautogui.hotkey('ctrl', 'f')
            return "Chrome find dialog opened"
        except:
            return "Chrome find failed"
    
    def _chrome_print(self):
        try:
            pyautogui.hotkey('ctrl', 'p')
            return "Chrome print dialog opened"
        except:
            return "Chrome print failed"
    
    def _chrome_save_page(self):
        try:
            pyautogui.hotkey('ctrl', 's')
            return "Chrome page saved"
        except:
            return "Chrome save page failed"
    
    def _chrome_view_source(self):
        try:
            pyautogui.hotkey('ctrl', 'u')
            return "Chrome page source opened"
        except:
            return "Chrome view source failed"
    
    def _chrome_extensions(self):
        try:
            pyautogui.hotkey('ctrl', 'shift', 'delete')
            return "Chrome extensions opened"
        except:
            return "Chrome extensions failed"
    
    def _chrome_settings(self):
        try:
            # Method 1: Try to open Chrome first, then navigate to settings
            subprocess.Popen('start chrome', shell=True)
            time.sleep(3)  # Wait for Chrome to open
            
            # Navigate to settings using keyboard shortcut
            pyautogui.hotkey('ctrl', 'l')  # Focus address bar
            time.sleep(0.5)
            pyautogui.typewrite('chrome://settings/')
            pyautogui.press('enter')
            time.sleep(1)
            return "Chrome settings opened"
        except Exception as e:
            try:
                # Method 2: Direct webbrowser approach
                import webbrowser
                webbrowser.open('chrome://settings/')
                time.sleep(2)
                return "Chrome settings opened"
            except Exception as e2:
                try:
                    # Method 3: Use Chrome command line
                    subprocess.Popen(['chrome', '--new-tab', 'chrome://settings/'], shell=True)
                    time.sleep(2)
                    return "Chrome settings opened"
                except Exception as e3:
                    return f"Chrome settings failed: {str(e3)}"
    
    def _chrome_clear_data(self):
        try:
            pyautogui.hotkey('ctrl', 'shift', 'delete')
            return "Chrome clear data dialog opened"
        except:
            return "Chrome clear data failed"
    
    def _open_path(self, path_query=""):
        """Enhanced file/folder opening with smart mapping and search"""
        try:
            import os
            import subprocess
            import glob
            
            # Get query from current command if not provided
            if not path_query and hasattr(self, '_current_query'):
                path_query = self._current_query
            
            if not path_query:
                return "Please specify what to open"
            
            query = path_query.lower().strip()
            
            # Handle recent files commands
            if any(phrase in query for phrase in ["recent files", "recent documents", "recently used files", "show recent files", "show recently used", "open recent"]):
                try:
                    import glob
                    import time
                    
                    # Windows stores recent files in this folder
                    recent_folder = os.path.expanduser(r"~\AppData\Roaming\Microsoft\Windows\Recent")
                    
                    # Get all recent items (*.lnk = shortcut files)
                    recent_files = glob.glob(os.path.join(recent_folder, "*.lnk"))
                    
                    if not recent_files:
                        return "No recent files found"
                    
                    # Filter out system files and keep only user documents
                    user_files = []
                    for file in recent_files:
                        name = os.path.basename(file).lower()
                        # Skip system files and keep user documents
                        if not any(skip in name for skip in ['ms-', 'system', 'windows', 'program', 'temp', 'cache']):
                            # Keep files with common document extensions
                            if any(ext in name for ext in ['.doc', '.pdf', '.ppt', '.xls', '.txt', '.jpg', '.png', '.mp4', '.mp3']):
                                user_files.append(file)
                    
                    # If no user files found, use all recent files
                    if not user_files:
                        user_files = recent_files
                    
                    # Sort by last modified (newest first)
                    user_files.sort(key=os.path.getmtime, reverse=True)
                    recent_files = user_files
                    
                    # Check if user wants to open recent file
                    if "open recent" in query:
                        # Open the first (most recent) file
                        first_recent = recent_files[0]
                        file_name = os.path.basename(first_recent).replace(".lnk", "")
                        # Clean file name to avoid encoding issues
                        file_name = ''.join(char for char in file_name if ord(char) < 128)
                        
                        # Try to resolve the shortcut and open the actual file
                        try:
                            # Use PowerShell to resolve the shortcut
                            ps_command = f'powershell -c "$ws = New-Object -ComObject WScript.Shell; $s = $ws.CreateShortcut(\"{first_recent}\"); $s.TargetPath"'
                            result = subprocess.run(ps_command, shell=True, capture_output=True, text=True)
                            
                            if result.returncode == 0 and result.stdout.strip():
                                target_path = result.stdout.strip()
                                if os.path.exists(target_path):
                                    subprocess.run(f'start "" "{target_path}"', shell=True)
                                    return f"{file_name} recent file opened"
                        except:
                            pass
                        
                        # Fallback: try to open the shortcut directly
                        subprocess.run(f'start "" "{first_recent}"', shell=True)
                        return f"{file_name} recent file opened"
                    
                    # Check for specific number of files to show
                    import re
                    number_match = re.search(r'(\d+)', query)
                    if number_match:
                        num_files = min(int(number_match.group(1)), len(recent_files))
                        top_recent = recent_files[:num_files]
                        # Limit the actual display to requested number
                        recent_files = top_recent
                    else:
                        # Default to 5 files
                        top_recent = recent_files[:5]
                        recent_files = top_recent
                    
                    # Get file names without .lnk extension and clean them
                    recent_names = []
                    for f in top_recent:
                        name = os.path.basename(f).replace(".lnk", "")
                        # Remove special characters that might cause encoding issues
                        clean_name = ''.join(char for char in name if ord(char) < 128)
                        recent_names.append(clean_name)
                    
                    # Open the Windows Recent Items folder
                    subprocess.run(f'explorer "{recent_folder}"', shell=True)
                    
                    # Create safe output string
                    if len(recent_names) > 3:
                        display_names = recent_names[:3]
                        return f"Showing {len(top_recent)} recent files: {', '.join(display_names)} and more"
                    else:
                        return f"Showing {len(top_recent)} recent files: {', '.join(recent_names)}"
                    
                except Exception as e:
                    # Handle encoding errors specifically
                    error_msg = str(e)
                    if 'charmap' in error_msg or 'codec' in error_msg:
                        return "Recent files found but cannot display due to special characters"
                    return f"Unable to show recent files: {error_msg}"
            
            # Enhanced folder shortcuts with multiple variations
            folder_shortcuts = {
                'downloads': ['downloads', 'download', 'dl'],
                'documents': ['documents', 'document', 'docs', 'doc'],
                'desktop': ['desktop', 'desk'],
                'pictures': ['pictures', 'picture', 'pics', 'pic', 'images', 'photos'],
                'music': ['music', 'songs', 'audio'],
                'videos': ['videos', 'video', 'movies', 'films'],
                'appdata': ['appdata', 'app data'],
                'temp': ['temp', 'temporary'],
                'startup': ['startup', 'start up']
            }
            
            # Check for folder shortcuts
            for folder, variations in folder_shortcuts.items():
                if any(var in query for var in variations):
                    if folder == 'appdata':
                        path = os.path.join(os.path.expanduser("~"), "AppData")
                    elif folder == 'temp':
                        path = os.environ.get('TEMP', 'C:\\Windows\\Temp')
                    elif folder == 'startup':
                        path = os.path.join(os.path.expanduser("~"), "AppData", "Roaming", "Microsoft", "Windows", "Start Menu", "Programs", "Startup")
                    else:
                        path = os.path.join(os.path.expanduser("~"), folder.title())
                    
                    if os.path.exists(path):
                        subprocess.run(f'explorer "{path}"', shell=True)
                        return f"{folder.title()} folder opened"
            
            # Extract filename from query FIRST
            import re
            # Look for patterns like "open file.txt" or "find document.pdf"
            file_match = re.search(r'(?:open|find|locate)\s+(?:file\s+)?([^\s]+\.[^\s]+)', query)
            if file_match:
                filename = file_match.group(1)
            else:
                # If no extension found, look for quoted filenames
                quote_match = re.search(r'["\']([^"\'\/\\]+\.[^"\'\/\\]+)["\']', query)
                if quote_match:
                    filename = quote_match.group(1)
                else:
                    filename = None
            
            if filename:
                
                # Search in common directories
                search_dirs = [
                    os.path.join(os.path.expanduser("~"), "Desktop"),
                    os.path.join(os.path.expanduser("~"), "Downloads"),
                    os.path.join(os.path.expanduser("~"), "Documents"),
                    os.path.join(os.path.expanduser("~"), "Pictures"),
                    os.path.join(os.path.expanduser("~"), "Videos"),
                    os.path.join(os.path.expanduser("~"), "Music")
                ]
                
                # Fuzzy search for files
                found_files = []
                for search_dir in search_dirs:
                    if os.path.exists(search_dir):
                        # Exact match
                        exact_path = os.path.join(search_dir, filename)
                        if os.path.exists(exact_path):
                            found_files.append(exact_path)
                        
                        # Fuzzy match
                        try:
                            matches = glob.glob(os.path.join(search_dir, f"*{filename}*"))
                            found_files.extend(matches)
                        except:
                            pass
                
                if found_files:
                    file_path = found_files[0]
                    if os.path.isfile(file_path):
                        subprocess.run(f'start "" "{file_path}"', shell=True)
                        return f"{os.path.basename(file_path)} opened"
                    else:
                        subprocess.run(f'explorer "{file_path}"', shell=True)
                        return f"{os.path.basename(file_path)} folder opened"
                else:
                    return f"'{filename}' not found"
            
            # Search for custom folder names with exact and fuzzy matching
            folder_name = None
            folder_patterns = [
                r'open\s+folder\s+(.+)',
                r'open\s+(.+)\s+folder',
                r'open\s+([^.]+)$'  # only match if no file extension
            ]
            for pat in folder_patterns:
                m = re.search(pat, query)
                if m:
                    folder_name = m.group(1).strip()
                    break

            if folder_name:
                folder_name = folder_name.lower()
                search_roots = [
                    os.path.join(os.path.expanduser("~"), "Desktop"),
                    os.path.join(os.path.expanduser("~"), "Documents"),
                    os.path.join(os.path.expanduser("~"), "Downloads"),
                    os.path.expanduser("~")
                ]

                exact_match = []
                fuzzy_match = []

                for root in search_roots:
                    for dirpath, dirnames, _ in os.walk(root):
                        for d in dirnames:
                            name = d.lower()
                            if name == folder_name:
                                exact_match.append(os.path.join(dirpath, d))
                            elif folder_name in name:
                                fuzzy_match.append(os.path.join(dirpath, d))

                if exact_match:
                    subprocess.run(f'explorer "{exact_match[0]}"', shell=True)
                    return f"Opened folder: {os.path.basename(exact_match[0])}"

                if fuzzy_match:
                    subprocess.run(f'explorer "{fuzzy_match[0]}"', shell=True)
                    return f"Opened folder: {os.path.basename(fuzzy_match[0])}"
                
                return f"Folder '{folder_name}' not found"
            
            # Default: open file explorer
            subprocess.run('explorer', shell=True)
            return "File Explorer opened"
            
        except Exception as e:
            return f"Error: {str(e)}"
    
    def _create_video(self):
        """Create AI video based on query"""
        try:
            # Extract prompt from query
            query = self._current_query.lower()
            
            # Remove command words to get the actual prompt
            for cmd in ['create video', 'generate video', 'make video', 'ai video']:
                if cmd in query:
                    prompt = query.replace(cmd, '').strip()
                    break
            else:
                prompt = query
            
            # Remove common words
            prompt = prompt.replace('of', '').replace('a', '').replace('an', '').strip()
            
            if not prompt:
                return "Please specify what video you want me to create"
            
            # Start video generation in background
            from engine.simple_video_gen import create_simple_video
            return create_simple_video(prompt)
            
        except Exception as e:
            return f"Video creation failed: {str(e)}"
    
    def _brightness_up(self):
        try:
            # Get current brightness and increase by 10%
            get_cmd = 'powershell -c "(Get-WmiObject -Namespace root/WMI -Class WmiMonitorBrightness).CurrentBrightness"'
            result = subprocess.run(get_cmd, shell=True, capture_output=True, text=True)
            
            if result.returncode == 0 and result.stdout.strip():
                current = int(result.stdout.strip())
                new_brightness = min(100, current + 10)
                
                set_cmd = f'powershell -c "(Get-WmiObject -Namespace root/WMI -Class WmiMonitorBrightnessMethods).WmiSetBrightness(1,{new_brightness})"'
                subprocess.run(set_cmd, shell=True)
                return f"Brightness increased to {new_brightness}%"
            else:
                # Fallback to keyboard method
                pyautogui.press('brightnessup')
                return "Brightness increased"
        except:
            return "Brightness control not supported on this system"
    
    def _brightness_down(self):
        try:
            # Get current brightness and decrease by 10%
            get_cmd = 'powershell -c "(Get-WmiObject -Namespace root/WMI -Class WmiMonitorBrightness).CurrentBrightness"'
            result = subprocess.run(get_cmd, shell=True, capture_output=True, text=True)

            if result.returncode == 0 and result.stdout.strip():
                current = int(result.stdout.strip())
                new_brightness = max(0, current - 10)

                set_cmd = f'powershell -c "(Get-WmiObject -Namespace root/WMI -Class WmiMonitorBrightnessMethods).WmiSetBrightness(1,{new_brightness})"'
                subprocess.run(set_cmd, shell=True)
                return f"Brightness decreased to {new_brightness}%"
            else:
                # Fallback to keyboard brightness down
                pyautogui.press('brightnessdown')
                return "Brightness decreased"
        except Exception as e:
            return f"Brightness control not supported on this system: {e}"


    def _schedule_event(self, event_text=""):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            if event_text:
                return voice_advanced_ai.calendar_schedule(event_text)
            return "Please specify an event to schedule"
        except Exception as e:
            return f"Scheduling failed: {str(e)}"
        except:
            return "Error scheduling event"
    
    def _show_calendar(self):
        try:
            from engine.voice_advanced_ai import get_voice_advanced_response
            result = get_voice_advanced_response('show calendar')
            return result
        except Exception as e:
            return f"Error showing calendar: {str(e)}"
    
    # Advanced AI Features
    def _daily_briefing(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.daily_briefing()
        except:
            return "Error getting daily briefing"
    
    def _predictive_assistance(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.predictive_assistance()
        except:
            return "Error with predictive assistance"
    
    def _context_memory_store(self, data=""):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.context_memory_store("user_input", data)
        except:
            return "Error storing memory"
    
    def _context_memory_recall(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            result = voice_advanced_ai.context_memory_recall()
            return result
        except Exception as e:
            return f"Error recalling memory: {str(e)}"
    
    # Security & Authentication
    def _file_vault_encrypt(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.file_vault_encrypt()
        except Exception as e:
            return f"File encryption error: {str(e)}"
    
    def _file_vault_decrypt(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.file_vault_decrypt()
        except Exception as e:
            return f"File decryption error: {str(e)}"
    
    def _anomaly_detection(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.anomaly_detection_recent_processes()
        except Exception as e:
            return f"Anomaly detection error: {str(e)}"
    
    def _phishing_scan(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.phishing_malware_scan_link()
        except Exception as e:
            return f"Phishing scan error: {str(e)}"
    
    def _parental_control(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.parental_control_set()
        except Exception as e:
            return f"Parental control error: {str(e)}"
    
    # Cloud & Multi-Device
    def _cloud_backup(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return "Cloud backup feature available"
        except:
            return "Error with cloud backup"
    
    def _email_summarize(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.email_summarize()
        except Exception as e:
            return f"Error with email summarization: {str(e)}"
    
    def _sync_devices(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.sync_across_devices()
        except Exception as e:
            return f"Error with device sync: {str(e)}"
    
    # AI Productivity
    def _realtime_transcription(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.realtime_transcription()
        except:
            return "Error with transcription"
    
    def _summarize_meeting(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return "Meeting summarization feature available"
        except:
            return "Error with meeting summary"
    
    def _smart_clipboard(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.smart_clipboard_store()
        except:
            return "Error with smart clipboard"
    
    def _document_qa(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return "Document Q&A feature available"
        except:
            return "Error with document Q&A"
    
# Update your dual AI call to support PowerPoint creation

    def _ai_presentation(self, topic="", create_ppt=True):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            
            # Extract topic from current query if available
            if hasattr(self, '_current_query') and self._current_query and not topic:
                import re
                query = self._current_query.lower()
                
                # Extract topic from various patterns
                patterns = [
                    r'(?:make|create)\s+(?:slides|presentation|ppt)\s+(?:of|on|about)\s+(.+)',
                    r'(?:slides|presentation|ppt)\s+(?:of|on|about)\s+(.+)',
                    r'(?:make|create)\s+(.+?)\s+(?:slides|presentation|ppt)',
                    r'presentation\s+(.+)',
                    r'slides\s+(.+)'
                ]
                
                for pattern in patterns:
                    match = re.search(pattern, query)
                    if match:
                        topic = match.group(1).strip()
                        break
            
            if not topic:
                topic = "ai assistant"
                
            return voice_advanced_ai.ai_presentation_maker(topic, create_ppt)
        except Exception as e:
            return f"Error with AI presentation: {str(e)}"

# Usage examples:
# _ai_presentation("machine learning")           # Text outline only
# _ai_presentation("AI", create_ppt=True)        # Creates actual PowerPoint file
    
    def _ai_report(self, topic=""):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            if not topic:
                topic = "business analysis"
            return voice_advanced_ai.ai_report_maker(topic)
        except Exception as e:
            return f"Error with AI report: {str(e)}"
    
    # Smart Home
    def _smart_home_control(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return "Smart home control available"
        except:
            return "Error with smart home control"

    def _check_new_features(self, query):
        """Check new features from external file"""
        try:
            from engine.new_features import get_new_feature_response
            result = get_new_feature_response(query)
            return result
        except:
            return None
    
    def _set_home_scene(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return "Home scene setting available"
        except:
            return "Error setting home scene"
    
    def _security_camera(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return "Security camera feature available"
        except:
            return "Error with security camera"
    
    def _energy_monitoring(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return "Energy monitoring available"
        except:
            return "Error with energy monitoring"
    
    # Entertainment Plus
    def _ai_dj_mode(self):
        try:
            from engine.ai_dj_enhanced import ai_dj_mode_enhanced
            return ai_dj_mode_enhanced()
        except:
            return "Error with AI DJ mode"
    
    def _trivia_game(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.trivia_game_start()
        except Exception as e:
            return f"Trivia game error: {str(e)}"
    
    def _storytelling(self):
        try:
            from engine.voice_advanced_ai import VoiceAdvancedAI
            ai = VoiceAdvancedAI()
            return ai.storytelling_mode()
        except Exception as e:
            return f"Storytelling error: {str(e)}"
    
    def _fitness_coach(self):
        try:
            from engine.voice_advanced_ai import VoiceAdvancedAI
            ai = VoiceAdvancedAI()
            return ai.fitness_coach()
        except Exception as e:
            return f"Fitness coach error: {str(e)}"
    
    # Health & Wellness
    def _posture_detection(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.posture_detection()
        except Exception as e:
            return f"Posture detection error: {str(e)}"
    
    def _eye_care_mode(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.eye_care_mode()
        except Exception as e:
            return f"Eye care mode error: {str(e)}"
    
    def _daily_health_log(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.daily_health_log()
        except Exception as e:
            return f"Daily health log error: {str(e)}"
    
    def _mood_tracker(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.mood_tracker()
        except Exception as e:
            return f"Mood tracker error: {str(e)}"
    
    def _meditation_prompt(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.meditation_prompt()
        except Exception as e:
            return f"Meditation prompt error: {str(e)}"
    
    def _system_monitor_live(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.system_monitor_dashboard_live()
        except Exception as e:
            return f"System monitoring error: {str(e)}"
    
    def _auto_fix_system(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.auto_fix_system_basic()
        except Exception as e:
            return f"Auto-fix system error: {str(e)}"
    
    # All Advanced AI Features Implementation
    def _manage_package(self, action="list", package=""):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.manage_package(action, package)
        except Exception as e:
            return f"Package management error: {str(e)}"
    
    def _docker_control(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.docker_control()
        except Exception as e:
            return f"Docker control error: {str(e)}"
    
    def _adaptive_learning(self, action="general_action"):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.adaptive_learning(action)
        except Exception as e:
            return f"Adaptive learning error: {str(e)}"
    
    def _check_proactive(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.check_proactive_suggestions()
        except Exception as e:
            return f"Proactive check error: {str(e)}"
    
    def _enable_proactive_mode(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.enable_proactive_mode()
        except Exception as e:
            return f"Enable proactive error: {str(e)}"
    
    def _disable_proactive_mode(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.disable_proactive_mode()
        except Exception as e:
            return f"Disable proactive error: {str(e)}"
    
    def _manual_learn(self, action=""):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.manual_learn(action)
        except Exception as e:
            return f"Manual learn error: {str(e)}"
    
    def _calendar_schedule(self, event_data=""):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.calendar_schedule(event_data)
        except Exception as e:
            return f"Calendar schedule error: {str(e)}"
    
    # All other advanced features with the same pattern
    def _code_agent(self):
        try:
            from engine.voice_advanced_ai import VoiceAdvancedAI
            ai = VoiceAdvancedAI()
            return ai.code_agent()
        except Exception as e:
            return f"Code agent error: {str(e)}"
    
    def _research_agent(self):
        try:
            from engine.voice_advanced_ai import VoiceAdvancedAI
            ai = VoiceAdvancedAI()
            return ai.research_agent()
        except Exception as e:
            return f"Research agent error: {str(e)}"
    
    def _debug_screen_code(self):
        try:
            from engine.voice_advanced_ai import VoiceAdvancedAI
            ai = VoiceAdvancedAI()
            return ai.debug_screen_code()
        except Exception as e:
            return f"Debug screen error: {str(e)}"
    
    def _organizer_agent(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.organizer_agent()
        except Exception as e:
            return f"Organizer agent error: {str(e)}"
    
    def _multi_agent_collab(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.multi_agent_collab()
        except Exception as e:
            return f"Multi-agent collaboration error: {str(e)}"
    
    def _scholar_search(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.scholar_search()
        except Exception as e:
            return f"Scholar search error: {str(e)}"
    
    def _stock_updates(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.stock_updates()
        except Exception as e:
            return f"Stock updates error: {str(e)}"
    
    def _crypto_updates(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.crypto_updates()
        except Exception as e:
            return f"Crypto updates error: {str(e)}"
    
    def _realtime_translation(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.realtime_translation()
        except Exception as e:
            return f"Real-time translation error: {str(e)}"
    
    def _start_gesture_control(self):
        try:
            return "Gesture control started"
        except Exception as e:
            return f"Gesture control error: {str(e)}"
    
    def _stop_gesture_control(self):
        try:
            return "Gesture control stopped"
        except Exception as e:
            return f"Gesture control error: {str(e)}"
    
    def _code_review(self, code_text=""):
        try:
            import pyperclip
            
            if not code_text:
                try:
                    code_text = pyperclip.paste()
                    if not code_text or len(code_text.strip()) < 5:
                        return "Please select code and copy to clipboard first"
                except:
                    return "Please select code and copy to clipboard first"
            
            # Add line numbers to code
            lines = code_text.split('\n')
            numbered_code = '\n'.join([f'{i+1}: {line}' for i, line in enumerate(lines)])
            
            prompt = f'''Find errors. Be extremely brief.

{numbered_code}

Answer format: Line X: change Y to Z'''
            
            if self.ai_provider == 'groq':
                response = self.groq_client.chat.completions.create(
                    messages=[{"role": "user", "content": prompt}],
                    model="llama-3.1-8b-instant"
                )
                return response.choices[0].message.content.strip()
            else:
                response = self.gemini_model.generate_content(prompt)
                return response.text.strip()
                
        except Exception as e:
            return f"Code review error: {str(e)}"
    
    def _folder_review(self, folder_path="."):
        try:
            import os
            
            files_scanned = 0
            all_code = ""
            file_list = []
            
            code_extensions = ['.py', '.js', '.java', '.cpp', '.c', '.cs', '.php', '.rb', '.go', '.rs', '.kt', '.swift', '.ts', '.jsx', '.tsx', '.vue', '.html', '.css', '.sql', '.sh', '.bat']
            
            for root, dirs, files in os.walk(folder_path):
                for file in files:
                    if any(file.endswith(ext) for ext in code_extensions):
                        file_path = os.path.join(root, file)
                        try:
                            with open(file_path, 'r', encoding='utf-8') as f:
                                code = f.read()
                                all_code += f"\n\n=== {file_path} ===\n{code}"
                                file_list.append(file_path)
                                files_scanned += 1
                        except Exception as e:
                            continue
            
            if not all_code:
                return "No code files found in the specified folder"
            
            prompt = f'''Review {files_scanned} code files. Be extremely brief.

{all_code[:4000]}...

Give only:
1. Main issues
2. Quick fixes

Max 2 lines each.'''
            
            if self.ai_provider == 'groq':
                response = self.groq_client.chat.completions.create(
                    messages=[{"role": "user", "content": prompt}],
                    model="llama-3.1-8b-instant"
                )
                return f"Scanned {files_scanned} code files\n\n" + response.choices[0].message.content.strip()
            else:
                response = self.gemini_model.generate_content(prompt)
                return f"Scanned {files_scanned} code files\n\n" + response.text.strip()
                
        except Exception as e:
            return f"Folder review error: {str(e)}"
    
    def _file_review(self, file_path="a.py"):
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                code_text = f.read()
            
            lines = code_text.split('\n')
            numbered_code = '\n'.join([f'{i+1}: {line}' for i, line in enumerate(lines)])
            
            prompt = f'''Code:\n{numbered_code}\n\nUndefined variable? Answer only: Line 6: z should be i'''
            
            if self.ai_provider == 'groq':
                response = self.groq_client.chat.completions.create(
                    messages=[{"role": "user", "content": prompt}],
                    model="llama-3.1-8b-instant"
                )
                return response.choices[0].message.content.strip()
            else:
                response = self.gemini_model.generate_content(prompt)
                return response.text.strip()
                
        except Exception as e:
            return f"File review error: {str(e)}"
    
    def _live_code_review(self):
        try:
            import threading
            import time
            import os
            from watchdog.observers import Observer
            from watchdog.events import FileSystemEventHandler
            
            class CodeReviewHandler(FileSystemEventHandler):
                def __init__(self, dual_ai_instance):
                    self.dual_ai = dual_ai_instance
                    self.last_check = {}
                    self.file_sizes = {}  # Track file sizes for polling
                    self.corrected_files = {}  # Track corrected files with their content hash
                    self.processing_files = set()  # Track files currently being processed
                    self.start_polling()
                
                def on_modified(self, event):
                    print(f"File modified: {event.src_path}")
                    
                    if event.is_directory:
                        print("Skipping directory")
                        return
                        
                    if not event.src_path.endswith('.py'):
                        print(f"Skipping non-Python file: {event.src_path}")
                        return
                    
                    current_time = time.time()
                    # Check if file is already being processed
                    if event.src_path in self.processing_files:
                        print("Skipping - file already being processed")
                        return
                    
                    if event.src_path in self.last_check:
                        time_diff = current_time - self.last_check[event.src_path]
                        if time_diff < 2.0:  # Increased cooldown to prevent duplicates
                            print(f"Skipping - too soon ({time_diff:.1f}s)")
                            return
                    
                    print(f"Processing file: {event.src_path}")
                    self.last_check[event.src_path] = current_time
                    self.processing_files.add(event.src_path)
                    
                    # Add small delay for file operations
                    time.sleep(0.2)
                    
                    # Process the file inline
                    try:
                        print(f"Starting file processing for: {event.src_path}")
                        
                        # Try multiple times for notepad compatibility
                        code = None
                        for attempt in range(5):  # More attempts for Notepad
                            try:
                                print(f"Reading attempt {attempt + 1}")
                                with open(event.src_path, 'r', encoding='utf-8') as f:
                                    code = f.read()
                                print(f"Successfully read {len(code)} characters")
                                break
                            except (PermissionError, FileNotFoundError, OSError) as e:
                                print(f"Read attempt {attempt + 1} failed: {e}")
                                time.sleep(0.1)  # Shorter delay between attempts
                        
                        if code is None:
                            print("Could not read file after 3 attempts")
                            return
                        
                        if len(code.strip()) < 5:
                            print("File too short, skipping")
                            return
                        
                        print("Checking for syntax errors...")
                        
                        # Check for syntax errors using compile
                        error_msg = None
                        try:
                            compile(code, event.src_path, 'exec')
                            print("Compile check passed")
                        except SyntaxError as e:
                            print(f"üö® Syntax error detected: {e}")
                            error_msg = f"Line {e.lineno}: {e.msg}"
                        except Exception as e:
                            print(f"üö® Other error detected: {e}")
                            error_msg = str(e)
                        
                        # Use AI to find all types of errors
                        if not error_msg:
                            print("Running AI analysis for all error types...")
                            error_msg = self.dual_ai._ai_code_analysis(code)
                            if error_msg:
                                print(f"üö® AI detected error: {error_msg}")
                        
                        if not error_msg:
                            print("‚úÖ No errors found")
                            return
                        
                        # Check if this file was recently corrected with same content
                        import hashlib
                        content_hash = hashlib.md5(code.encode()).hexdigest()
                        if event.src_path in self.corrected_files and self.corrected_files[event.src_path] == content_hash:
                            print("Skipping - file already corrected")
                            return
                        
                        print(f"Showing notification for error: {error_msg}")
                        
                        # Show notification immediately
                        import threading
                        def delayed_notification():
                            time.sleep(0.5)
                            self.dual_ai._show_error_notification(event.src_path, error_msg)
                        
                        threading.Thread(target=delayed_notification, daemon=True).start()
                    
                    except Exception as e:
                        print(f"‚ùå Exception in file processing: {e}")
                        import traceback
                        traceback.print_exc()
                    finally:
                        # Remove from processing set
                        self.processing_files.discard(event.src_path)
                
                def start_polling(self):
                    """Start polling for file changes as fallback for Notepad"""
                    import threading
                    def poll_files():
                        while True:
                            try:
                                import glob
                                for py_file in glob.glob('*.py'):
                                    try:
                                        current_size = os.path.getsize(py_file)
                                        if py_file not in self.file_sizes:
                                            self.file_sizes[py_file] = current_size
                                        elif self.file_sizes[py_file] != current_size:
                                            print(f"Polling detected change in {py_file}")
                                            self.file_sizes[py_file] = current_size
                                            # Create mock event
                                            class MockEvent:
                                                def __init__(self, path):
                                                    self.src_path = path
                                                    self.is_directory = False
                                            self.on_modified(MockEvent(py_file))
                                    except (OSError, FileNotFoundError):
                                        pass
                                time.sleep(1)  # Poll every second
                            except Exception as e:
                                print(f"Polling error: {e}")
                                time.sleep(2)
                    
                    polling_thread = threading.Thread(target=poll_files, daemon=True)
                    polling_thread.start()
                    print("Started file polling for Notepad compatibility")
                
                def on_created(self, event):
                    print(f"File created: {event.src_path}")
                    if not event.is_directory and event.src_path.endswith('.py'):
                        time.sleep(1)
                        self.on_modified(event)
                
                def on_moved(self, event):
                    print(f"File moved: {getattr(event, 'src_path', 'unknown')} -> {getattr(event, 'dest_path', 'unknown')}")
                    if not event.is_directory and hasattr(event, 'dest_path') and event.dest_path.endswith('.py'):
                        time.sleep(1)
                        class MockEvent:
                            def __init__(self, path):
                                self.src_path = path
                                self.is_directory = False
                        self.on_modified(MockEvent(event.dest_path))
                    

            
            self.observer = Observer()
            self.handler = CodeReviewHandler(self)
            self.observer.schedule(self.handler, '.', recursive=True)
            self.observer.start()
            
            print("üîç Live code review started - monitoring Python files")
            print(f"Watching directory: {os.path.abspath('.')}")
            return "Live code review active - will notify about errors and offer fixes"
            
        except Exception as e:
            return f"Live code review error: {str(e)}"
    
    def _ai_code_analysis(self, code):
        """Use AI to analyze code for all types of errors"""
        try:
            lines = code.split('\n')
            numbered_code = '\n'.join([f'{i+1}: {line}' for i, line in enumerate(lines)])
            
            prompt = f'''Check this Python code for CRITICAL errors only:\n{numbered_code}\n\nOnly report:\n- Undefined variables\n- Syntax errors\n- Missing imports that cause errors\n\nIgnore style suggestions, variable naming, and input validation.\n\nIf you find a CRITICAL error, respond with: "Line X: [error]"\nIf no critical errors, respond with: "OK"'''
            
            if self.ai_provider == 'groq':
                response = self.groq_client.chat.completions.create(
                    messages=[{"role": "user", "content": prompt}],
                    model="llama-3.1-8b-instant"
                )
                result = response.choices[0].message.content.strip()
            else:
                response = self.gemini_model.generate_content(prompt)
                result = response.text.strip()
            
            # Check if AI found critical errors
            if 'line' in result.lower() and 'ok' not in result.lower():
                return result
            
            return None
        except Exception as e:
            print(f"AI analysis failed: {e}")
            return None
    
    def _show_error_notification(self, file_path, error_message):
        import os
        import time
        
        title = f"Code Error in {os.path.basename(file_path)}"
        print(f"üö® {title}: {error_message}")
        
        # Simple console notification to avoid crashes
        print(f"üö® {title}: {error_message}")
        
        # Ask for correction
        if self._ask_for_correction(title, error_message):
            self._auto_correct_code(file_path, error_message)
        
    def _ask_for_correction(self, title, message):
        try:
            import tkinter as tk
            from tkinter import messagebox
            import time
            
            # Create root window
            root = tk.Tk()
            root.withdraw()
            root.attributes('-topmost', True)
            root.attributes('-alpha', 0.0)  # Make invisible
            root.deiconify()  # Show window
            root.lift()
            root.focus_force()
            root.update()
            
            # Small delay to ensure window is ready
            time.sleep(0.2)
            
            # Show dialog
            result = messagebox.askyesno(
                "Auto-Fix Code?",
                f"{title}\n\n{message[:200]}\n\nWould you like to automatically fix this error?",
                parent=root
            )
            
            root.destroy()
            print(f"User choice: {'YES' if result else 'NO'}")
            return result
            
        except Exception as e:
            print(f"Dialog error: {e}")
            return False
        
    def _auto_correct_code(self, file_path, error_message):
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                original_code = f.read()
            
            print("Using AI to fix the code...")
            correction_prompt = f'''Fix this Python code error. Return ONLY the corrected code without explanations:\n\nOriginal code:\n{original_code}\n\nError: {error_message}\n\nCorrected code:'''
            
            if self.ai_provider == 'groq':
                response = self.groq_client.chat.completions.create(
                    messages=[{"role": "user", "content": correction_prompt}],
                    model="llama-3.1-8b-instant",
                    temperature=0.1
                )
                corrected_code = response.choices[0].message.content.strip()
            else:
                response = self.gemini_model.generate_content(correction_prompt)
                corrected_code = response.text.strip()
            
            # Clean AI response
            if corrected_code.startswith('```'):
                lines = corrected_code.split('\n')
                corrected_code = '\n'.join(lines[1:-1])
            
            # Create backup
            import datetime
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_path = f"{file_path}.backup_{timestamp}"
            
            with open(backup_path, 'w', encoding='utf-8') as f:
                f.write(original_code)
            print(f"File created: {backup_path}")
            
            # Apply correction
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(corrected_code)
            
            # Mark file as corrected
            import hashlib
            content_hash = hashlib.md5(corrected_code.encode()).hexdigest()
            if hasattr(self, 'handler') and self.handler:
                self.handler.corrected_files[file_path] = content_hash
            
            print(f"‚úÖ Code fixed in {os.path.basename(file_path)}")
            self._show_notification("üéâ Code Fixed!", f"Error corrected in {os.path.basename(file_path)}")
        
        except Exception as e:
            print(f"‚ùå Auto-correction failed: {e}")
            self._show_notification("Auto-Correction Failed", f"Could not fix: {str(e)}")
    
    def _old_auto_correct_code(self, file_path, error_message):
        try:
            import os
            import datetime
            
            with open(file_path, 'r', encoding='utf-8') as f:
                original_code = f.read()
            
            correction_prompt = f'''Fix this Python code. Return ONLY the corrected code:\n\n{original_code}\n\nError: {error_message}'''
            
            if self.ai_provider == 'groq':
                response = self.groq_client.chat.completions.create(
                    messages=[{"role": "user", "content": correction_prompt}],
                    model="llama-3.1-8b-instant",
                    temperature=0.1
                )
                corrected_code = response.choices[0].message.content.strip()
            else:
                response = self.gemini_model.generate_content(correction_prompt)
                corrected_code = response.text.strip()
            
            # Clean markdown
            if corrected_code.startswith('```'):
                lines = corrected_code.split('\n')
                corrected_code = '\n'.join(lines[1:-1])
            
            # Create backup
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_path = f"{file_path}.backup_{timestamp}"
            
            with open(backup_path, 'w', encoding='utf-8') as f:
                f.write(original_code)
            
            # Apply fix
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(corrected_code)
            
            print(f"‚úÖ Code fixed in {os.path.basename(file_path)}")
            self._show_notification("üéâ Code Fixed!", f"Fixed {os.path.basename(file_path)}\nBackup: {os.path.basename(backup_path)}")
        
        except Exception as e:
            print(f"‚ùå Fix failed: {str(e)}")
            self._show_notification("‚ùå Fix Failed", f"Could not fix: {str(e)}")
    
    def _show_notification(self, title, message):
        try:
            import tkinter as tk
            from tkinter import messagebox
            root = tk.Tk()
            root.withdraw()
            root.attributes('-topmost', True)
            messagebox.showinfo(title, message[:300])
            root.destroy()
            print(f"‚úÖ Popup shown: {title}")
        except:
            print(f"üì¢ {title}: {message}")
    
    def _start_live_review(self):
        return self._live_code_review()
    
    def _stop_live_review(self):
        try:
            if hasattr(self, 'observer') and self.observer:
                self.observer.stop()
                self.observer.join()
                print("üõë Live code review stopped")
                return "Live code review stopped"
            return "Live code review not running"
        except Exception as e:
            return f"Error stopping live code review: {str(e)}"
    
    # Voice Gender Control Methods
    def _switch_to_male_voice(self):
        try:
            from engine.voice_gender_control import voice_control
            response = voice_control.switch_to_male()
            return response
        except Exception as e:
            return f"Error switching to male voice: {str(e)}"
    
    def _switch_to_female_voice(self):
        try:
            from engine.voice_gender_control import voice_control
            response = voice_control.switch_to_female()
            return response
        except Exception as e:
            return f"Error switching to female voice: {str(e)}"
    
    def _get_current_voice_gender(self):
        try:
            from engine.voice_gender_control import voice_control
            gender = voice_control.get_current_gender()
            return f"Current voice is set to {gender}"
        except Exception as e:
            return f"Error getting voice status: {str(e)}"
    
    # Mapping Functions
    def _open_maps(self):
        try:
            subprocess.Popen('start https://maps.google.com', shell=True)
            return "Google Maps opened"
        except:
            return "Failed to open maps"
    
    def _find_location(self, location=""):
        try:
            import urllib.parse
            if not location:
                location = "current location"
            encoded_location = urllib.parse.quote(location)
            url = f"https://maps.google.com/maps?q={encoded_location}"
            subprocess.Popen(f'start {url}', shell=True)
            return f"Searching for {location} on maps"
        except:
            return "Failed to search location"
    
    def _get_directions(self, destination=""):
        try:
            import urllib.parse
            if not destination:
                return "Please specify a destination"
            encoded_dest = urllib.parse.quote(destination)
            url = f"https://maps.google.com/maps/dir//{encoded_dest}"
            subprocess.Popen(f'start {url}', shell=True)
            return f"Getting directions to {destination}"
        except:
            return "Failed to get directions"
    
    def _nearby_places(self, place_type="restaurants"):
        try:
            import urllib.parse
            encoded_type = urllib.parse.quote(f"{place_type} near me")
            url = f"https://maps.google.com/maps/search/{encoded_type}"
            subprocess.Popen(f'start {url}', shell=True)
            return f"Finding nearby {place_type}"
        except:
            return "Failed to find nearby places"
    
    def _traffic_info(self):
        try:
            url = "https://maps.google.com/maps/@?layer=t"
            subprocess.Popen(f'start {url}', shell=True)
            return "Showing traffic information"
        except:
            return "Failed to show traffic info"
    
    def _map_satellite(self):
        try:
            url = "https://maps.google.com/maps/@?layer=s"
            subprocess.Popen(f'start {url}', shell=True)
            return "Switched to satellite view"
        except:
            return "Failed to switch to satellite view"
    
    def _map_terrain(self):
        try:
            url = "https://maps.google.com/maps/@?layer=p"
            subprocess.Popen(f'start {url}', shell=True)
            return "Switched to terrain view"
        except:
            return "Failed to switch to terrain view"
    
    def _save_location(self, location=""):
        try:
            if not location:
                return "Please specify a location to save"
            # Save to a simple text file
            with open('saved_locations.txt', 'a', encoding='utf-8') as f:
                f.write(f"{location}\n")
            return f"Location '{location}' saved"
        except:
            return "Failed to save location"
    
    def _my_location(self):
        try:
            url = "https://maps.google.com/maps/@?layer=c"
            subprocess.Popen(f'start {url}', shell=True)
            return "Showing your current location"
        except:
            return "Failed to show current location"

    def _dictate_to_file(self, query=""):
        """Voice-to-text dictation to file"""
        try:
            import speech_recognition as sr
            import re
            import os
            
            filename = "dictation.txt"
            file_match = re.search(r'to file\s+([^\s]+)', query.lower())
            if file_match:
                filename = file_match.group(1).strip()
                if not filename.endswith('.txt'):
                    filename += '.txt'
            
            mode = "append" if "append" in query.lower() else "write"
            
            r = sr.Recognizer()
            
            with sr.Microphone() as source:
                print("üé§ Adjusting for ambient noise...")
                r.adjust_for_ambient_noise(source)
                print(f"üé§ Dictating to {filename}. Say 'stop dictation' to finish...")
                
                text_content = ""
                
                while True:
                    try:
                        audio = r.listen(source, timeout=1, phrase_time_limit=5)
                        text = r.recognize_google(audio)
                        
                        if "stop dictation" in text.lower():
                            break
                        
                        text = self._process_punctuation_commands(text)
                        text_content += text + " "
                        print(f"üìù {text}")
                        
                    except sr.WaitTimeoutError:
                        continue
                    except sr.UnknownValueError:
                        continue
                    except sr.RequestError as e:
                        return f"Speech recognition error: {e}"
            
            if text_content.strip():
                if mode == "append" and os.path.exists(filename):
                    with open(filename, 'a', encoding='utf-8') as f:
                        f.write("\n" + text_content.strip())
                else:
                    with open(filename, 'w', encoding='utf-8') as f:
                        f.write(text_content.strip())
                
                return f"üìù Dictation saved to {filename} ({len(text_content.split())} words)"
            else:
                return "No speech detected"
                
        except ImportError:
            return "Speech recognition not installed. Run: pip install SpeechRecognition pyaudio"
        except Exception as e:
            return f"Dictation failed: {e}"

    def _dictate_to_document(self, query=""):
        """Advanced voice-to-text for formatted documents"""
        try:
            import speech_recognition as sr
            import re
            from datetime import datetime
            
            doc_type = "word"
            if "google docs" in query.lower():
                doc_type = "gdocs"
            elif "email" in query.lower():
                doc_type = "email"
            
            r = sr.Recognizer()
            
            with sr.Microphone() as source:
                print("üé§ Adjusting for ambient noise...")
                r.adjust_for_ambient_noise(source)
                print(f"üé§ Dictating to {doc_type}. Say formatting commands like 'bold this', 'new paragraph'...")
                
                document_content = []
                current_text = ""
                
                while True:
                    try:
                        audio = r.listen(source, timeout=1, phrase_time_limit=5)
                        text = r.recognize_google(audio)
                        
                        if "stop dictation" in text.lower():
                            break
                        
                        if self._is_formatting_command(text):
                            formatted_text = self._process_formatting_command(text, current_text)
                            document_content.append(formatted_text)
                            current_text = ""
                        else:
                            text = self._process_punctuation_commands(text)
                            current_text += text + " "
                            print(f"üìù {text}")
                        
                    except sr.WaitTimeoutError:
                        continue
                    except sr.UnknownValueError:
                        continue
                    except sr.RequestError as e:
                        return f"Speech recognition error: {e}"
            
            if current_text.strip():
                document_content.append(current_text.strip())
            
            if document_content:
                timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                
                if doc_type == "email":
                    filename = f"email_draft_{timestamp}.txt"
                    content = self._format_as_email(document_content)
                elif doc_type == "gdocs":
                    filename = f"gdocs_draft_{timestamp}.txt"
                    content = self._format_as_document(document_content)
                else:
                    filename = f"document_{timestamp}.docx"
                    content = self._format_as_document(document_content)
                
                with open(filename, 'w', encoding='utf-8') as f:
                    f.write(content)
                
                word_count = len(' '.join(document_content).split())
                return f"üìÑ Document saved to {filename} ({word_count} words)\nFormatting commands processed"
            else:
                return "No content dictated"
                
        except ImportError:
            return "Speech recognition not installed. Run: pip install SpeechRecognition pyaudio"
        except Exception as e:
            return f"Document dictation failed: {e}"
    def _dictate_to_file(self, query=""):
        """Voice-to-text dictation to file"""
        try:
            import speech_recognition as sr
            import re
            import os
            
            filename = "dictation.txt"
            file_match = re.search(r'to file\s+([^\s]+)', query.lower())
            if file_match:
                filename = file_match.group(1).strip()
                if not filename.endswith('.txt'):
                    filename += '.txt'
            
            mode = "append" if "append" in query.lower() else "write"
            
            r = sr.Recognizer()
            
            with sr.Microphone() as source:
                print("üé§ Adjusting for ambient noise...")
                r.adjust_for_ambient_noise(source)
                print(f"üé§ Dictating to {filename}. Say 'stop dictation' to finish...")
                
                text_content = ""
                
                while True:
                    try:
                        audio = r.listen(source, timeout=1, phrase_time_limit=5)
                        text = r.recognize_google(audio)
                        
                        if "stop dictation" in text.lower():
                            break
                        
                        text = self._process_punctuation_commands(text)
                        text_content += text + " "
                        print(f"üìù {text}")
                        
                    except sr.WaitTimeoutError:
                        continue
                    except sr.UnknownValueError:
                        continue
                    except sr.RequestError as e:
                        return f"Speech recognition error: {e}"
            
            if text_content.strip():
                if mode == "append" and os.path.exists(filename):
                    with open(filename, 'a', encoding='utf-8') as f:
                        f.write("\n" + text_content.strip())
                else:
                    with open(filename, 'w', encoding='utf-8') as f:
                        f.write(text_content.strip())
                
                return f"üìù Dictation saved to {filename} ({len(text_content.split())} words)"
            else:
                return "No speech detected"
                
        except ImportError:
            return "Speech recognition not installed. Run: pip install SpeechRecognition pyaudio"
        except Exception as e:
            return f"Dictation failed: {e}"

    def _dictate_to_document(self, query=""):
        """Advanced voice-to-text for formatted documents"""
        try:
            import speech_recognition as sr
            import re
            from datetime import datetime
            
            doc_type = "word"
            if "google docs" in query.lower():
                doc_type = "gdocs"
            elif "email" in query.lower():
                doc_type = "email"
            
            r = sr.Recognizer()
            
            with sr.Microphone() as source:
                print("üé§ Adjusting for ambient noise...")
                r.adjust_for_ambient_noise(source)
                print(f"üé§ Dictating to {doc_type}. Say formatting commands like 'bold this', 'new paragraph'...")
                
                document_content = []
                current_text = ""
                
                while True:
                    try:
                        audio = r.listen(source, timeout=1, phrase_time_limit=5)
                        text = r.recognize_google(audio)
                        
                        if "stop dictation" in text.lower():
                            break
                        
                        if self._is_formatting_command(text):
                            formatted_text = self._process_formatting_command(text, current_text)
                            document_content.append(formatted_text)
                            current_text = ""
                        else:
                            text = self._process_punctuation_commands(text)
                            current_text += text + " "
                            print(f"üìù {text}")
                        
                    except sr.WaitTimeoutError:
                        continue
                    except sr.UnknownValueError:
                        continue
                    except sr.RequestError as e:
                        return f"Speech recognition error: {e}"
            
            if current_text.strip():
                document_content.append(current_text.strip())
            
            if document_content:
                timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                
                if doc_type == "email":
                    filename = f"email_draft_{timestamp}.txt"
                    content = self._format_as_email(document_content)
                elif doc_type == "gdocs":
                    filename = f"gdocs_draft_{timestamp}.txt"
                    content = self._format_as_document(document_content)
                else:
                    filename = f"document_{timestamp}.docx"
                    content = self._format_as_document(document_content)
                
                with open(filename, 'w', encoding='utf-8') as f:
                    f.write(content)
                
                word_count = len(' '.join(document_content).split())
                return f"üìÑ Document saved to {filename} ({word_count} words)\nFormatting commands processed"
            else:
                return "No content dictated"
                
        except ImportError:
            return "Speech recognition not installed. Run: pip install SpeechRecognition pyaudio"
        except Exception as e:
            return f"Document dictation failed: {e}"

    def _process_punctuation_commands(self, text):
        """Process voice punctuation commands"""
        # More comprehensive punctuation mapping
        punctuation_map = {
            ' period': '.',
            ' comma': ',',
            ' question mark': '?',
            ' exclamation point': '!',
            ' exclamation mark': '!',
            ' colon': ':',
            ' semicolon': ';',
            ' new line': '\n',
            ' new paragraph': '\n\n',
            ' dot': '.',
            ' full stop': '.'
        }
    
        # Process punctuation commands (case insensitive)
        for command, punctuation in punctuation_map.items():
            text = text.replace(command, punctuation)
            text = text.replace(command.title(), punctuation)
            text = text.replace(command.upper(), punctuation)
    
        return text

    def _is_formatting_command(self, text):
        """Check if text contains formatting commands"""
        formatting_commands = [
            'bold this', 'italic this', 'underline this',
            'bullet point', 'numbered list', 'new paragraph',
            'heading', 'title', 'center this'
        ]
    
        return any(cmd in text.lower() for cmd in formatting_commands)

    def _process_formatting_command(self, command, text):
        """Process formatting commands and return formatted text"""
        command_lower = command.lower()
    
        if 'bold this' in command_lower:
            return f"**{text.strip()}**"
        elif 'italic this' in command_lower:
            return f"*{text.strip()}*"
        elif 'underline this' in command_lower:
            return f"_{text.strip()}_"
        elif 'bullet point' in command_lower:
            return f"‚Ä¢ {text.strip()}"
        elif 'numbered list' in command_lower:
            return f"1. {text.strip()}"
        elif 'heading' in command_lower:
            return f"# {text.strip()}"
        elif 'title' in command_lower:
            return f"## {text.strip()}"
        elif 'center this' in command_lower:
            return f"<center>{text.strip()}</center>"
        else:
            return text

    def _format_as_email(self, content_list):
        """Format content as email"""
        email_content = "Subject: [Your Subject]\n\n"
        email_content += "Dear [Recipient],\n\n"
    
        for content in content_list:
            email_content += content + "\n\n"
    
        email_content += "Best regards,\n[Your Name]"
        return email_content

    def _format_as_document(self, content_list):
        """Format content as document"""
        document_content = ""
    
        for content in content_list:
            document_content += content + "\n\n"
    
        return document_content.strip()


    def _process_formatting_command(self, command, text):
        """Process formatting commands and return formatted text"""
        command_lower = command.lower()
    
        if 'bold this' in command_lower:
            return f"**{text.strip()}**"
        elif 'italic this' in command_lower:
            return f"*{text.strip()}*"
        elif 'underline this' in command_lower:
            return f"_{text.strip()}_"
        elif 'bullet point' in command_lower:
            return f"‚Ä¢ {text.strip()}"
        elif 'numbered list' in command_lower:
            return f"1. {text.strip()}"
        elif 'heading' in command_lower:
            return f"# {text.strip()}"
        elif 'title' in command_lower:
            return f"## {text.strip()}"
        elif 'center this' in command_lower:
            return f"<center>{text.strip()}</center>"
        else:
            return text

    def _format_as_email(self, content_list):
        """Format content as email"""
        email_content = "Subject: [Your Subject]\n\n"
        email_content += "Dear [Recipient],\n\n"
    
        for content in content_list:
            email_content += content + "\n\n"
    
        email_content += "Best regards,\n[Your Name]"
        return email_content

    def _format_as_document(self, content_list):
        """Format content as document"""
        document_content = ""
    
        for content in content_list:
            document_content += content + "\n\n"
    
        return document_content.strip()

    def _simple_fallback_match(self, query):
        """Simple fallback matching for basic commands"""
        query_lower = query.lower()
        
        # Basic command mappings
        if 'open' in query_lower:
            if 'chrome' in query_lower:
                return 'chrome'
            elif 'notepad' in query_lower:
                return 'notepad'
            elif 'calculator' in query_lower:
                return 'calculator'
        
        if 'volume' in query_lower:
            if 'up' in query_lower:
                return 'volume_up'
            elif 'down' in query_lower:
                return 'volume_down'
        
        if 'brightness' in query_lower:
            if 'up' in query_lower:
                return 'brightness_up'
            elif 'down' in query_lower:
                return 'brightness_down'
        
        return None

    def _pause_dictation(self):
        """Pause dictation mode"""
        try:
            self.dictation_paused = True
            return "Dictation paused"
        except Exception as e:
            return f"Failed to pause dictation: {e}"
    
    def _resume_dictation(self):
        """Resume dictation mode"""
        try:
            self.dictation_paused = False
            return "Dictation resumed"
        except Exception as e:
            return f"Failed to resume dictation: {e}"
    def _start_dictation(self, query=""):
        """Start dictation mode - opens app and starts listening"""
        try:
            import speech_recognition as sr
            import pyautogui
            import time
            
            # Determine which app to open
            self.current_app = "notepad"  # default
            
            if "notepad" in query.lower():
                self.current_app = "notepad"
                subprocess.Popen('notepad', shell=True)
                time.sleep(2)
            elif "word" in query.lower():
                self.current_app = "word"
                subprocess.Popen('start winword', shell=True)
                time.sleep(3)  # Word takes longer to load
                # Create new document in Word
                pyautogui.hotkey('ctrl', 'n')
                time.sleep(1)
                pyautogui.press('enter')
                time.sleep(1)
                pyautogui.press('enter')   # Press enter after ctrl+n
            elif "chrome" in query.lower():
                self.current_app = "chrome"
                subprocess.Popen('start chrome', shell=True)
                time.sleep(2)
            elif "anywhere" in query.lower() or not query.strip():
                self.current_app = "anywhere"
                # Don't open any specific app, just start dictating
            else:
                # If no specific app mentioned, open notepad
                self.current_app = "notepad"
                subprocess.Popen('notepad', shell=True)
                time.sleep(2)
            
            # Start dictation
            return self._dictate_anywhere()
            
        except Exception as e:
            return f"Failed to start dictation: {e}"
    
    def _auto_save_file(self):
        """Auto-save the dictated file"""
        try:
            # Only save if we opened notepad or word
            if hasattr(self, 'current_app') and self.current_app in ['notepad', 'word']:
                from datetime import datetime
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                
                if self.current_app == 'word':
                    filename = f"dictation_{timestamp}"
                else:
                    filename = f"dictation_{timestamp}"
                
                # Press Ctrl+S to save
                pyautogui.hotkey('ctrl', 's')
                time.sleep(2)
                
                # Type filename and save
                pyautogui.typewrite(filename)
                time.sleep(1)
                pyautogui.press('enter')
                
                print(f"üíæ File saved as {filename}")
        except Exception as e:
            print(f"Save error: {e}")
    
    def _stop_dictation(self):
        """Stop dictation mode"""
        try:
            self.dictation_active = False
            return "Dictation stopped"
        except Exception as e:
            return f"Failed to stop dictation: {e}"
    
    def _dictate_anywhere(self, query=""):
        """Universal dictation that works in any application"""
        try:
            import speech_recognition as sr
            import pyautogui
            import time
            
            r = sr.Recognizer()
            # Improve recognition settings
            r.energy_threshold = 300
            r.dynamic_energy_threshold = True
            r.pause_threshold = 0.8
            r.phrase_threshold = 0.3
            
            self.dictation_active = True
            
            with sr.Microphone() as source:
                print("üé§ Adjusting for ambient noise...")
                r.adjust_for_ambient_noise(source, duration=2)
                print("üé§ Universal dictation started. Say 'stop dictation' to finish...")
                print("üìù Speaking will type directly into the active application")
                
                while self.dictation_active:
                    try:
                        # Adjust listening parameters for better recognition
                        audio = r.listen(source, timeout=3, phrase_time_limit=6)
                        text = r.recognize_google(audio, language='en-US', show_all=False)
                        
                        # Check for control commands
                        text_lower = text.lower()
                        if any(stop_phrase in text_lower for stop_phrase in ["stop dictation", "end dictation", "finish dictation", "stop writing", "stop typing"]):
                            self.dictation_active = False
                            print("üõë Dictation stopped")
                            # Auto-save the file
                            self._auto_save_file()
                            break
                        # Automation features
                        elif "press enter" in text_lower or "new line" in text_lower:
                            pyautogui.press('enter')
                            print("‚Üµ Enter pressed")
                            continue
                        elif "press tab" in text_lower:
                            pyautogui.press('tab')
                            print("‚á• Tab pressed")
                            continue
                        elif "press space" in text_lower:
                            pyautogui.press('space')
                            print("‚ê£ Space pressed")
                            continue
                        elif "backspace" in text_lower or "delete back" in text_lower:
                            pyautogui.press('backspace')
                            print("‚å´ Backspace pressed")
                            continue
                        elif "delete" in text_lower and "back" not in text_lower:
                            pyautogui.press('delete')
                            print("‚å¶ Delete pressed")
                            continue
                        elif any(pause_phrase in text_lower for pause_phrase in ["pause dictation", "pause typing"]):
                            if not hasattr(self, 'dictation_paused'):
                                self.dictation_paused = False
                            self.dictation_paused = True
                            print("‚è∏Ô∏è Dictation paused - say 'resume dictation' to continue")
                            continue
                        elif any(resume_phrase in text_lower for resume_phrase in ["resume dictation", "continue dictation"]):
                            if not hasattr(self, 'dictation_paused'):
                                self.dictation_paused = False
                            if self.dictation_paused:
                                self.dictation_paused = False
                                print("‚ñ∂Ô∏è Dictation resumed")
                            continue
                        
                        # Skip typing if paused
                        if hasattr(self, 'dictation_paused') and self.dictation_paused:
                            continue
                        
                        # Clean up the text
                        text = text.strip()
                        if len(text) < 2:  # Skip very short utterances
                            continue
                            
                        # Process punctuation commands
                        text = self._process_punctuation_commands(text)
                        
                        # Type the text with proper spacing
                        if text:
                            pyautogui.typewrite(text + " ", interval=0.01)
                            print(f"üìù Typed: {text}")
                        
                    except sr.WaitTimeoutError:
                        continue
                    except sr.UnknownValueError:
                        # Don't print for every unrecognized audio to reduce noise
                        continue
                    except sr.RequestError as e:
                        print(f"Speech service error: {e}")
                        return f"Speech recognition error: {e}"
                    except Exception as e:
                        print(f"Typing error: {e}")
                        continue
            
            return "üìù Universal dictation completed"
                
        except ImportError:
            return "Speech recognition not installed. Run: pip install SpeechRecognition pyaudio"
        except Exception as e:
            return f"Universal dictation failed: {e}"
        

    def _find_file(self):
        """Find files by name in specified directory"""
        try:
            query = self._current_query.lower()
            
            # Parse directory from query
            directory = self._get_directory(query)
            
            # Get search pattern
            pattern = simpledialog.askstring("Find File", "Enter filename or pattern to search for:")
            if not pattern:
                return "Search cancelled"
            
            found_files = []
            for root, dirs, files in os.walk(directory):
                for file in files:
                    if pattern.lower() in file.lower():
                        found_files.append(os.path.join(root, file))
            
            if found_files:
                return f"Found {len(found_files)} files:\n" + "\n".join(found_files[:10])
            else:
                return f"No files found matching '{pattern}' in {directory}"
                
        except Exception as e:
            return f"Error finding files: {str(e)}"
    
    def _find_duplicates(self):
        """Find duplicate files in specified directory"""
        try:
            import hashlib
            query = self._current_query.lower()
            directory = self._get_directory(query)
            
            file_hashes = {}
            duplicates = []
            
            for root, dirs, files in os.walk(directory):
                for file in files:
                    file_path = os.path.join(root, file)
                    try:
                        with open(file_path, 'rb') as f:
                            file_hash = hashlib.md5(f.read()).hexdigest()
                        
                        if file_hash in file_hashes:
                            duplicates.append((file_path, file_hashes[file_hash]))
                        else:
                            file_hashes[file_hash] = file_path
                    except:
                        continue
            
            if duplicates:
                result = f"Found {len(duplicates)} duplicate file pairs:\n"
                for dup in duplicates[:5]:
                    result += f"Duplicate: {dup[0]} = {dup[1]}\n"
                return result
            else:
                return f"No duplicate files found in {directory}"
                
        except Exception as e:
            return f"Error finding duplicates: {str(e)}"
    
    def _find_large_files(self):
        """Find large files in specified directory"""
        try:
            query = self._current_query.lower()
            directory = self._get_directory(query)
            
            large_files = []
            size_limit = 100 * 1024 * 1024  # 100MB
            
            for root, dirs, files in os.walk(directory):
                for file in files:
                    file_path = os.path.join(root, file)
                    try:
                        size = os.path.getsize(file_path)
                        if size > size_limit:
                            large_files.append((file_path, size))
                    except:
                        continue
            
            if large_files:
                large_files.sort(key=lambda x: x[1], reverse=True)
                result = f"Found {len(large_files)} large files (>100MB):\n"
                for file_path, size in large_files[:10]:
                    size_mb = size / (1024 * 1024)
                    result += f"{file_path} - {size_mb:.1f}MB\n"
                return result
            else:
                return f"No large files found in {directory}"
                
        except Exception as e:
            return f"Error finding large files: {str(e)}"
    
    def _find_empty_folders(self):
        """Find empty folders in specified directory"""
        try:
            query = self._current_query.lower()
            directory = self._get_directory(query)
            
            empty_folders = []
            
            for root, dirs, files in os.walk(directory, topdown=False):
                for dir_name in dirs:
                    dir_path = os.path.join(root, dir_name)
                    try:
                        if not os.listdir(dir_path):
                            empty_folders.append(dir_path)
                    except:
                        continue
            
            if empty_folders:
                return f"Found {len(empty_folders)} empty folders:\n" + "\n".join(empty_folders[:10])
            else:
                return f"No empty folders found in {directory}"
                
        except Exception as e:
            return f"Error finding empty folders: {str(e)}"
    
    def _get_file_info(self):
        """Get detailed file information"""
        try:
            query = self._current_query.lower()
            directory = self._get_directory(query)
            
            file_name = simpledialog.askstring("File Info", "Enter filename:")
            if not file_name:
                return "Operation cancelled"
            
            file_path = os.path.join(directory, file_name)
            
            if not os.path.exists(file_path):
                return f"File not found: {file_path}"
            
            import time
            stat = os.stat(file_path)
            
            info = f"File Information for {file_name}:\n"
            info += f"Path: {file_path}\n"
            info += f"Size: {stat.st_size} bytes ({stat.st_size / (1024*1024):.2f} MB)\n"
            info += f"Created: {time.ctime(stat.st_ctime)}\n"
            info += f"Modified: {time.ctime(stat.st_mtime)}\n"
            info += f"Accessed: {time.ctime(stat.st_atime)}\n"
            
            return info
            
        except Exception as e:
            return f"Error getting file info: {str(e)}"
    
    def _backup_folder(self):
        """Backup a folder in specified location"""
        try:
            import shutil
            from datetime import datetime
            
            query = self._current_query.lower()
            
            # Get folder to backup
            folder_path = simpledialog.askstring("Backup Folder", "Enter folder path to backup:")
            if not folder_path:
                return "Backup cancelled"
            
            # Handle relative paths and common names
            if not os.path.isabs(folder_path):
                folder_path = os.path.join(self._get_directory(query), folder_path)
            
            if not os.path.exists(folder_path):
                return f"Folder not found: {folder_path}"
            
            # Get backup location from query or use same directory
            backup_dir = self._get_directory(query) if 'in ' in query else os.path.dirname(folder_path)
            
            # Create backup with timestamp
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_name = f"{os.path.basename(folder_path)}_backup_{timestamp}"
            backup_path = os.path.join(backup_dir, backup_name)
            
            shutil.copytree(folder_path, backup_path)
            return f"Folder backed up to: {backup_path}"
            
        except Exception as e:
            return f"Error backing up folder: {str(e)}"
        


    
    def _search_content(self):
        """Search inside files for content"""
        try:
            query = self._current_query.lower()
            directory = self._get_directory(query)
            
            search_term = simpledialog.askstring("Content Search", "Enter text to search for:")
            if not search_term:
                return "Search cancelled"
            
            results = []
            for root, dirs, files in os.walk(directory):
                for file in files:
                    file_path = os.path.join(root, file)
                    try:
                        if file.lower().endswith(('.txt', '.py', '.js', '.html', '.css', '.md', '.json', '.xml')):
                            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                                content = f.read()
                                if search_term.lower() in content.lower():
                                    results.append(file_path)
                        elif file.lower().endswith('.pdf'):
                            try:
                                import PyPDF2
                                with open(file_path, 'rb') as f:
                                    reader = PyPDF2.PdfReader(f)
                                    text = ''.join(page.extract_text() for page in reader.pages)
                                    if search_term.lower() in text.lower():
                                        results.append(file_path)
                            except:
                                pass
                    except:
                        continue
            
            if results:
                return f"Found '{search_term}' in {len(results)} files:\n" + "\n".join(results[:10])
            else:
                return f"No files found containing '{search_term}'"
                
        except Exception as e:
            return f"Error searching content: {str(e)}"
    
    def _find_similar_files(self):
        """Find files with similar content"""
        try:
            import difflib
            query = self._current_query.lower()
            directory = self._get_directory(query)
            
            file_contents = {}
            for root, dirs, files in os.walk(directory):
                for file in files:
                    if file.lower().endswith(('.txt', '.py', '.js', '.html', '.css', '.md')):
                        file_path = os.path.join(root, file)
                        try:
                            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                                file_contents[file_path] = f.read()
                        except:
                            continue
            
            similar_pairs = []
            files = list(file_contents.keys())
            for i, file1 in enumerate(files):
                for file2 in files[i+1:]:
                    similarity = difflib.SequenceMatcher(None, file_contents[file1], file_contents[file2]).ratio()
                    if similarity > 0.7:
                        similar_pairs.append((file1, file2, similarity))
            
            if similar_pairs:
                result = f"Found {len(similar_pairs)} similar file pairs:\n"
                for file1, file2, sim in similar_pairs[:5]:
                    result += f"{sim:.1%} similar: {os.path.basename(file1)} ‚Üî {os.path.basename(file2)}\n"
                return result
            else:
                return "No similar files found"
                
        except Exception as e:
            return f"Error finding similar files: {str(e)}"
    
    def _suggest_folder(self):
        """Suggest folder based on file content"""
        try:
            file_path = simpledialog.askstring("Smart Folder", "Enter file path to analyze:")
            if not file_path:
                return "Operation cancelled"
            
            if not os.path.exists(file_path):
                return f"File not found: {file_path}"
            
            suggestions = []
            file_ext = os.path.splitext(file_path)[1].lower()
            
            # Extension-based suggestions
            ext_map = {
                '.py': 'Code/Python', '.js': 'Code/JavaScript', '.html': 'Web/HTML',
                '.pdf': 'Documents/PDFs', '.docx': 'Documents/Word', '.xlsx': 'Documents/Excel',
                '.jpg': 'Images/Photos', '.png': 'Images/Graphics', '.mp4': 'Media/Videos',
                '.mp3': 'Media/Audio', '.zip': 'Archives', '.exe': 'Programs'
            }
            
            if file_ext in ext_map:
                suggestions.append(ext_map[file_ext])
            
            # Content-based suggestions
            try:
                if file_ext in ['.txt', '.py', '.js', '.html']:
                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                        content = f.read().lower()
                        if 'import' in content or 'function' in content:
                            suggestions.append('Code/Scripts')
                        elif 'todo' in content or 'task' in content:
                            suggestions.append('Tasks/Notes')
                        elif 'project' in content:
                            suggestions.append('Projects')
            except:
                pass
            
            if suggestions:
                return f"Suggested folders for {os.path.basename(file_path)}:\n" + "\n".join(f"‚Ä¢ {s}" for s in suggestions)
            else:
                return f"No specific folder suggestions for {os.path.basename(file_path)}"
                
        except Exception as e:
            return f"Error suggesting folder: {str(e)}"
    
    def _map_file_relationships(self):
        """Map relationships between files"""
        try:
            query = self._current_query.lower()
            directory = self._get_directory(query)
            
            relationships = {}
            
            for root, dirs, files in os.walk(directory):
                for file in files:
                    file_path = os.path.join(root, file)
                    relationships[file_path] = {'imports': [], 'references': [], 'similar_name': []}
                    
                    try:
                        if file.lower().endswith(('.py', '.js', '.html', '.css')):
                            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                                content = f.read()
                                
                                # Find imports/includes
                                for other_file in files:
                                    if other_file != file and other_file.replace('.', '') in content:
                                        relationships[file_path]['references'].append(other_file)
                                
                                # Find similar names
                                base_name = os.path.splitext(file)[0]
                                for other_file in files:
                                    if other_file != file and base_name in other_file:
                                        relationships[file_path]['similar_name'].append(other_file)
                    except:
                        continue
            
            result = "File Relationships:\n"
            for file_path, relations in relationships.items():
                if any(relations.values()):
                    result += f"\n{os.path.basename(file_path)}:\n"
                    if relations['references']:
                        result += f"  References: {', '.join(relations['references'])}\n"
                    if relations['similar_name']:
                        result += f"  Similar names: {', '.join(relations['similar_name'])}\n"
            
            return result if len(result) > 20 else "No file relationships found"
                
        except Exception as e:
            return f"Error mapping relationships: {str(e)}"
        



    def _search_google(self, query=""):
        """Search Google directly with query"""
        try:
            import webbrowser
            import urllib.parse
            
            # Extract search term from current query if available
            if hasattr(self, '_current_query') and self._current_query:
                import re
                search_query = self._current_query.lower()
                
                # Remove "search google" or "google search" from the query
                search_query = re.sub(r'(?:search\s+google|google\s+search)\s*', '', search_query)
                
                # If there's remaining text, use it as search term
                if search_query.strip():
                    query = search_query.strip()
            
            if not query:
                query = "python programming"  # Default search
            
            # Create Google search URL
            search_url = f"https://www.google.com/search?q={urllib.parse.quote(query)}"
            webbrowser.open(search_url)
            
            return f"Searching Google for: {query}"
            
        except Exception as e:
            return f"Google search failed: {str(e)}"
        

    def _search_images(self, query=""):
        """Search Google Images"""
        try:
            import webbrowser
            import urllib.parse
            
            if hasattr(self, '_current_query') and self._current_query:
                import re
                search_query = self._current_query.lower()
                search_query = re.sub(r'(?:search\s+(?:for\s+)?images?|images?\s+search)\s*', '', search_query)
                if search_query.strip():
                    query = search_query.strip()
            
            if not query:
                query = "nature"
            
            search_url = f"https://www.google.com/search?q={urllib.parse.quote(query)}&tbm=isch"
            webbrowser.open(search_url)
            return f"Searching images for: {query}"
            
        except Exception as e:
            return f"Image search failed: {str(e)}"

    def _search_gifs(self, query=""):
        """Search Google for GIFs"""
        try:
            import webbrowser
            import urllib.parse
            
            if hasattr(self, '_current_query') and self._current_query:
                import re
                search_query = self._current_query.lower()
                search_query = re.sub(r'(?:search\s+(?:for\s+)?gifs?|gifs?\s+search)\s*', '', search_query)
                if search_query.strip():
                    query = search_query.strip()
            
            if not query:
                query = "funny"
            
            search_url = f"https://www.google.com/search?q={urllib.parse.quote(query)}+gif&tbm=isch&tbs=itp:animated"
            webbrowser.open(search_url)
            return f"Searching GIFs for: {query}"
            
        except Exception as e:
            return f"GIF search failed: {str(e)}"
        

    def _copy_webpage_link(self):
        """Copy current webpage URL to clipboard"""
        try:
            pyautogui.hotkey('ctrl', 'l')
            time.sleep(0.2)
            pyautogui.hotkey('ctrl', 'c')
            pyautogui.press('escape')
            return "Webpage link copied to clipboard"
        except Exception as e:
            return f"Failed to copy link: {str(e)}"

    def _translate_webpage(self):
        """Translate current webpage using Google Translate"""
        try:
            pyautogui.hotkey('ctrl', 'l')
            time.sleep(0.2)
            pyautogui.hotkey('ctrl', 'c')
            time.sleep(0.2)
            
            import pyperclip
            current_url = pyperclip.paste()
            
            if current_url and current_url.startswith('http'):
                import webbrowser
                import urllib.parse
                translate_url = f"https://translate.google.com/translate?sl=auto&tl=en&u={urllib.parse.quote(current_url)}"
                webbrowser.open(translate_url)
                return "Opening webpage translation"
            else:
                return "No valid webpage URL found"
                
        except Exception as e:
            return f"Translation failed: {str(e)}"


    def _check_website_status(self):
        """Check if a website is up or down"""
        try:
            import re
            if hasattr(self, '_current_query') and self._current_query:
                query = self._current_query.lower()
                # Extract website from query
                match = re.search(r'(?:check|status|up)\s+(?:website\s+)?([^\s]+)', query)
                if match:
                    website = match.group(1)
                    if not website.startswith('http'):
                        website = f"https://{website}"
                    
                    response = requests.get(website, timeout=5)
                    if response.status_code == 200:
                        return f"Website {website} is UP (Status: {response.status_code})"
                    else:
                        return f"Website {website} returned status: {response.status_code}"
                else:
                    return "Please specify a website to check"
            return "Please specify a website to check"
        except Exception as e:
            return f"Website appears to be DOWN or unreachable: {str(e)}"

    def _play_radio(self):
        """Play online radio stations"""
        try:
            import webbrowser
            if hasattr(self, '_current_query') and self._current_query:
                query = self._current_query.lower()
                if 'bbc' in query:
                    webbrowser.open("https://www.bbc.co.uk/sounds/play/live:bbc_radio_one")
                elif 'npr' in query:
                    webbrowser.open("https://www.npr.org/player/live/500005/")
                elif 'classical' in query:
                    webbrowser.open("https://www.classicfm.com/radio/live/")
                else:
                    webbrowser.open("https://radio.garden/")
            else:
                webbrowser.open("https://radio.garden/")
            return "Opening online radio"
        except Exception as e:
            return f"Radio playback failed: {str(e)}"

    def _play_podcast(self):
        """Play online podcasts"""
        try:
            import webbrowser
            if hasattr(self, '_current_query') and self._current_query:
                query = self._current_query.lower()
                if 'spotify' in query:
                    webbrowser.open("https://open.spotify.com/genre/podcasts-web")
                elif 'apple' in query:
                    webbrowser.open("https://podcasts.apple.com/")
                else:
                    webbrowser.open("https://www.google.com/podcasts")
            else:
                webbrowser.open("https://www.google.com/podcasts")
            return "Opening podcast platform"
        except Exception as e:
            return f"Podcast playback failed: {str(e)}"

    def _get_weekday(self):
        try:
            return datetime.now().strftime('%A')
        except:
            return "Could not get weekday"
    
    def _get_traffic(self, origin="current location", destination="office"):
        try:
            import webbrowser
            import urllib.parse
            
            # Extract locations from query if provided
            if hasattr(self, '_current_query') and self._current_query:
                query = self._current_query.lower()
                if 'from' in query and 'to' in query:
                    parts = query.split('from')[1].split('to')
                    if len(parts) == 2:
                        origin = parts[0].strip()
                        destination = parts[1].strip()
                elif 'traffic' in query and ('to' in query or 'from' in query):
                    # Handle "traffic to location" or "traffic from location"
                    if 'to' in query:
                        destination = query.split('to')[1].strip()
                    elif 'from' in query:
                        origin = query.split('from')[1].strip()
            
            # Open Google Maps with traffic layer
            if origin != "current location" and destination != "office":
                # Specific route
                maps_url = f"https://www.google.com/maps/dir/{urllib.parse.quote(origin)}/{urllib.parse.quote(destination)}/@?layer=t"
            elif destination != "office":
                # To specific destination
                maps_url = f"https://www.google.com/maps/dir//{urllib.parse.quote(destination)}/@?layer=t"
            else:
                # General traffic view
                maps_url = "https://www.google.com/maps/@?layer=t"
            
            webbrowser.open(maps_url)
            
            # Return informative message
            if origin != "current location" and destination != "office":
                return f"Opening traffic information from {origin} to {destination} in Google Maps"
            elif destination != "office":
                return f"Opening traffic information to {destination} in Google Maps"
            else:
                return "Opening Google Maps with live traffic information"
                
        except Exception as e:
            return f"Could not get traffic information: {str(e)}"
    
    def _get_holidays(self, country="IN"):
        try:
            year = datetime.now().year
            url = f"https://date.nager.at/api/v3/PublicHolidays/{year}/{country}"
            response = requests.get(url, timeout=5)
            
            # Handle 204 No Content or other non-200 responses
            if response.status_code == 204 or response.status_code != 200:
                return self._get_simple_holidays()
            
            # Check if response has content
            if not response.text.strip():
                return self._get_simple_holidays()
            
            # Try to parse JSON
            try:
                holidays = response.json()
            except json.JSONDecodeError:
                return self._get_simple_holidays()
            
            if not holidays or not isinstance(holidays, list):
                return self._get_simple_holidays()
            
            today = datetime.now().strftime("%Y-%m-%d")
            tomorrow = (datetime.now() + timedelta(days=1)).strftime("%Y-%m-%d")
            
            for holiday in holidays:
                if holiday.get('date') == today:
                    return f"Today is {holiday.get('localName', 'a holiday')}, a public holiday in {country}."
                elif holiday.get('date') == tomorrow:
                    return f"Tomorrow is {holiday.get('localName', 'a holiday')}, a public holiday in {country}."
            
            # Find next upcoming holiday
            upcoming = None
            for holiday in holidays:
                if holiday.get('date'):
                    try:
                        holiday_date = datetime.strptime(holiday['date'], "%Y-%m-%d")
                        if holiday_date > datetime.now():
                            upcoming = holiday
                            break
                    except ValueError:
                        continue
            
            if upcoming:
                try:
                    days_until = (datetime.strptime(upcoming['date'], "%Y-%m-%d") - datetime.now()).days
                    return f"Next holiday: {upcoming.get('localName', 'Holiday')} in {days_until} days ({upcoming['date']})."
                except ValueError:
                    return "Found upcoming holidays but couldn't calculate dates"
            
            return "No public holidays today or tomorrow."
        except requests.RequestException:
            return self._get_simple_holidays()
        except Exception as e:
            return self._get_simple_holidays()
    
    def _get_simple_holidays(self):
        """Fallback method for when API fails"""
        try:
            today = datetime.now()
            month = today.month
            day = today.day
            year = today.year
            
            # Common holidays with dates
            holidays = {
                (1, 1): "New Year's Day",
                (1, 26): "Republic Day (India)",
                (3, 8): "Holi (approximate)",
                (4, 14): "Baisakhi",
                (8, 15): "Independence Day (India)",
                (10, 2): "Gandhi Jayanti",
                (10, 31): "Halloween",
                (11, 14): "Children's Day (India)",
                (12, 25): "Christmas Day",
                (12, 31): "New Year's Eve"
            }
            
            # Check today
            if (month, day) in holidays:
                return f"Today is {holidays[(month, day)]}"
            
            # Check tomorrow
            tomorrow = today + timedelta(days=1)
            if (tomorrow.month, tomorrow.day) in holidays:
                return f"Tomorrow is {holidays[(tomorrow.month, tomorrow.day)]}"
            
            # Find next holiday
            for i in range(1, 365):
                future_date = today + timedelta(days=i)
                if (future_date.month, future_date.day) in holidays:
                    return f"Next major holiday: {holidays[(future_date.month, future_date.day)]} in {i} days ({future_date.strftime('%B %d')})"
            
            return "No major public holidays found in the next year"
        except Exception:
            return "Could not check holidays"
    
    def _get_covid_stats(self, country="India"):
        try:
            url = f"https://disease.sh/v3/covid-19/countries/{country}?strict=true"
            response = requests.get(url, timeout=5)
            
            if response.status_code != 200:
                return f"COVID API returned status code: {response.status_code}"
            
            if not response.text.strip():
                return "COVID API returned empty response"
            
            try:
                data = response.json()
            except json.JSONDecodeError:
                return "COVID API returned invalid data format"
            
            new_cases = data.get('todayCases', 0)
            deaths = data.get('todayDeaths', 0)
            recovered = data.get('todayRecovered', 0)
            total_cases = data.get('cases', 0)
            
            return f"COVID-19 update for {country}: {new_cases:,} new cases, {deaths:,} deaths, and {recovered:,} recoveries today. Total cases: {total_cases:,}."
        except requests.RequestException:
            return "Could not connect to COVID-19 statistics service"
        except Exception as e:
            return f"Could not get COVID-19 statistics: {str(e)}"
        


    
    def _extract_product_name(self, query: str, site: str):
        """
        Extracts product name from query like 'track price of iPhone 15 on flipkart'
        """
        query = query.lower()
        print(f"DEBUG: Extracting from query: '{query}' for site: '{site}'")
        
        # Pattern 1: "track price of <product> on site"
        pattern1 = rf"track\s+price\s+of\s+(.+?)\s+on\s+{site}"
        match = re.search(pattern1, query)
        if match:
            result = match.group(1).strip()
            print(f"DEBUG: Pattern 1 matched: '{result}'")
            return result
        
        # Pattern 2: "track <product> on site"
        pattern2 = rf"track\s+(.+?)\s+on\s+{site}"
        match = re.search(pattern2, query)
        if match:
            result = match.group(1).strip()
            print(f"DEBUG: Pattern 2 matched: '{result}'")
            return result
        
        print(f"DEBUG: No pattern matched")
        return None

    # ===== PRODUCT PRICE TRACKING =====#
    def _track_amazon_price(self, product_name=""):
        try:
            if not product_name and hasattr(self, '_current_query'):
                product_name = self._extract_product_name(self._current_query, "amazon")
            
            if not product_name:
                product_name = "laptop"
            
            search_url = f"https://www.amazon.in/s?k={urllib.parse.quote(product_name)}"
            subprocess.Popen(f'start chrome "{search_url}"', shell=True)
            return f"Opened Amazon price tracking for: {product_name}"
        except Exception as e:
            return f"Amazon price tracking failed: {str(e)}"

    def _track_flipkart_price(self, product_name=""):
        try:
            if not product_name and hasattr(self, '_current_query'):
                print(f"DEBUG: Current query: {self._current_query}")
                product_name = self._extract_product_name(self._current_query, "flipkart")
                print(f"DEBUG: Extracted product name: '{product_name}'")

            if not product_name:
                product_name = "smartphone"

            search_url = f"https://www.flipkart.com/search?q={urllib.parse.quote(product_name)}"
            subprocess.Popen(f'start chrome "{search_url}"', shell=True)
            return f"Opened Flipkart price tracking for: {product_name}"
        except Exception as e:
            return f"Flipkart price tracking failed: {str(e)}"
    
    def _check_product_price(self, product_name=""):
        try:
            if not product_name and hasattr(self, '_current_query'):
                import re
                query = self._current_query.lower()
                match = re.search(r'(?:check|price).*?(?:of|for)\s+(.+)', query)
                if match:
                    product_name = match.group(1).strip()
            
            if not product_name:
                return "Please specify a product to check price"
            
            # Open both Amazon and Flipkart for price comparison
            import urllib.parse
            amazon_url = f"https://www.amazon.in/s?k={urllib.parse.quote(product_name)}"
            flipkart_url = f"https://www.flipkart.com/search?q={urllib.parse.quote(product_name)}"
            
            subprocess.Popen(f'start chrome "{amazon_url}"', shell=True)
            time.sleep(2)
            subprocess.Popen(f'start chrome "{flipkart_url}"', shell=True)
            
            return f"Opened price comparison for: {product_name} on Amazon and Flipkart"
        except Exception as e:
            return f"Price check failed: {str(e)}"
    
    # ===== TRAVEL SEARCH =====
    def _search_flights(self, route=""):
        try:
            if not route and hasattr(self, '_current_query'):
                import re
                query = self._current_query.lower()
                # Extract route from query
                match = re.search(r'(?:flight|flights).*?(?:from|to)\s+(.+)', query)
                if match:
                    route = match.group(1).strip()
                else:
                    match = re.search(r'search.*?flights?\s+(.+)', query)
                    if match:
                        route = match.group(1).strip()
            
            if not route:
                route = "Delhi to Mumbai"
            
            # Open multiple flight booking sites
            flight_sites = [
                "https://www.makemytrip.com/flight/search",
                "https://www.goibibo.com/flights/",
                "https://www.cleartrip.com/flights"
            ]
            
            for site in flight_sites:
                subprocess.Popen(f'start chrome "{site}"', shell=True)
                time.sleep(1)
            
            return f"Opened flight search for: {route}"
        except Exception as e:
            return f"Flight search failed: {str(e)}"
    
    def _search_hotels(self, location=""):
        try:
            if not location and hasattr(self, '_current_query'):
                import re
                query = self._current_query.lower()
                # Extract location from query
                match = re.search(r'(?:hotel|hotels).*?(?:in|at)\s+(.+)', query)
                if match:
                    location = match.group(1).strip()
                else:
                    match = re.search(r'search.*?hotels?\s+(.+)', query)
                    if match:
                        location = match.group(1).strip()
            
            if not location:
                location = "Goa"
            
            # Open multiple hotel booking sites
            hotel_sites = [
                f"https://www.booking.com/searchresults.html?ss={location}",
                f"https://www.makemytrip.com/hotels/{location.lower().replace(' ', '-')}-hotels.html",
                f"https://www.oyo.com/search/?location={location}"
            ]
            
            for site in hotel_sites:
                subprocess.Popen(f'start chrome "{site}"', shell=True)
                time.sleep(1)
            
            return f"Opened hotel search for: {location}"
        except Exception as e:
            return f"Hotel search failed: {str(e)}"
    
    # ===== STREAMING AVAILABILITY =====
    def _find_movie_streaming(self, movie_name=""):
        try:
            if not movie_name and hasattr(self, '_current_query'):
                import re
                query = self._current_query.lower()
                # Extract movie name from query
                match = re.search(r'(?:movie|film).*?(?:streaming|watch)\s+(.+)', query)
                if match:
                    movie_name = match.group(1).strip()
                else:
                    match = re.search(r'(?:find|search).*?movie\s+(.+)', query)
                    if match:
                        movie_name = match.group(1).strip()
            
            if not movie_name:
                return "Please specify a movie name"
            
            # Open streaming platforms and search engines
            import urllib.parse
            search_query = f"{movie_name} streaming where to watch"
            
            streaming_searches = [
                f"https://www.google.com/search?q={urllib.parse.quote(search_query)}",
                f"https://www.justwatch.com/in/search?q={urllib.parse.quote(movie_name)}",
                f"https://www.netflix.com/search?q={urllib.parse.quote(movie_name)}",
                f"https://www.primevideo.com/search/ref=atv_nb_sr?phrase={urllib.parse.quote(movie_name)}"
            ]
            
            for url in streaming_searches:
                subprocess.Popen(f'start chrome "{url}"', shell=True)
                time.sleep(1)
            
            return f"Searching streaming availability for movie: {movie_name}"
        except Exception as e:
            return f"Movie streaming search failed: {str(e)}"
    
    def _find_show_streaming(self, show_name=""):
        try:
            if not show_name and hasattr(self, '_current_query'):
                import re
                query = self._current_query.lower()
                # Extract show name from query
                match = re.search(r'(?:show|series).*?(?:streaming|watch)\s+(.+)', query)
                if match:
                    show_name = match.group(1).strip()
                else:
                    match = re.search(r'(?:find|search).*?show\s+(.+)', query)
                    if match:
                        show_name = match.group(1).strip()
            
            if not show_name:
                return "Please specify a show name"
            
            # Open streaming platforms and search engines
            import urllib.parse
            search_query = f"{show_name} TV show streaming where to watch"
            
            streaming_searches = [
                f"https://www.google.com/search?q={urllib.parse.quote(search_query)}",
                f"https://www.justwatch.com/in/search?q={urllib.parse.quote(show_name)}",
                f"https://www.netflix.com/search?q={urllib.parse.quote(show_name)}",
                f"https://www.hotstar.com/in/search?q={urllib.parse.quote(show_name)}"
            ]
            
            for url in streaming_searches:
                subprocess.Popen(f'start chrome "{url}"', shell=True)
                time.sleep(1)
            
            return f"Searching streaming availability for show: {show_name}"
        except Exception as e:
            return f"Show streaming search failed: {str(e)}"
    
    def _where_to_watch(self, content_name=""):
        try:
            if not content_name and hasattr(self, '_current_query'):
                import re
                query = self._current_query.lower()
                # Extract content name from query
                match = re.search(r'where.*?watch\s+(.+)', query)
                if match:
                    content_name = match.group(1).strip()
            
            if not content_name:
                return "Please specify what you want to watch"
            
            # Open JustWatch - the best platform for finding streaming availability
            import urllib.parse
            justwatch_url = f"https://www.justwatch.com/in/search?q={urllib.parse.quote(content_name)}"
            google_search = f"https://www.google.com/search?q={urllib.parse.quote(content_name + ' where to watch streaming')}"
            
            subprocess.Popen(f'start chrome "{justwatch_url}"', shell=True)
            time.sleep(2)
            subprocess.Popen(f'start chrome "{google_search}"', shell=True)
            
            return f"Finding where to watch: {content_name}"
        except Exception as e:
            return f"Streaming search failed: {str(e)}"
    
    def _streaming_availability(self, content_name=""):
        try:
            return self._where_to_watch(content_name)
        except Exception as e:
            return f"Streaming availability check failed: {str(e)}"
    
    def _get_weekday(self):
        try:
            return datetime.now().strftime('%A')
        except:
            return "Could not get weekday"
    
    def _get_traffic(self):
        try:
            subprocess.Popen('start https://maps.google.com/maps?layer=t', shell=True)
            return "Traffic information opened"
        except:
            return "Could not get traffic info"
    
    def _get_holidays(self):
        try:
            subprocess.Popen('start https://www.google.com/search?q=public+holidays+today+india', shell=True)
            return "Holiday information opened"
        except:
            return "Could not get holiday info"
    
    def _get_covid_stats(self):
        try:
            subprocess.Popen('start https://www.google.com/search?q=covid+cases+india+today', shell=True)
            return "COVID-19 statistics opened"
        except:
            return "Could not get COVID stats"
    
   
    
    # Advanced Flight/Hotel Search with API Integration
    def _search_flights(self, route=""):
        try:
            import requests, re, datetime
            
            if not route and hasattr(self, '_current_query'):
                query = self._current_query.lower()
                match = re.search(r'(?:flight|flights).*?(?:from|to)\s+(.+)', query)
                if match:
                    route = match.group(1).strip()
            
            if not route:
                route = "Delhi to Mumbai"
            
            # City code mapping
            city_map = {"bengaluru": "BLR", "delhi": "DEL", "mumbai": "BOM", "chennai": "MAA", "goa": "GOI"}
            from_city = next((city_map[k] for k in city_map if k in route.lower()), "DEL")
            to_city = next((city_map[k] for k in city_map if k in route.lower().split("to")[-1]), "BOM")
            
            # Open multiple flight booking sites
            flight_sites = [
                "https://www.makemytrip.com/flights/",
                "https://www.goibibo.com/flights/",
                "https://www.easemytrip.com/flights.html"
            ]
            
            for site in flight_sites:
                subprocess.Popen(f'start chrome "{site}"', shell=True)
                time.sleep(1)
            
            return f"Flight search opened for: {route}"
        except Exception as e:
            return f"Flight search failed: {str(e)}"
    
    def _search_hotels(self, location=""):
        try:
            if not location and hasattr(self, '_current_query'):
                import re
                query = self._current_query.lower()
                match = re.search(r'(?:hotel|hotels).*?(?:in|at)\s+(.+)', query)
                if match:
                    location = match.group(1).strip()
            
            if not location:
                location = "Goa"
            
            # Open multiple hotel booking sites
            hotel_sites = [
                f"https://www.booking.com/searchresults.html?ss={location}",
                f"https://www.makemytrip.com/hotels/{location.lower().replace(' ', '-')}-hotels.html",
                f"https://www.oyo.com/search/?location={location}"
            ]
            
            for site in hotel_sites:
                subprocess.Popen(f'start chrome "{site}"', shell=True)
                time.sleep(1)
            
            return f"Hotel search opened for: {location}"
        except Exception as e:
            return f"Hotel search failed: {str(e)}"
    
    # Advanced Movie/Show Streaming Search with TMDb API
    def _find_movie_streaming(self, movie_name=""):
        try:
            import requests
            
            if not movie_name and hasattr(self, '_current_query'):
                import re
                query = self._current_query.lower()
                match = re.search(r'(?:movie|film).*?(?:streaming|watch)\s+(.+)', query)
                if match:
                    movie_name = match.group(1).strip()
            
            if not movie_name:
                return "Please specify a movie name"
            
            # Use JustWatch and Google for streaming availability
            import urllib.parse
            search_query = f"{movie_name} streaming where to watch"
            
            streaming_searches = [
                f"https://www.google.com/search?q={urllib.parse.quote(search_query)}",
                f"https://www.justwatch.com/in/search?q={urllib.parse.quote(movie_name)}",
                f"https://www.netflix.com/search?q={urllib.parse.quote(movie_name)}",
                f"https://www.primevideo.com/search/ref=atv_nb_sr?phrase={urllib.parse.quote(movie_name)}"
            ]
            
            for url in streaming_searches:
                subprocess.Popen(f'start chrome "{url}"', shell=True)
                time.sleep(1)
            
            return f"Searching streaming availability for movie: {movie_name}"
        except Exception as e:
            return f"Movie streaming search failed: {str(e)}"
    
    def _find_show_streaming(self, show_name=""):
        try:
            if not show_name and hasattr(self, '_current_query'):
                import re
                query = self._current_query.lower()
                match = re.search(r'(?:show|series).*?(?:streaming|watch)\s+(.+)', query)
                if match:
                    show_name = match.group(1).strip()
            
            if not show_name:
                return "Please specify a show name"
            
            # Open streaming platforms and search engines
            import urllib.parse
            search_query = f"{show_name} TV show streaming where to watch"
            
            streaming_searches = [
                f"https://www.google.com/search?q={urllib.parse.quote(search_query)}",
                f"https://www.justwatch.com/in/search?q={urllib.parse.quote(show_name)}",
                f"https://www.netflix.com/search?q={urllib.parse.quote(show_name)}",
                f"https://www.hotstar.com/in/search?q={urllib.parse.quote(show_name)}"
            ]
            
            for url in streaming_searches:
                subprocess.Popen(f'start chrome "{url}"', shell=True)
                time.sleep(1)
            
            return f"Searching streaming availability for show: {show_name}"
        except Exception as e:
            return f"Show streaming search failed: {str(e)}"
    
    def _where_to_watch(self, content_name=""):
        try:
            if not content_name and hasattr(self, '_current_query'):
                import re
                query = self._current_query.lower()
                match = re.search(r'where.*?watch\s+(.+)', query)
                if match:
                    content_name = match.group(1).strip()
            
            if not content_name:
                return "Please specify what you want to watch"
            
            # Open JustWatch - the best platform for finding streaming availability
            import urllib.parse
            justwatch_url = f"https://www.justwatch.com/in/search?q={urllib.parse.quote(content_name)}"
            google_search = f"https://www.google.com/search?q={urllib.parse.quote(content_name + ' where to watch streaming')}"
            
            subprocess.Popen(f'start chrome "{justwatch_url}"', shell=True)
            time.sleep(2)
            subprocess.Popen(f'start chrome "{google_search}"', shell=True)
            
            return f"Finding where to watch: {content_name}"
        except Exception as e:
            return f"Streaming search failed: {str(e)}"
    
    def _streaming_availability(self, content_name=""):
        try:
            return self._where_to_watch(content_name)
        except Exception as e:
            return f"Streaming availability check failed: {str(e)}"



    # DEBUG Price Tracking Functions
    def _track_amazon_price_debug(self):
        try:
            print("DEBUG: Amazon price tracking function called")
            query = getattr(self, '_current_query', 'No query stored')
            print(f"DEBUG: Current query: {query}")
            
            # Extract product name from query
            import re
            product_match = re.search(r'track price.*?(?:of|for)\s+(.+?)\s+(?:on|in|from)\s+amazon', query.lower())
            if product_match:
                product_name = product_match.group(1).strip()
                print(f"DEBUG: Extracted product name: {product_name}")
                import urllib.parse
                search_url = f"https://www.amazon.in/s?k={urllib.parse.quote(product_name)}"
                subprocess.Popen(['start', search_url], shell=True)
                return f"DEBUG: Amazon search opened for: {product_name}"
            else:
                subprocess.Popen('start https://www.amazon.in', shell=True)
                return "DEBUG: Amazon opened (no product extracted)"
        except Exception as e:
            return f"DEBUG: Amazon price tracking failed - {str(e)}"
    
    def _track_flipkart_price_debug(self):
        try:
            print("DEBUG: Flipkart price tracking function called")
            query = getattr(self, '_current_query', 'No query stored')
            print(f"DEBUG: Current query: {query}")
            
            # Extract product name from query
            import re
            product_match = re.search(r'track price.*?(?:of|for)\s+(.+?)\s+(?:on|in|from)\s+flipkart', query.lower())
            if product_match:
                product_name = product_match.group(1).strip()
                print(f"DEBUG: Extracted product name: {product_name}")
                import urllib.parse
                search_url = f"https://www.flipkart.com/search?q={urllib.parse.quote(product_name)}"
                subprocess.Popen(['start', search_url], shell=True)
                return f"DEBUG: Flipkart search opened for: {product_name}"
            else:
                subprocess.Popen('start https://www.flipkart.com', shell=True)
                return "DEBUG: Flipkart opened (no product extracted)"
        except Exception as e:
            return f"DEBUG: Flipkart price tracking failed - {str(e)}"
    
    def _check_product_price_debug(self):
        try:
            print("DEBUG: Product price comparison function called")
            query = getattr(self, '_current_query', 'No query stored')
            print(f"DEBUG: Current query: {query}")
            
            # Extract product name from query
            import re
            product_match = re.search(r'(?:track|check)\s+price.*?(?:of|for)\s+(.+)', query.lower())
            if product_match:
                product_name = product_match.group(1).strip()
                print(f"DEBUG: Extracted product name: {product_name}")
                import urllib.parse
                # Open multiple price comparison sites
                sites = [
                    f"https://www.amazon.in/s?k={urllib.parse.quote(product_name)}",
                    f"https://www.flipkart.com/search?q={urllib.parse.quote(product_name)}",
                    f"https://www.google.com/search?q={urllib.parse.quote(product_name + ' price comparison')}"
                ]
                for site in sites:
                    subprocess.Popen(['start', site], shell=True)
                    time.sleep(1)
                return f"DEBUG: Price comparison opened for: {product_name}"
            else:
                subprocess.Popen('start https://www.pricehistory.in', shell=True)
                return "DEBUG: Price comparison opened (no product extracted)"
        except Exception as e:
            return f"DEBUG: Product price comparison failed - {str(e)}"
        

    # Timer & Stopwatch Features
    def __init_timer_vars(self):
        if not hasattr(self, 'stopwatch_start'):
            self.stopwatch_start = None
            self.elapsed_time = 0
            self.running = False
    
    def _countdown_timer(self):
        try:
            self.__init_timer_vars()
            import threading, re
            query = getattr(self, '_current_query', '')
            
            # Extract duration from query
            duration = 0
            words = query.lower().split()
            for i, word in enumerate(words):
                if word.isdigit():
                    duration = int(word)
                    if i+1 < len(words) and 'minute' in words[i+1]:
                        duration *= 60
                    break
            
            if duration > 0:
                def countdown():
                    seconds = duration
                    while seconds > 0:
                        mins, secs = divmod(seconds, 60)
                        print(f"\r‚è≥ Time left: {mins:02d}:{secs:02d}", end="")
                        time.sleep(1)
                        seconds -= 1
                    print("\n‚úÖ Time's up!")
                    try:
                        from engine.command import speak
                        speak("Time's up!")
                    except:
                        pass
                
                threading.Thread(target=countdown, daemon=True).start()
                return f"Timer started for {duration} seconds"
            return "Please specify a valid duration"
        except Exception as e:
            return f"Timer error: {str(e)}"
    
    def _start_stopwatch(self):
        try:
            self.__init_timer_vars()
            if not self.running:
                self.stopwatch_start = time.time()
                self.running = True
                return "‚è±Ô∏è Stopwatch started"
            return "Stopwatch already running"
        except Exception as e:
            return f"Stopwatch error: {str(e)}"
    
    def _stop_stopwatch(self):
        try:
            self.__init_timer_vars()
            if self.running:
                self.elapsed_time += time.time() - self.stopwatch_start
                self.running = False
                return f"‚èπÔ∏è Stopwatch stopped. Elapsed: {self.elapsed_time:.2f} seconds"
            return "Stopwatch not running"
        except Exception as e:
            return f"Stopwatch error: {str(e)}"
    
    def _reset_stopwatch(self):
        try:
            self.__init_timer_vars()
            self.elapsed_time = 0
            self.stopwatch_start = None
            self.running = False
            return "üîÅ Stopwatch reset"
        except Exception as e:
            return f"Stopwatch error: {str(e)}"
    
    def _show_elapsed(self):
        try:
            self.__init_timer_vars()
            if self.running:
                current = self.elapsed_time + (time.time() - self.stopwatch_start)
            else:
                current = self.elapsed_time
            return f"‚è≥ Elapsed time: {current:.2f} seconds"
        except Exception as e:
            return f"Stopwatch error: {str(e)}"
    
    # Mini Games Feature
    def _open_mini_game(self):
        try:
            query = getattr(self, '_current_query', '').lower()
            
            mini_games = {
                "chess": "https://www.chess.com/play/computer",
                "snake": "https://playsnake.org/",
                "flappy bird": "https://flappybird.io/",
                "car": "https://simmer.io/@gqcar/game-car-driving",
                "tetris": "https://tetris.com/play-tetris",
                "2048": "https://play2048.co/",
                "dino": "https://chromedino.com/",
                "pac man": "https://pacman.live/",
                "mario": "https://supermario-game.com/",
                "solitaire": "https://solitaired.com/",
                "sudoku": "https://sudoku.com/",
                "crossword": "https://crosswordpuzzles.com/",
                "bubble shooter": "https://bubble-shooter.co/",
                "candy crush": "https://king.com/game/candycrushsaga",
                "angry birds": "https://angrybirds.com/",
                "pool": "https://www.crazygames.com/game/8-ball-pool",
                "racing": "https://www.crazygames.com/game/madalin-stunt-cars-2",
                "puzzle": "https://www.jigsawplanet.com/",
                "word": "https://wordscapes.com/"
            }
            
            # Check for specific game in query
            for name, url in mini_games.items():
                if name in query:
                    subprocess.Popen(['start', url], shell=True)
                    return f"üéÆ Opening {name} game"
            
            # Open default games site
            subprocess.Popen(['start', 'https://crazygames.com'], shell=True)
            return "üéØ Opening games collection"
        except Exception as e:
            return f"Game launch error: {str(e)}"



               # Smart Clipboard Assistant Methods
    def _clipboard_assistant(self):
        """Smart clipboard assistant that analyzes clipboard content"""
        try:
            import pyperclip
            import re
            
            clipboard_text = pyperclip.paste()
            if not clipboard_text or len(clipboard_text.strip()) < 3:
                return "Clipboard is empty or too short to analyze"
            
            # Analyze clipboard content using AI
            return self._analyze_clipboard_content(clipboard_text)
        except Exception as e:
            return f"Clipboard assistant error: {str(e)}"
    
    def _start_clipboard_assistant(self):
        """Start monitoring clipboard for context-aware help"""
        try:
            import threading
            import time
            import pyperclip
            
            if hasattr(self, 'clipboard_monitor_active') and self.clipboard_monitor_active:
                return "Clipboard assistant already running"
            
            self.clipboard_monitor_active = True
            self.last_clipboard = ""
            
            def monitor_clipboard():
                while self.clipboard_monitor_active:
                    try:
                        current_clipboard = pyperclip.paste()
                        if current_clipboard != self.last_clipboard and current_clipboard.strip():
                            self.last_clipboard = current_clipboard
                            suggestion = self._analyze_clipboard_content(current_clipboard)
                            if suggestion:
                                print(f"üìã Clipboard Assistant: {suggestion}")
                        time.sleep(2)
                    except:
                        time.sleep(2)
            
            threading.Thread(target=monitor_clipboard, daemon=True).start()
            return "Clipboard assistant started - monitoring clipboard for smart suggestions"
        except Exception as e:
            return f"Failed to start clipboard assistant: {str(e)}"
    
    def _stop_clipboard_assistant(self):
        """Stop clipboard monitoring"""
        try:
            self.clipboard_monitor_active = False
            return "Clipboard assistant stopped"
        except Exception as e:
            return f"Error stopping clipboard assistant: {str(e)}"
    
    def _analyze_clipboard_content(self, text):
        """Analyze clipboard content and provide context-aware suggestions"""
        try:
            import re
            
            text = text.strip()
            
            # Phone number detection
            if re.match(r'^[+]?[\d\s\-\(\)]{10,15}$', text):
                return "üìû Phone number detected! Want me to save this contact or make a call?"
            
            # Email detection
            if re.match(r'^[\w\.-]+@[\w\.-]+\.[a-zA-Z]{2,}$', text):
                return "üìß Email address detected! Want me to compose an email or save this contact?"
            
            # URL detection
            if re.match(r'https?://[\w\.-]+', text):
                return "üîó URL detected! Want me to open this link or bookmark it?"
            
            # Long text (paragraph)
            if len(text) > 100 and '.' in text:
                return "üìÑ Long text detected! Shall I summarize this or save it to a document?"
            
            # Code detection
            if any(keyword in text for keyword in ['def ', 'function', 'class ', 'import ', 'const ', 'var ']):
                return "üíª Code detected! Want me to format it, review it, or save to a file?"
            
            # Address detection
            if any(word in text.lower() for word in ['street', 'avenue', 'road', 'city', 'zip']):
                return "üìç Address detected! Want me to find directions or save this location?"
            
            # Date/time detection
            if re.search(r'\d{1,2}[/\-]\d{1,2}[/\-]\d{2,4}|\d{1,2}:\d{2}', text):
                return "üìÖ Date/time detected! Want me to create a calendar event or set a reminder?"
            
            # Password-like text
            if len(text) > 8 and re.search(r'[A-Z]', text) and re.search(r'[0-9]', text) and re.search(r'[!@#$%^&*]', text):
                return "üîê Strong password detected! Want me to save this securely?"
            
            # Shopping list
            if '\n' in text and len(text.split('\n')) > 3:
                return "üìù List detected! Want me to organize this or create a task list?"
            
            # Default for other text
            if len(text) > 20:
                return "üìã Text copied! Want me to translate, search, or save this?"
            
            return None
        except Exception as e:
            return None
    


    
    def _create_image(self):
        """Create image using AI"""
        try:
            query = getattr(self, '_current_query', '')
            prompt = query.replace('create image', '').replace('generate image', '').replace('make image', '').strip()
            
            if not prompt:
                return "Please specify what image to create (e.g., 'create image of a sunset')"
            
            from engine.simple_image_gen import create_simple_image
            return create_simple_image(prompt)
        except Exception as e:
            return f"Image creation error: {str(e)}"
    
    def _explain_capabilities(self):
        """Explain what Jarvis can do"""
        return "I can control your computer (open apps, manage files, system controls), help with productivity (alarms, reminders, clipboard assistant), browse the web (YouTube, search, websites), create AI images, and answer questions using AI. I support voice commands for hands-free operation and can adapt to your preferences. Just ask me to open something, control media, set alarms, create images, or help with tasks!"
    
    def _set_alarm(self):
        """Set alarm with voice notification"""
        try:
            import threading
            import time
            import re
            import json
            from datetime import datetime, timedelta
            
            query = getattr(self, '_current_query', '')
            
            # Extract time from query
            time_match = re.search(r'(\d{1,2}):?(\d{2})\s*(am|pm)?', query.lower())
            if not time_match:
                time_match = re.search(r'(\d{1,2})\s*(am|pm)', query.lower())
                if time_match:
                    hour = int(time_match.group(1))
                    if 'pm' in query.lower() and hour != 12:
                        hour += 12
                    elif 'am' in query.lower() and hour == 12:
                        hour = 0
                    minute = 0
                else:
                    return "Please specify time (e.g., 'set alarm 7:30' or 'alarm 8 am')"
            else:
                hour = int(time_match.group(1))
                minute = int(time_match.group(2)) if time_match.group(2) else 0
                # Handle AM/PM for time with minutes
                if 'pm' in query.lower() and hour != 12:
                    hour += 12
                elif 'am' in query.lower() and hour == 12:
                    hour = 0
            
            # Calculate alarm time
            now = datetime.now()
            alarm_time = now.replace(hour=hour, minute=minute, second=0, microsecond=0)
            
            # Only set for tomorrow if time has already passed today
            if alarm_time <= now:
                alarm_time += timedelta(days=1)
            
            # Store alarm
            self.active_alarm = alarm_time
            
            # Save to file
            with open('alarm.json', 'w') as f:
                json.dump({'time': alarm_time.isoformat()}, f)
            
            self._start_alarm_thread(alarm_time)
            return f"‚è∞ Alarm set for {alarm_time.strftime('%I:%M %p')}"
            
        except Exception as e:
            return f"Error setting alarm: {e}"
    
    def _cancel_alarm(self):
        """Cancel active alarm with voice confirmation"""
        try:
            if self.active_alarm:
                self.active_alarm = None
                # Remove file
                import os
                if os.path.exists('alarm.json'):
                    os.remove('alarm.json')
                print("‚è∞ Alarm cancelled")
                return "‚è∞ Alarm cancelled successfully"
            else:
                return "No active alarm to cancel"
        except Exception as e:
            return f"Error cancelling alarm: {e}"
    



    def _start_alarm_thread(self, alarm_time):
        """Helper method to start alarm thread"""
        import threading
        import time
        from datetime import datetime
        
        def alarm_thread():
            while datetime.now() < alarm_time:
                if not self.active_alarm:
                    return
                time.sleep(1)
            
            # Trigger alarm notification
            try:
                from engine.voice_gender_control import voice_control
                voice_control.speak_with_gender("Good morning! This is your alarm notification. Wake up! Wake up! It's time to get up and start your day. Your alarm time has arrived. Please wake up now!")
            except:
                print("‚è∞ ALARM: Good morning! Wake up! Wake up! It's time to get up and start your day!")
            
            # Clean up
            self.active_alarm = None
            import os
            if os.path.exists('alarm.json'):
                os.remove('alarm.json')
        
        threading.Thread(target=alarm_thread, daemon=True).start()



    def _roll_dice(self):
        """Roll a dice and return the result"""
        result = random.randint(1, 6)
        return f" {result}"
    
    def _flip_coin(self):
        """Flip a coin and return the result"""
        result = random.choice(['Heads', 'Tails'])
        return f"  {result}"
    
    def _age_calculator(self):
        """Calculate age from birth date"""
        try:
            from datetime import datetime
            import re
            
            query = getattr(self, '_current_query', '')
            
            # Extract date from query (DD/MM/YYYY or DD-MM-YYYY)
            date_match = re.search(r'(\d{1,2})[/-](\d{1,2})[/-](\d{4})', query)
            if date_match:
                day, month, year = map(int, date_match.groups())
                
                # Validate year (reasonable range)
                if year < 1900 or year > 2024:
                    return f"Invalid year: {year}. Please use a year between 1900 and 2024"
                
                # Validate month
                if month < 1 or month > 12:
                    return f"Invalid month: {month}. Please use month between 1-12"
                
                # Validate day
                if day < 1 or day > 31:
                    return f"Invalid day: {day}. Please use day between 1-31"
                
                try:
                    birth_date = datetime(year, month, day)
                except ValueError as ve:
                    return f"Invalid date: {day}/{month}/{year}. {str(ve)}"
                
                today = datetime.now()
                
                # Check if birth date is in the future
                if birth_date > today:
                    return f"Birth date {day}/{month}/{year} is in the future!"
                
                age = today.year - birth_date.year
                if today.month < birth_date.month or (today.month == birth_date.month and today.day < birth_date.day):
                    age -= 1
                
                days_diff = (today - birth_date).days
                return f"Age: {age} years ({days_diff} days old)"
            
            return "Please provide birth date (e.g., 'my age 15/03/1990')"
        except Exception as e:
            return f"Age calculation error: {str(e)}"


    def _sort_files(self):
        """Sort files by date, time, name, or size"""
        try:
            import os
            import re
            from datetime import datetime
            
            query = getattr(self, '_current_query', '').lower()
            
            # Extract sort criteria and directory
            sort_by = 'name'  # default
            if 'date' in query or 'time' in query:
                sort_by = 'date'
            elif 'size' in query:
                sort_by = 'size'
            elif 'name' in query:
                sort_by = 'name'
            
            # Extract directory
            target_dir = os.path.join(os.path.expanduser("~"), "Desktop")
            dir_match = re.search(r'(?:in|on)\s+(\w+)', query)
            if dir_match:
                dir_name = dir_match.group(1)
                dirs = {
                    'downloads': 'Downloads', 'documents': 'Documents',
                    'desktop': 'Desktop', 'pictures': 'Pictures',
                    'music': 'Music', 'videos': 'Videos'
                }
                if dir_name in dirs:
                    target_dir = os.path.join(os.path.expanduser("~"), dirs[dir_name])
            
            if not os.path.exists(target_dir):
                return f"Directory not found: {target_dir}"
            
            # Get files
            files = [f for f in os.listdir(target_dir) if os.path.isfile(os.path.join(target_dir, f))]
            
            if not files:
                return f"No files found in {os.path.basename(target_dir)}"
            
            # Sort files
            if sort_by == 'date':
                files.sort(key=lambda f: os.path.getmtime(os.path.join(target_dir, f)), reverse=True)
                criteria = "date (newest first)"
            elif sort_by == 'size':
                files.sort(key=lambda f: os.path.getsize(os.path.join(target_dir, f)), reverse=True)
                criteria = "size (largest first)"
            else:  # name
                files.sort()
                criteria = "name (A-Z)"
            
            # Show top 5 files with details
            result = f"Files in {os.path.basename(target_dir)} sorted by {criteria}:\n"
            for i, file in enumerate(files[:5]):
                file_path = os.path.join(target_dir, file)
                if sort_by == 'date':
                    mod_time = datetime.fromtimestamp(os.path.getmtime(file_path))
                    result += f"{i+1}. {file} ({mod_time.strftime('%Y-%m-%d %H:%M')})\n"
                elif sort_by == 'size':
                    size = os.path.getsize(file_path)
                    if size < 1024:
                        size_str = f"{size} B"
                    elif size < 1024*1024:
                        size_str = f"{size/1024:.1f} KB"
                    else:
                        size_str = f"{size/(1024*1024):.1f} MB"
                    result += f"{i+1}. {file} ({size_str})\n"
                else:
                    result += f"{i+1}. {file}\n"
            
            if len(files) > 5:
                result += f"... and {len(files)-5} more files"
            
            return result.strip()
            
        except Exception as e:
            return f"Sort failed: {str(e)}"


    def _ai_document_maker(self, doc_type="document"):
        try:
            topic = "Document"
            user_info = ""
            num_pages = 2
            
            if hasattr(self, '_current_query') and self._current_query:
                import re
                query = self._current_query.lower()

                # Document type
                if 'report' in query:
                    doc_type = "report"
                elif 'letter' in query:
                    doc_type = "letter"

                # Extract page count
                page_match = re.search(r'(\d+)\s+page', query)
                if page_match:
                    num_pages = int(page_match.group(1))

                # Extract topic correctly
                patterns = [
                    r'(?:create|make)\s+(?:a\s+)?(?:document|report|letter)\s+(?:about|on|regarding)\s+(.+?)(?:\s+\d+\s+page)?$',
                    r'(?:document|report|letter)\s+(?:about|on|regarding)\s+(.+?)(?:\s+\d+\s+page)?$',
                ]
                
                for pattern in patterns:
                    match = re.search(pattern, query)
                    if match:
                        topic = match.group(1).strip()
                        topic = re.sub(r'\b\d+\s*page(s)?\b', '', topic).strip()
                        break
            
            try:
                from engine.voice_advanced_ai import voice_advanced_ai
                return voice_advanced_ai.ai_document_maker(doc_type, topic, user_info, num_pages)
            except:
                return f"{doc_type.title()} creation started for: {topic} ({num_pages} pages)"
        except Exception as e:
            return f"Document creation error: {str(e)}"
    
    def _write_code(self):
        """AI Code Writer - Write code in any language"""
        try:
            if hasattr(self, '_current_query') and self._current_query:
                import re
                query = self._current_query.lower()
                
                # Extract programming language
                languages = ['python', 'javascript', 'java', 'c++', 'c#', 'html', 'css', 'php', 'ruby', 'go', 'rust', 'swift', 'kotlin']
                language = 'python'  # default
                for lang in languages:
                    if lang in query:
                        language = lang
                        break
                
                # Extract code description with improved patterns
                patterns = [
                    r'write\s+(?:' + '|'.join(languages) + r')\s+code\s+(?:for|to)\s+(.+)',
                    r'write\s+code\s+(?:in\s+(?:' + '|'.join(languages) + r')\s+)?(?:for|to)\s+(.+)',
                    r'generate\s+(?:' + '|'.join(languages) + r')\s+code\s+(?:for|to)\s+(.+)',
                    r'generate\s+code\s+(?:in\s+(?:' + '|'.join(languages) + r')\s+)?(?:for|to)\s+(.+)',
                    r'create\s+(?:' + '|'.join(languages) + r')\s+code\s+(?:for|to)\s+(.+)',
                    r'create\s+code\s+(?:in\s+(?:' + '|'.join(languages) + r')\s+)?(?:for|to)\s+(.+)'
                ]
                
                description = None
                for pattern in patterns:
                    match = re.search(pattern, query)
                    if match:
                        description = match.group(1).strip()
                        break
                
                # Fallback extraction if patterns fail
                if not description:
                    # Remove common words and extract the main request
                    temp = query
                    for word in ['write', 'generate', 'create', 'code', 'program', 'script'] + languages:
                        temp = temp.replace(word, '')
                    temp = re.sub(r'\b(?:for|to|in|a|an|the)\b', '', temp)
                    description = temp.strip() or "a simple program"
                
                # Generate code using AI with better prompt
                prompt = f"""Write ONLY the {language} code for: {description}

Requirements:
- Write clean, working {language} code
- Include proper comments
- Make it functional and ready to run
- Focus specifically on: {description}
- No explanations, just code

Code:"""
                
                if self.ai_provider == 'groq':
                    response = self.groq_client.chat.completions.create(
                        messages=[{"role": "user", "content": prompt}],
                        model="llama-3.1-8b-instant",
                        max_tokens=1500
                    )
                    code = response.choices[0].message.content.strip()
                else:
                    response = self.gemini_model.generate_content(prompt)
                    code = response.text.strip()
                
                # Clean up the response to get only code
                if '```' in code:
                    # Extract code from markdown blocks
                    import re
                    code_match = re.search(r'```(?:python|javascript|java|html|css)?\n?([\s\S]*?)```', code)
                    if code_match:
                        code = code_match.group(1).strip()
                
                # Remove any leading explanatory text
                lines = code.split('\n')
                code_lines = []
                code_started = False
                for line in lines:
                    if not code_started and (line.strip().startswith('#') or line.strip().startswith('//') or 
                                           line.strip().startswith('def ') or line.strip().startswith('function ') or
                                           line.strip().startswith('class ') or line.strip().startswith('import ') or
                                           line.strip().startswith('from ') or line.strip().startswith('<!DOCTYPE') or
                                           line.strip().startswith('<') or line.strip().startswith('var ') or
                                           line.strip().startswith('let ') or line.strip().startswith('const ')):
                        code_started = True
                    if code_started:
                        code_lines.append(line)
                
                if code_lines:
                    code = '\n'.join(code_lines)
                
                # Save to file
                extensions = {
                    'python': '.py', 'javascript': '.js', 'java': '.java', 'c++': '.cpp',
                    'c#': '.cs', 'html': '.html', 'css': '.css', 'php': '.php',
                    'ruby': '.rb', 'go': '.go', 'rust': '.rs', 'swift': '.swift', 'kotlin': '.kt'
                }
                
                ext = extensions.get(language, '.txt')
                # Clean description for filename
                clean_desc = re.sub(r'[^a-zA-Z0-9_\s]', '', description)
                clean_desc = clean_desc.replace(' ', '_')[:20]
                filename = f"ai_code_{clean_desc}_{datetime.now().strftime('%H%M%S')}{ext}"
                file_path = os.path.join(os.path.expanduser("~"), "Desktop", filename)
                
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(code)
                
                # Open in notepad
                subprocess.Popen(f'notepad "{file_path}"', shell=True)
                
                return f"AI {language} code generated and opened: {filename}"
            
            return "Please specify what code to write (e.g., 'write python code for calculator')"
            
        except Exception as e:
            return f"Code generation failed: {str(e)}"
    

    def _create_project(self):
        """AI Project Creator - generates complete multi-file projects"""
        import os
        import re
        import subprocess

        try:
            if not hasattr(self, '_current_query') or not self._current_query:
                return "Please specify what project to create (e.g., 'create todo app using python')"

            query = self._current_query.strip()

            tech_keywords = ['python', 'javascript', 'html', 'css', 'react', 'flask', 'django', 'node', 'java', 'c++']
            mentioned_tech = [tech for tech in tech_keywords if tech in query.lower()]

            project_name_raw = query.replace("create", "").replace("project", "").strip()
            project_name = re.sub(r'[^a-zA-Z0-9_]', '_', project_name_raw)[:30]
            if not project_name:
                project_name = "AI_Project"

            prompt = f"""
Create a complete working project for: "{query}"

Technologies detected: {', '.join(mentioned_tech) if mentioned_tech else 'auto-select best stack'}

Generate 3‚Äì6 FULL files. Format EXACTLY like this:

**FILENAME: main.py**
```python
# code here
```

**FILENAME: README.md**
```markdown
# content here
```

CRITICAL RULES:
- ONLY complete, working code inside ``` blocks
- Enterprise-grade, production-ready implementation with better ui and backend
- Professional UI with perfect alignment, modern design, responsive layout
- Zero placeholders, TODOs, or incomplete features
- No explanations or text outside file blocks
- Comprehensive README with installation and usage
- All functionality must work flawlessly
"""

            ai_response = ""
            try:
                if hasattr(self, "groq_client") and self.groq_client:
                    resp = self.groq_client.chat.completions.create(
                        model="llama-3.1-8b-instant",
                        messages=[{"role": "user", "content": prompt}],
                        max_tokens=4096
                    )
                    ai_response = resp.choices[0].message.content

                elif hasattr(self, "gemini_model") and self.gemini_model:
                    resp = self.gemini_model.generate_content(prompt)
                    ai_response = resp.text

                else:
                    return "‚ùå No AI provider available."
            except Exception as e:
                return f"‚ùå AI Generation Failed: {e}"

            if not ai_response:
                return "‚ùå AI returned empty response."

            file_blocks = re.findall(
                r'\*\*FILENAME:\s*(.*?)\*\*.*?```(?:[a-zA-Z]*)\n(.*?)```',
                ai_response,
                flags=re.DOTALL
            )

            files = []
            for filename, content in file_blocks:
                filename = filename.strip()
                content = content.strip("\n")
                files.append((filename, content))

            if not files:
                files = [
                    ("main.py", f'# Fallback generated project\nprint("Project: {query}")'),
                    ("README.md", f'# {project_name}\n\nAI formatting error fallback.')
                ]

            desktop = os.path.join(os.path.expanduser("~"), "Desktop")
            project_dir = os.path.join(desktop, f"AI_Project_{project_name}")
            os.makedirs(project_dir, exist_ok=True)

            for filename, content in files:
                file_path = os.path.join(project_dir, filename)
                os.makedirs(os.path.dirname(file_path), exist_ok=True)
                with open(file_path, "w", encoding="utf-8") as f:
                    f.write(content)

            try:
                subprocess.run(["explorer", project_dir], check=False)
            except:
                pass

            return (
                f"‚úÖ Project '{project_name}' created successfully!\n"
                f"üìÅ Location: {project_dir}\n"
                f"üìÑ Files created: {len(files)}\n"
                f"üöÄ Folder opened automatically."
            )

        except Exception as e:
            return f"‚ùå Project creation failed: {str(e)}"


dual_ai = DualAI()

def get_simple_response(query):
    return dual_ai.execute(query)
import subprocess
import pyautogui
import psutil
from datetime import datetime, timedelta
import json
import os
import shutil
import socket
import time
import random
import requests
import winreg
import base64
import hashlib
import sqlite3
from collections import Counter
from typing import Optional, Dict, Any, List
import zipfile
import re
import warnings
warnings.filterwarnings("ignore")
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'

# Import multilingual support
try:
    from engine.multilingual_support import multilingual
except:
    multilingual = None

class DualAI:
    def __init__(self):
        self.ai_provider = self._get_ai_provider()
        self._init_ai_models()
        # Initialize multilingual support
        from engine.multilingual_support import multilingual
        self.multilingual = multilingual
        
        # Initialize personality manager
        try:
            from engine.personality_manager import personality_manager
            self.personality_manager = personality_manager
        except:
            self.personality_manager = None
        
        # All system functions
        self.functions = {
            # Power
            'shutdown': lambda: subprocess.run('shutdown /s /t 5', shell=True),
            'restart': lambda: subprocess.run('shutdown /r /t 5', shell=True),
            'sleep': lambda: subprocess.run('rundll32.exe powrprof.dll,SetSuspendState 0,1,0', shell=True),
            'lock': lambda: subprocess.run('rundll32.exe user32.dll,LockWorkStation', shell=True),
            'hibernate': lambda: subprocess.run('shutdown /h', shell=True),
            
            # Apps
            'calculator': lambda: subprocess.Popen('calc', shell=True),
            'notepad': lambda: subprocess.Popen('notepad', shell=True),
            'chrome': lambda: subprocess.Popen('start chrome', shell=True),
            'edge': lambda: subprocess.Popen('start msedge', shell=True),
            'explorer': lambda: subprocess.Popen('explorer', shell=True),
            'settings': lambda: subprocess.Popen('start ms-settings:', shell=True),
            'taskmanager': lambda: subprocess.Popen('taskmgr', shell=True),
            'cmd': lambda: subprocess.Popen('cmd', shell=True),
            'paint': lambda: subprocess.Popen('mspaint', shell=True),
            'firefox': lambda: subprocess.Popen('start firefox', shell=True),
            'word': lambda: subprocess.Popen('start winword', shell=True),
            'excel': lambda: subprocess.Popen('start excel', shell=True),
            'powerpoint': lambda: subprocess.Popen('start powerpnt', shell=True),
            'vlc': lambda: subprocess.Popen('start vlc', shell=True),
            'vscode': lambda: subprocess.Popen('start code', shell=True),
            'spotify': lambda: subprocess.Popen('start spotify:', shell=True),
            'steam': lambda: subprocess.Popen('start steam', shell=True),
            
            # Websites
            'google': lambda: subprocess.Popen('start chrome https://www.google.com', shell=True),
            'youtube': lambda: subprocess.Popen('start chrome https://www.youtube.com', shell=True),
            'wikipedia': lambda: subprocess.Popen('start chrome https://www.wikipedia.org', shell=True),
            'stackoverflow': lambda: subprocess.Popen('start chrome https://stackoverflow.com', shell=True),
            'github': lambda: subprocess.Popen('start chrome https://github.com', shell=True),
            'amazon': lambda: subprocess.Popen('start chrome https://www.amazon.in', shell=True),
            'flipkart': lambda: subprocess.Popen('start chrome https://www.flipkart.com', shell=True),
            'instagram': lambda: subprocess.Popen('start chrome https://www.instagram.com', shell=True),
            'facebook': lambda: subprocess.Popen('start chrome https://www.facebook.com', shell=True),
            'twitter': lambda: subprocess.Popen('start chrome https://www.twitter.com', shell=True),
            'linkedin': lambda: subprocess.Popen('start chrome https://www.linkedin.com', shell=True),
            'whatsapp_web': lambda: subprocess.Popen('start chrome https://web.whatsapp.com', shell=True),
            'gmail': lambda: subprocess.Popen('start chrome https://mail.google.com', shell=True),
            'netflix': lambda: subprocess.Popen('start chrome https://www.netflix.com', shell=True),
            
            # Volume
            'volume_up': lambda: pyautogui.press('volumeup'),
            'volume_down': lambda: pyautogui.press('volumedown'),
            'mute': lambda: pyautogui.press('volumemute'),
            
            # Screen
            'screenshot': lambda: pyautogui.screenshot().save(f'screenshot_{datetime.now().strftime("%Y%m%d_%H%M%S")}.png'),
            'desktop': lambda: pyautogui.hotkey('win', 'd'),
            'minimize_all': lambda: pyautogui.hotkey('win', 'm'),
            'brightness_up': self._brightness_up,
            'brightness_down': self._brightness_down,
            
            # Keyboard
            'alt_tab': lambda: pyautogui.hotkey('alt', 'tab'),
            'copy': lambda: pyautogui.hotkey('ctrl', 'c'),
            'paste': lambda: pyautogui.hotkey('ctrl', 'v'),
            'save': lambda: pyautogui.hotkey('ctrl', 's'),
            'undo': lambda: pyautogui.hotkey('ctrl', 'z'),
            'select_all': lambda: pyautogui.hotkey('ctrl', 'a'),
            
            # Close apps
            'close_chrome': lambda: subprocess.run('taskkill /f /im chrome.exe', shell=True),
            'close_edge': lambda: subprocess.run('taskkill /f /im msedge.exe', shell=True),
            'close_notepad': lambda: subprocess.run('taskkill /f /im notepad.exe', shell=True),
            
            # Folders
            'downloads': lambda: subprocess.run('explorer shell:Downloads', shell=True),
            'documents': lambda: subprocess.run('explorer shell:Personal', shell=True),
            'pictures': lambda: subprocess.run('explorer shell:MyPictures', shell=True),
            
            # System info
            'cpu': lambda: psutil.cpu_percent(interval=1),
            'memory': lambda: psutil.virtual_memory().percent,
            'battery': lambda: psutil.sensors_battery().percent if psutil.sensors_battery() else None,
            'time': lambda: datetime.now().strftime('%I:%M %p'),
            'date': lambda: datetime.now().strftime('%A, %B %d, %Y'),
            
            # AI Control
            'switch_to_gemini': self._switch_to_gemini,
            'switch_to_groq': self._switch_to_groq,
            'current_ai': self._get_current_ai,
            'switch_language_hindi': self._switch_to_hindi,
            'switch_language_kannada': self._switch_to_kannada,
            'switch_language_english': self._switch_to_english,
            
            # Calendar
            'schedule': self._schedule_event,
            'show_calendar': self._show_calendar,
            
            # Advanced AI Features
            'daily_briefing': self._daily_briefing,
            'predictive_assistance': self._predictive_assistance,
            'context_memory_store': self._context_memory_store,
            'context_memory_recall': self._context_memory_recall,
            'recall': self._context_memory_recall,
            
            # Security & Authentication
            'file_vault_encrypt': self._file_vault_encrypt,
            'file_vault_decrypt': self._file_vault_decrypt,
            'anomaly_detection': self._anomaly_detection,
            'phishing_scan': self._phishing_scan,
            'parental_control': self._parental_control,
            
            # Cloud & Multi-Device
            'cloud_backup': self._cloud_backup,
            'email_summarize': self._email_summarize,
            'sync_devices': self._sync_devices,
            
            # AI Productivity
            'realtime_transcription': self._realtime_transcription,
            'summarize_meeting': self._summarize_meeting,
            'smart_clipboard': self._smart_clipboard,
            'document_qa': self._document_qa,
            'ai_presentation': self._ai_presentation,
            
            # Smart Home
            'smart_home_control': self._smart_home_control,
            'set_home_scene': self._set_home_scene,
            'security_camera': self._security_camera,
            'energy_monitoring': self._energy_monitoring,
            
            # Entertainment Plus
            'ai_dj_mode': self._ai_dj_mode,
            'trivia_game': self._trivia_game,
            'storytelling': self._storytelling,
            'fitness_coach': self._fitness_coach,
            
            # Health & Wellness
            'posture_detection': self._posture_detection,
            'eye_care_mode': self._eye_care_mode,
            'daily_health_log': self._daily_health_log,
            'mood_tracker': self._mood_tracker,
            'meditation_prompt': self._meditation_prompt,
            
            # System Monitoring
            'system_monitor_live': self._system_monitor_live,
            'auto_fix_system': self._auto_fix_system,
            
            # All Advanced AI Features Integration
            'manage_package': self._manage_package,
            'docker_control': self._docker_control,
            'context_memory_store': self._context_memory_store,
            'context_memory_recall': self._context_memory_recall,
            'adaptive_learning': self._adaptive_learning,
            'check_proactive': self._check_proactive,
            'enable_proactive_mode': self._enable_proactive_mode,
            'enable proactive mode': self._enable_proactive_mode,
            'disable_proactive_mode': self._disable_proactive_mode,
            'disable proactive mode': self._disable_proactive_mode,
            'manual_learn': self._manual_learn,
            'file_vault_encrypt': self._file_vault_encrypt,
            'file_vault_decrypt': self._file_vault_decrypt,
            'anomaly_detection': self._anomaly_detection,
            'phishing_scan': self._phishing_scan,
            'parental_control': self._parental_control,
            'calendar_schedule': self._calendar_schedule,
            'cloud_backup': self._cloud_backup,
            'realtime_transcription': self._realtime_transcription,
            'summarize_meeting': self._summarize_meeting,
            'smart_clipboard': self._smart_clipboard,
            'document_qa': self._document_qa,
            'ai_presentation': self._ai_presentation,
            'smart_home_control': self._smart_home_control,
            'set_home_scene': self._set_home_scene,
            'security_camera': self._security_camera,
            'energy_monitoring': self._energy_monitoring,
            'ai_dj_mode': self._ai_dj_mode,
            'trivia_game': self._trivia_game,
            'storytelling': self._storytelling,
            'fitness_coach': self._fitness_coach,
            'debug_screen': self._debug_screen_code,
            'fix_my_code': self._debug_screen_code,
            'check_code': self._debug_screen_code,
            'code_agent': self._code_agent,
            'research_agent': self._research_agent,
            'organizer_agent': self._organizer_agent,
            'multi_agent_collab': self._multi_agent_collab,
            'scholar_search': self._scholar_search,
            'stock_updates': self._stock_updates,
            'crypto_updates': self._crypto_updates,
            'realtime_translation': self._realtime_translation,
            'posture_detection': self._posture_detection,
            'eye_care_mode': self._eye_care_mode,
            'daily_health_log': self._daily_health_log,
            'mood_tracker': self._mood_tracker,
            'meditation_prompt': self._meditation_prompt,
            
            # Face Auth
            'enable_face_auth': self._enable_face_auth,
            'disable_face_auth': self._disable_face_auth,
            'face_auth_status': self._get_face_auth_status,
            
            # Voice Gender Control
            'switch_to_male_voice': self._switch_to_male_voice,
            'switch_to_female_voice': self._switch_to_female_voice,
            'male_voice': self._switch_to_male_voice,
            'female_voice': self._switch_to_female_voice,
            'current_voice_gender': self._get_current_voice_gender,
            'voice_status': self._get_current_voice_gender,
            

            
            # Media Controls
            'play_pause': self._play_pause,
            'next_track': self._next_track,
            'previous_track': self._previous_track,
            'stop_media': self._stop_media,
            
            # Window Management
            'maximize_window': self._maximize_window,
            'minimize_window': self._minimize_window,
            'split_screen_left': self._split_screen_left,
            'split_screen_right': self._split_screen_right,
            'close_window': self._close_window,
            'switch_window': self._switch_window,
            
            # Text Operations
            'find_text': self._find_text,
            'replace_text': self._replace_text,
            'new_document': self._new_document,
            'print_document': self._print_document,
            'zoom_in': self._zoom_in,
            'zoom_out': self._zoom_out,
            
            # Security Features
            'clear_clipboard': self._clear_clipboard,
            'clear_history': self._clear_browser_history,
            'empty_recycle_bin': self._empty_recycle_bin,
            'lock_screen': self._lock_screen,
            
            # Automation
            'set_reminder': self._set_reminder,
            'schedule_shutdown': self._schedule_shutdown,
            'auto_backup': self._backup_files,
            'clean_temp': self._clean_temp_files,
            
            # Entertainment
            'play_music': self._play_music,
            'random_wallpaper': self._change_wallpaper,
            'joke': self._tell_joke,
   
            'news': self._get_news,
            'quote': self._get_quote,
            
            # Voice Mouse Control
            'move_mouse_up': self._move_mouse_up,
            'move_mouse_down': self._move_mouse_down,
            'move_mouse_left': self._move_mouse_left,
            'move_mouse_right': self._move_mouse_right,
            'move_mouse_center': self._move_mouse_center,
            'left_click': self._left_click,
            'right_click': self._right_click,
            'double_click': self._double_click,
            'start_drag': self._start_drag,
            'drop_here': self._drop_here,
            'scroll_up': self._scroll_up,
            'scroll_down': self._scroll_down,
            'scroll_to_top': self._scroll_to_top,
            
            # Voice Keyboard Control
            'type_text': self._type_text,
            'press_enter': self._press_enter,
            'press_tab': self._press_tab,
            'press_escape': self._press_escape,
            'press_backspace': self._press_backspace,
            'press_delete': self._press_delete,
            'go_to_beginning': self._go_to_beginning,
            'go_to_end': self._go_to_end,
            
            # ALL ADVANCED FEATURES INTEGRATED
            # File Operations
            'create_folder': self._create_folder,
            'delete_file': self._delete_file,
            'search_files': self._search_files,
            'copy_file': self._copy_file,
            'move_file': self._move_file,
            
            # Network & Internet
            'check_internet': self._ping_test,
            'ip_address': self._get_ip,
            'wifi_password': self._get_wifi_password,
            'network_speed': self._speed_test,
            
            # System Monitoring
            'disk_space': self._get_disk_space,
            'running_processes': self._list_processes,
            'system_uptime': self._get_uptime,
            'temperature': self._get_cpu_temp,
            
            # Advanced Window Management
            'next_window': self._next_window,
            'previous_window': self._previous_window,
            'close_all_windows': self._close_all_windows,
            'snap_left': self._snap_left,
            'snap_right': self._snap_right,
            'full_screen': self._full_screen,
            'restore_window': self._restore_window,
            
            # Advanced File Operations
            'open_recent_file': self._open_recent_file,
            'create_new_file': self._create_new_file,
            'rename_file': self._rename_file,
            'duplicate_file': self._duplicate_file,
            'compress_file': self._compress_file,
            'extract_archive': self._extract_archive,
            
            # Web Browsing Control
            'open_new_tab': self._open_new_tab,
            'close_current_tab': self._close_current_tab,
            'switch_to_next_tab': self._switch_to_next_tab,
            'switch_to_previous_tab': self._switch_to_previous_tab,
            'refresh_page': self._refresh_page,
            'go_back': self._go_back,
            'go_forward': self._go_forward,
            'bookmark_page': self._bookmark_page,
            'open_bookmarks': self._open_bookmarks,
            'search_web': self._search_web,
            
            # Advanced Media Control
            'skip_forward': self._skip_forward,
            'skip_backward': self._skip_backward,
            'increase_speed': self._increase_speed,
            'decrease_speed': self._decrease_speed,
            'toggle_fullscreen': self._toggle_fullscreen,
            'toggle_subtitles': self._toggle_subtitles,
            
            # System Information
            'show_system_info': self._show_system_info,
            'check_updates': self._check_updates,
            'show_installed_programs': self._show_installed_programs,
            'show_startup_programs': self._show_startup_programs,
            'show_network_info': self._show_network_info,
            
            # Voice Dictation
            'start_dictation': self._start_dictation,
            'stop_dictation': self._stop_dictation,
            'dictate_email': self._dictate_email,
            'dictate_document': self._dictate_document,
            
            # Screen Control
            'take_screenshot_window': self._take_screenshot_window,
            'take_screenshot_area': self._take_screenshot_area,
            'start_screen_recording': self._start_screen_recording,
            'stop_screen_recording': self._stop_screen_recording,
            
            # Power Management
            'hibernate_computer': self._hibernate_computer,
            'log_off': self._log_off,
            'switch_user': self._switch_user,
            'enable_airplane_mode': self._enable_airplane_mode,
            'disable_airplane_mode': self._disable_airplane_mode,
            
            # Accessibility Features
            'enable_narrator': self._enable_narrator,
            'disable_narrator': self._disable_narrator,
            'enable_magnifier': self._enable_magnifier,
            'disable_magnifier': self._disable_magnifier,
            'high_contrast_mode': self._high_contrast_mode,
            
            # Network Control
            'connect_wifi': self._connect_wifi,
            'disconnect_wifi': self._disconnect_wifi,
            'show_wifi_networks': self._show_wifi_networks,
            'enable_hotspot': self._enable_hotspot,
            'disable_hotspot': self._disable_hotspot,
            
            # Advanced Search
            'search_files_content': self._search_files_content,
            'search_registry': self._search_registry,
            'search_installed_software': self._search_installed_software,
            'find_large_files': self._find_large_files,
            'find_duplicate_files': self._find_duplicate_files,
            
            # Smart Home Integration
            'smart_lights': self._control_smart_lights,
            'smart_fan': self._control_smart_fan,
            'smart_ac': self._control_smart_ac,
            'home_scene': self._set_home_scene,
            
            # Advanced AI Capabilities
            'generate_code': self._generate_code,
            'debug_code': self._debug_code,
            'translate_text': self._translate_text,
            'summarize_text': self._summarize_text,
            'analyze_image': self._analyze_image,
            
            # Productivity & Office
            'send_email': self._send_email,
            'schedule_meeting': self._schedule_meeting,
            'create_task': self._create_task,
            'convert_document': self._convert_document,
            'merge_pdf': self._merge_pdf,
            
            # Developer Tools
            'git_status': self._git_status,
            'git_commit': self._git_commit,
            'run_tests': self._run_tests,
            'format_code': self._format_code,
            'api_test': self._api_test,
            
            # Health & Wellness
            'water_reminder': self._water_reminder,
            'break_reminder': self._break_reminder,
            'eye_care': self._eye_care_reminder,
            'fitness_track': self._fitness_track,
            
            # Advanced System Control
            'registry_edit': self._registry_edit,
            'service_control': self._service_control,
            'driver_update': self._driver_update,
            'system_optimize': self._system_optimize,
            'performance_monitor': self._performance_monitor,
            
            # Communication & Social
            'social_post': self._social_post,
            'compose_email': self._compose_email,
            'message_template': self._message_template,
            'contact_search': self._contact_search,
            
            # Learning & Education
            'wikipedia_search': self._wikipedia_search,
            'dictionary_lookup': self._dictionary_lookup,
            'unit_convert': self._unit_convert,
            'math_calculate': self._math_calculate,
            'language_learn': self._language_learn,
            
            # Entertainment Plus
            'movie_recommend': self._movie_recommend,
            'book_suggest': self._book_suggest,
            'game_launch': self._game_launch,
            'streaming_control': self._streaming_control,
            'playlist_manage': self._playlist_manage,
            
            # Advanced Automation
            'workflow_automate': self._workflow_automate,
            'batch_operations': self._batch_operations,
            'scheduled_tasks': self._scheduled_tasks,
            'system_maintenance': self._system_maintenance,
            'auto_updates': self._auto_updates,
            
            # Built-in Entertainment
            'tell_joke': self._tell_joke,
            'get_quote': self._get_quote,
       
            'get_news': self._get_news,
            
            # YouTube Automation
            'youtube_play': self._youtube_play,
            'youtube_pause': self._youtube_pause,
            'youtube_next': self._youtube_next,
            'youtube_previous': self._youtube_previous,
            'youtube_fullscreen': self._youtube_fullscreen,
            'youtube_volume_up': self._youtube_volume_up,
            'youtube_volume_down': self._youtube_volume_down,
            'youtube_mute': self._youtube_mute,
            'youtube_speed_up': self._youtube_speed_up,
            'youtube_speed_down': self._youtube_speed_down,
            'youtube_skip_forward': self._youtube_skip_forward,
            'youtube_skip_backward': self._youtube_skip_backward,
            'youtube_search': self._youtube_search,
            'youtube_subscribe': self._youtube_subscribe,
            'youtube_like': self._youtube_like,
            'youtube_dislike': self._youtube_dislike,
            'youtube_comment': self._youtube_comment,
            'youtube_share': self._youtube_share,
            'youtube_theater_mode': self._youtube_theater_mode,
            'youtube_miniplayer': self._youtube_miniplayer,
            'youtube_captions': self._youtube_captions,
            'play_video': self._play_video,
            'play_movie': self._play_movie,
            'play_song': self._play_song,
            'search_and_play': self._search_and_play,
            
            # Multiple App/Website Opening
     
            
            # Chrome Automation
            'chrome_new_tab': self._chrome_new_tab,
            'chrome_close_tab': self._chrome_close_tab,
            'chrome_next_tab': self._chrome_next_tab,
            'chrome_previous_tab': self._chrome_previous_tab,
            'chrome_reload': self._chrome_reload,
            'chrome_back': self._chrome_back,
            'chrome_forward': self._chrome_forward,
            'chrome_home': self._chrome_home,
            'chrome_bookmark': self._chrome_bookmark,
            'chrome_history': self._chrome_history,
            'chrome_downloads': self._chrome_downloads,
            'chrome_incognito': self._chrome_incognito,
            'chrome_developer_tools': self._chrome_developer_tools,
            'chrome_zoom_in': self._chrome_zoom_in,
            'chrome_zoom_out': self._chrome_zoom_out,
            'chrome_zoom_reset': self._chrome_zoom_reset,
            'chrome_find': self._chrome_find,
            'chrome_print': self._chrome_print,
            'chrome_save_page': self._chrome_save_page,
            'chrome_view_source': self._chrome_view_source,
            'chrome_extensions': self._chrome_extensions,
            'chrome_settings': self._chrome_settings,
            'chrome_clear_data': self._chrome_clear_data,
            
            # Proactive mode commands
            'enable proactive mode': self._enable_proactive_mode,
            'disable proactive mode': self._disable_proactive_mode,
            
            # Gesture Control
            'start_gesture_control': self._start_gesture_control,
            'stop_gesture_control': self._stop_gesture_control,
            'hand_control': self._start_gesture_control,
            'eye_control': self._start_gesture_control,
            'head_control': self._start_gesture_control,
            'gesture_control': self._start_gesture_control,
            'start gesture control': self._start_gesture_control,
            'stop gesture control': self._stop_gesture_control,
            
            # Code Review Functions
            'code_review': self._code_review,
            'folder_review': self._folder_review,
            'file_review': self._file_review,
            'live_code_review': self._live_code_review,
            'start_live_review': self._start_live_review,
            'stop_live_review': self._stop_live_review,
            
            # Continuous Listening Functions
         
            

        }
    
    def _get_ai_provider(self):
        try:
            with open('ai_config.json', 'r') as f:
                config = json.load(f)
                return config.get('ai_provider', 'groq')
        except:
            return 'groq'
    
    def _set_ai_provider(self, provider):
        try:
            config = {'ai_provider': provider}
            with open('ai_config.json', 'w') as f:
                json.dump(config, f)
            self.ai_provider = provider
            self._init_ai_models()
            return True
        except:
            return False
    
    def _init_ai_models(self):
        if self.ai_provider == 'groq':
            try:
                from groq import Groq
                from engine.groq_config import GROQ_API_KEY
                self.groq_client = Groq(api_key=GROQ_API_KEY)
                # Test the API key with a simple request
                test_response = self.groq_client.chat.completions.create(
                    model="llama-3.1-8b-instant",
                    messages=[{"role": "user", "content": "test"}],
                    max_tokens=1
                )
            except Exception as e:
                print(f"Groq failed: {e}, switching to Gemini")
                self.ai_provider = 'gemini'
                self._init_gemini()
        else:
            self._init_gemini()
    
    def _init_gemini(self):
        try:
            import google.generativeai as genai
            from engine.gemini_config import GEMINI_API_KEY
            genai.configure(api_key=GEMINI_API_KEY)
            self.gemini_model = genai.GenerativeModel('gemini-2.0-flash')
            print("Using Gemini AI")
        except Exception as e:
            print(f"AI init error: {e}")
    
    def execute(self, query):
        try:
            # Handle voice gender switching commands FIRST (highest priority)
            query_lower = query.lower().strip()
            
            # Exact voice command matching
            if 'female voice' in query_lower:
                return self._switch_to_female_voice()
            elif 'male voice' in query_lower:
                return self._switch_to_male_voice()
            elif 'switch to female' in query_lower:
                return self._switch_to_female_voice()
            elif 'switch to male' in query_lower:
                return self._switch_to_male_voice()
            elif 'current voice' in query_lower or 'voice status' in query_lower:
                return self._get_current_voice_gender()
            
            # Process multilingual commands AFTER English commands
            # Skip multilingual processing for basic English "open" commands
            if not query.lower().startswith('open ') and self.multilingual:
                # Check if it's a language switching command
                if any(word in query.lower() for word in ['switch to', 'change language', '‡§≠‡§æ‡§∑‡§æ', '‡¶≠‡¶æ‡¶∑‡¶æ', '‡™≠‡™æ‡¶∑‡™æ', '‡≤≠‡≤æ‡≤∑‡≥Ü', '‡¥≠‡¥æ‡¥∑', '‡§≠‡§æ‡§∑‡§æ', '‡ÆÆ‡Øä‡Æ¥‡Æø', '‡∞≠‡∞æ‡∞∑', 'ÿ≤ÿ®ÿßŸÜ']):
                    response = self.multilingual.process_multilingual_command(query)
                    return response
                
                # Process command in current language context only for non-English commands
                detected_lang = self.multilingual.detect_language(query)
                if detected_lang != 'english':
                    response = self.multilingual.process_command_in_language(query, self.multilingual.current_language)
                    if response != self.multilingual.get_response('processing'):
                        return response
            # Handle continuous listening commands FIRST
            query_clean = query.lower().strip()
          
            
            # Handle code review commands FIRST to prevent interference
            if query_clean == 'code review':
                return self._code_review()
            
            if query_clean == 'folder review' or query_clean == 'review':
                return self._folder_review()
            
            if query_clean.startswith('folder review '):
                folder_name = query[14:].strip()
                return self._folder_review(folder_name)
            
            if query_clean.startswith('file review '):
                file_path = query[12:].strip()
                return self._file_review(file_path)
            
            if query_clean == 'start live review':
                return self._start_live_review()
            
            if query_clean == 'stop live review':
                return self._stop_live_review()
            
            if query_clean == 'live code review':
                return self._live_code_review()
            
            # Skip all other processing for review commands
            if 'review' in query_clean and not query_clean.startswith('folder review ') and not query_clean.startswith('live'):
                return self._folder_review()
            
            # Check for dynamic commands - HIGHEST PRIORITY
            import re
            
            # Volume/brightness with numbers - PROCESS IMMEDIATELY
            volume_match = re.search(r'(?:set )?volume (?:to )?([0-9]+)', query.lower())
            brightness_match = re.search(r'(?:set )?brightness (?:to )?([0-9]+)', query.lower())
            
            if volume_match:
                level = int(volume_match.group(1))
                self._set_volume(level)
                return f"Volume set to {level}%"
            
            if brightness_match:
                level = int(brightness_match.group(1))
                self._set_brightness(level)
                return f"Brightness set to {level}%"
            
            # Handle "open" commands - HIGHEST PRIORITY
            if query.lower().startswith('open '):
                content = query[5:].strip().lower()  # Remove 'open '
                
                # Direct mappings for open commands
                direct_mappings = {
                    'facebook': 'facebook',
                    'instagram': 'instagram',
                    'google': 'google',
                    'youtube': 'youtube',
                    'gmail': 'gmail',
                    'twitter': 'twitter',
                    'linkedin': 'linkedin',
                    'whatsapp': 'whatsapp_web',
                    'netflix': 'netflix',
                    'amazon': 'amazon',
                    'flipkart': 'flipkart',
                    'wikipedia': 'wikipedia',
                    'stackoverflow': 'stackoverflow',
                    'github': 'github',
                    'notepad': 'notepad',
                    'calculator': 'calculator',
                    'chrome': 'chrome',
                    'edge': 'edge',
                    'firefox': 'firefox',
                    'word': 'word',
                    'excel': 'excel',
                    'powerpoint': 'powerpoint',
                    'vlc': 'vlc',
                    'vscode': 'vscode',
                    'spotify': 'spotify',
                    'steam': 'steam',
                    'explorer': 'explorer',
                    'settings': 'settings',
                    'taskmanager': 'taskmanager',
                    'cmd': 'cmd',
                    'paint': 'paint'
                }
                
                # Check for exact single command match first
                if content in direct_mappings:
                    func_name = direct_mappings[content]
                    try:
                        result = self.functions[func_name]()
                        return self._get_response(func_name, result)
                    except Exception as e:
                        return f"Error opening {content}"
                
            
                
                # If not found in direct mappings, try original function check
                if content in self.functions:
                    result = self.functions[content]()
                    return self._get_response(content, result)
            
            # Handle volume commands with better parsing
            if 'volume' in query.lower():
                if 'up' in query.lower() or 'increase' in query.lower():
                    result = self.functions['volume_up']()
                    return self._get_response('volume_up', result)
                elif 'down' in query.lower() or 'decrease' in query.lower():
                    result = self.functions['volume_down']()
                    return self._get_response('volume_down', result)
                elif 'mute' in query.lower():
                    result = self.functions['mute']()
                    return self._get_response('mute', result)
            
        
            
            # Handle brightness commands
            if 'brightness' in query.lower():
                if 'up' in query.lower() or 'increase' in query.lower():
                    result = self.functions['brightness_up']()
                    return self._get_response('brightness_up', result)
                elif 'down' in query.lower() or 'decrease' in query.lower():
                    result = self.functions['brightness_down']()
                    return self._get_response('brightness_down', result)
            
            # Chrome automation commands
            if query.lower().startswith('chrome '):
                chrome_cmd = query.lower().replace('chrome ', '').strip().replace(' ', '_')
                chrome_function = f'chrome_{chrome_cmd}'
                if chrome_function in self.functions:
                    result = self.functions[chrome_function]()
                    return self._get_response(chrome_function, result)
            
            # YouTube automation commands  
            if query.lower().startswith('youtube '):
                youtube_cmd = query.lower().replace('youtube ', '').strip().replace(' ', '_')
                youtube_function = f'youtube_{youtube_cmd}'
                if youtube_function in self.functions:
                    result = self.functions[youtube_function]()
                    return self._get_response(youtube_function, result)
            
            # Email summarization with content
            if query.lower().startswith('summarize email '):
                email_content = query[16:].strip()  # Remove 'summarize email '
                try:
                    from engine.voice_advanced_ai import voice_advanced_ai
                    return voice_advanced_ai.email_summarize(email_content)
                except:
                    return "Error summarizing email"
            
            # Calendar commands - force use of voice_advanced_ai
            if 'show calendar' in query.lower() or 'check calendar' in query.lower() or 'add event' in query.lower():
                try:
                    from engine.voice_advanced_ai import get_voice_advanced_response
                    return get_voice_advanced_response(query)
                except:
                    pass
            
            # Package management commands
            if query.lower().startswith('install '):
                package = query[8:].strip()  # Remove 'install '
                try:
                    from engine.voice_advanced_ai import voice_advanced_ai
                    return voice_advanced_ai.install_package(package)
                except:
                    return "Error installing package"
            
            if query.lower() == 'list packages':
                try:
                    from engine.voice_advanced_ai import voice_advanced_ai
                    return voice_advanced_ai.list_packages()
                except:
                    return "Error listing packages"
            
            # Check for research agent before search patterns
            if 'research agent' in query.lower() or 'research help' in query.lower():
                return self._research_agent()
            
            # Health & Wellness dynamic commands
            if query.lower().startswith('health log '):
                entry = query[11:].strip()  # Remove 'health log '
                try:
                    from engine.voice_advanced_ai import voice_advanced_ai
                    return voice_advanced_ai.daily_health_log(entry)
                except:
                    return "Error logging health data"
            
            if query.lower().startswith('mood tracker ') or query.lower().startswith('track mood '):
                if query.lower().startswith('mood tracker '):
                    mood = query[13:].strip()  # Remove 'mood tracker '
                else:
                    mood = query[11:].strip()  # Remove 'track mood '
                try:
                    from engine.voice_advanced_ai import voice_advanced_ai
                    return voice_advanced_ai.mood_tracker(mood)
                except:
                    return "Error tracking mood"
            
            if query.lower().startswith('meditate ') or query.lower().startswith('meditation '):
                if query.lower().startswith('meditate '):
                    duration = query[9:].strip()  # Remove 'meditate '
                else:
                    duration = query[11:].strip()  # Remove 'meditation '
                try:
                    from engine.voice_advanced_ai import voice_advanced_ai
                    if duration and duration.isdigit():
                        return voice_advanced_ai.meditation_prompt(duration)
                    return voice_advanced_ai.meditation_prompt()
                except:
                    return "Error starting meditation"
            
            # Security & Authentication dynamic commands
            if query.lower().startswith('encrypt file '):
                file_path = query[13:].strip()  # Remove 'encrypt file '
                try:
                    from engine.voice_advanced_ai import voice_advanced_ai
                    return voice_advanced_ai.file_vault_encrypt(file_path)
                except:
                    return "Error encrypting file"
            
            if query.lower().startswith('decrypt file '):
                file_path = query[13:].strip()  # Remove 'decrypt file '
                try:
                    from engine.voice_advanced_ai import voice_advanced_ai
                    return voice_advanced_ai.file_vault_decrypt(file_path)
                except:
                    return "Error decrypting file"
            
            if query.lower().startswith('phishing scan '):
                url = query[14:].strip()  # Remove 'phishing scan '
                try:
                    from engine.voice_advanced_ai import voice_advanced_ai
                    return voice_advanced_ai.phishing_malware_scan_link(url)
                except:
                    return "Error scanning URL"
            
            if query.lower().startswith('parental control '):
                action = query[17:].strip()  # Remove 'parental control '
                try:
                    from engine.voice_advanced_ai import voice_advanced_ai
                    return voice_advanced_ai.parental_control_set(action)
                except:
                    return "Error with parental control"
            
            # Adaptive Learning dynamic commands
            if query.lower().startswith('adaptive learning '):
                action = query[18:].strip()  # Remove 'adaptive learning '
                try:
                    from engine.voice_advanced_ai import voice_advanced_ai
                    return voice_advanced_ai.adaptive_learning(action)
                except:
                    return "Error with adaptive learning"
            
            if query.lower().startswith('manual learn '):
                action = query[13:].strip()  # Remove 'manual learn '
                try:
                    from engine.voice_advanced_ai import voice_advanced_ai
                    return voice_advanced_ai.manual_learn(action)
                except:
                    return "Error with manual learning"
            
            if query.lower().startswith('teach jarvis '):
                action = query[14:].strip()  # Remove 'teach jarvis '
                try:
                    from engine.voice_advanced_ai import voice_advanced_ai
                    return voice_advanced_ai.manual_learn(action)
                except:
                    return "Error teaching Jarvis"
            
            # Check new features FIRST before any other processing
            new_feature_result = self._check_new_features(query)
            if new_feature_result:
                return new_feature_result
            
            # Dynamic search and play commands - more flexible detection
            play_patterns = [
                r'(?:play|search)\s+(?:video|movie|song|music|on youtube)?\s*(.+)',
                r'youtube\s+(?:play|search)\s+(.+)',
                r'(?:play|search)\s+(.+?)\s+(?:on youtube|video|song|music)',
                r'(?:play|search)\s+(.+)'
            ]
            
            for pattern in play_patterns:
                play_match = re.search(pattern, query.lower())
                if play_match:
                    search_term = play_match.group(1).strip()
                    # Check if it's likely a media search
                    media_keywords = ['youtube', 'video', 'movie', 'song', 'music', 'play', 'search']
                    if any(keyword in query.lower() for keyword in media_keywords) and search_term:
                        # Exclude system commands
                        system_commands = ['notepad', 'calculator', 'chrome', 'word', 'excel']
                        if not any(cmd in search_term.lower() for cmd in system_commands):
                            return self._search_and_play(search_term)
                    break
            
            # Face auth commands - handle before general on/off
            if 'face auth' in query.lower() or 'face recognition' in query.lower():
                if 'enable' in query.lower() or 'turn on' in query.lower():
                    result = self._enable_face_auth()
                    return self._get_response('enable_face_auth', result)
                elif 'disable' in query.lower() or 'turn off' in query.lower():
                    result = self._disable_face_auth()
                    return self._get_response('disable_face_auth', result)
                elif 'status' in query.lower() or 'check' in query.lower():
                    result = self._get_face_auth_status()
                    return self._get_response('face_auth_status', result)
            
            # Dynamic on/off commands using AI
            on_off_match = re.search(r'(?:turn (on|off)|(?:enable|disable)) (.+)', query.lower())
            if on_off_match:
                action = on_off_match.group(1) if on_off_match.group(1) else ('on' if 'enable' in query.lower() else 'off')
                feature = on_off_match.group(2).strip()
                # Skip face auth as it's handled above
                if 'face' not in feature:
                    return self._handle_on_off(feature, action)
            
            if volume_match:
                level = int(volume_match.group(1))
                self._set_volume(level)
                return f"Volume set to {level}%"
            
            if brightness_match:
                level = int(brightness_match.group(1))
                self._set_brightness(level)
                return f"Brightness set to {level}%"
            

            
            if self._is_question(query):
                return self._answer_question(query)
            
            # Enhanced command matching with better natural language processing
            query_lower = query.lower().strip()
            
            # First try exact matches
            if query_lower in self.functions:
                func_name = query_lower
            else:
                # Try natural language understanding with enhanced matching
                func_name = self.understand_natural_speech(query)
                
                # If still no match, try fuzzy matching for common commands
                if not func_name:
                    func_name = self._fuzzy_match_command(query_lower)
                
                if not func_name:
                    # Fallback to advanced AI functions
                    try:
                        from engine.voice_advanced_ai import get_voice_advanced_response
                        advanced_response = get_voice_advanced_response(query)
                        if advanced_response and "Voice command not recognized" not in advanced_response and "Error:" not in advanced_response:
                            return advanced_response
                    except:
                        pass
                    
                    # Final fallback to AI model for function selection
                    prompt = f'User said: "{query}"\nAvailable functions: {list(self.functions.keys())}\nRespond with ONLY the function name or "none":'
                    
                    try:
                        if self.ai_provider == 'groq':
                            response = from engine.ai_fallback_system import try_all_ai_providers
func_name = try_all_ai_providers(prompt)
if not func_name:
    func_name = self._simple_fallback_match(query)
                        else:
                            response = self.gemini_model.generate_content(prompt)
                            func_name = response.text.strip()
                    except Exception as e:
                        print(f"AI API error: {e}")
                        # Fallback to simple command matching
                        func_name = self._simple_fallback_match(query)

            if func_name in self.functions:
                result = self.functions[func_name]()
                # For advanced features, return the actual result
                advanced_result_features = ['joke', 'quote', 'disk_space', 'ip_address', 'system_uptime', 'temperature', 'running_processes', 'check_internet', 'wifi_password', 'network_speed', 'create_folder', 'delete_file', 'search_files', 'set_reminder', 'schedule_shutdown', 'auto_backup', 'clean_temp', 'move_mouse_up', 'move_mouse_down', 'move_mouse_left', 'move_mouse_right', 'move_mouse_center', 'left_click', 'right_click', 'double_click', 'start_drag', 'drop_here', 'scroll_up', 'scroll_down', 'scroll_to_top', 'type_text', 'press_enter', 'press_tab', 'press_escape', 'press_backspace', 'press_delete', 'go_to_beginning', 'go_to_end', 'play_video', 'play_movie', 'play_song', 'search_and_play', 'open_multiple', 'daily_briefing', 'predictive_assistance', 'context_memory_recall', 'show_calendar', 'schedule', 'email_summarize', 'sync_devices', 'system_monitor_live', 'auto_fix_system', 'manage_package', 'docker_control', 'adaptive_learning', 'check_proactive', 'enable_proactive_mode', 'disable_proactive_mode', 'manual_learn', 'file_vault_encrypt', 'file_vault_decrypt', 'anomaly_detection', 'phishing_scan', 'parental_control', 'calendar_schedule', 'cloud_backup', 'realtime_transcription', 'summarize_meeting', 'smart_clipboard', 'document_qa', 'ai_presentation', 'smart_home_control', 'set_home_scene', 'security_camera', 'energy_monitoring', 'ai_dj_mode', 'trivia_game', 'storytelling', 'fitness_coach', 'code_agent', 'research_agent', 'organizer_agent', 'multi_agent_collab', 'scholar_search', 'stock_updates', 'crypto_updates', 'realtime_translation', 'posture_detection', 'eye_care_mode', 'daily_health_log', 'mood_tracker', 'meditation_prompt', 'start_gesture_control', 'stop_gesture_control']
                if func_name in advanced_result_features:
                    return result
                response = self._get_response(func_name, result)
                return response
            else:
                if self._is_question(query):
                    response = self._answer_question(query)
                    return response
                # Try multilingual processing as fallback
                if self.multilingual:
                    ml_response = self.multilingual.process_command_in_language(query, self.multilingual.current_language)
                    if ml_response != self.multilingual.get_response('processing'):
                        return ml_response
                
                if self.multilingual:
                    response = self.multilingual.get_response('not_understood')
                else:
                    response = "I can help with commands or questions!"
                return response
                
        except Exception as e:
            print(f"Error: {e}")
            # Try simple fallback for basic commands
            fallback_result = self._simple_fallback_match(query)
            if fallback_result and fallback_result in self.functions:
                try:
                    result = self.functions[fallback_result]()
                    return self._get_response(fallback_result, result)
                except:
                    pass
            
            if self.multilingual:
                response = self.multilingual.get_response('error')
            else:
                response = "Something went wrong."
            return response
    
    def understand_natural_speech(self, query):
        """Complete natural language processing for ALL functions"""
        query = query.lower().strip()
        
        mappings = {
            'shutdown': ['shut down', 'turn off computer', 'power off', 'shutdown computer'],
            'restart': ['restart', 'reboot', 'restart computer', 'reboot system'],
            'sleep': ['sleep', 'put to sleep', 'sleep mode'],
            'lock': ['lock', 'lock screen', 'secure screen'],
            'hibernate': ['hibernate', 'deep sleep', 'hibernation'],
            'volume_up': ['volume up', 'louder', 'increase volume', 'make it louder', 'turn up sound', 'increase the volume'],
            'volume_down': ['volume down', 'quieter', 'decrease volume', 'make it quieter', 'turn down sound'],
            'mute': ['mute', 'silence', 'turn off sound', 'mute audio'],
            'screenshot': ['screenshot', 'take screenshot', 'capture screen', 'take a picture of screen'],
            'brightness_up': ['brightness up', 'brighter', 'increase brightness', 'brighten screen'],
            'brightness_down': ['brightness down', 'dimmer', 'decrease brightness', 'my screen is too bright'],
            'desktop': ['show desktop', 'go to desktop', 'minimize all'],
            'calculator': ['calculator', 'calc', 'open calculator'],
            'notepad': ['notepad', 'text editor', 'open notepad'],
            'chrome': ['chrome', 'browser', 'open chrome', 'web browser'],
            'edge': ['edge', 'microsoft edge', 'open edge'],
            'firefox': ['firefox', 'open firefox', 'mozilla'],
            'word': ['word', 'microsoft word', 'document editor'],
            'excel': ['excel', 'spreadsheet', 'microsoft excel'],
            'powerpoint': ['powerpoint', 'presentation', 'slides'],
            'vlc': ['vlc', 'video player', 'media player'],
            'vscode': ['vscode', 'code editor', 'visual studio'],
            'spotify': ['spotify', 'music', 'music player'],
            'steam': ['steam', 'games', 'gaming'],
            'explorer': ['explorer', 'file manager', 'files'],
            'settings': ['settings', 'system settings', 'control panel'],
            'taskmanager': ['task manager', 'processes', 'taskmanager'],
            'cmd': ['command prompt', 'cmd', 'terminal'],
            'paint': ['paint', 'drawing', 'mspaint'],
            'google': ['google', 'search', 'google search'],
            'youtube': ['youtube', 'videos', 'watch videos'],
            'wikipedia': ['wikipedia', 'wiki', 'encyclopedia'],
            'stackoverflow': ['stackoverflow', 'programming help', 'coding help'],
            'github': ['github', 'git', 'code repository'],
            'amazon': ['amazon', 'shopping', 'buy online'],
            'flipkart': ['flipkart', 'shopping india'],
            'instagram': ['instagram', 'insta', 'photos'],
            'facebook': ['facebook', 'fb', 'social media'],
            'twitter': ['twitter', 'tweets', 'social'],
            'linkedin': ['linkedin', 'professional network'],
            'whatsapp_web': ['whatsapp', 'messaging', 'chat'],
            'gmail': ['gmail', 'email', 'mail'],
            'netflix': ['netflix', 'movies', 'streaming'],
            'copy': ['copy', 'copy text', 'copy this'],
            'paste': ['paste', 'paste text', 'paste here'],
            'save': ['save', 'save file', 'save document'],
            'undo': ['undo', 'undo last action', 'go back'],
            'select_all': ['select all', 'select everything'],
            'alt_tab': ['switch window', 'alt tab', 'change window'],
            'time': ['time', 'what time is it', 'current time', 'tell me the time'],
            'date': ['date', 'what date is it', 'current date', 'today'],
            'cpu': ['cpu usage', 'processor usage', 'cpu load'],
            'memory': ['memory usage', 'ram usage', 'memory load'],
            'battery': ['battery', 'battery level', 'battery percentage'],
            'downloads': ['downloads', 'download folder'],
            'documents': ['documents', 'my documents'],
            'pictures': ['pictures', 'photos', 'image folder'],
            'switch_to_gemini': ['switch to gemini', 'use gemini', 'gemini ai'],
            'switch_to_groq': ['switch to groq', 'use groq', 'groq ai'],
            'current_ai': ['current ai', 'which ai', 'ai status'],
            'switch_language_hindi': ['hindi', 'switch to hindi'],
            'switch_language_kannada': ['kannada', 'switch to kannada'],
            'switch_language_english': ['english', 'switch to english'],
            'close_chrome': ['close chrome', 'quit chrome'],
            'close_edge': ['close edge', 'quit edge'],
            'close_notepad': ['close notepad', 'quit notepad'],
            'switch_to_male_voice': ['male voice', 'switch to male'],
            'switch_to_female_voice': ['female voice', 'switch to female'],
            'current_voice_gender': ['voice status', 'current voice'],
            'context_memory_recall': ['what do you remember', 'recall memory', 'show memories'],
            'daily_briefing': ['daily briefing', 'morning briefing'],
            'predictive_assistance': ['predictive help', 'smart suggestions'],
            'schedule': ['schedule meeting', 'add event', 'book appointment'],
            'show_calendar': ['show calendar', 'check calendar'],
            'posture_detection': ['posture check', 'check posture'],
            'eye_care_mode': ['eye care', 'protect eyes'],
            'daily_health_log': ['health log', 'log health'],
            'mood_tracker': ['mood tracker', 'track mood'],
            'meditation_prompt': ['meditate', 'meditation', 'relax'],
            'trivia_game': ['trivia', 'quiz game', 'test knowledge'],
            'storytelling': ['tell story', 'story time'],
            'fitness_coach': ['fitness coach', 'workout guide'],
            'ai_dj_mode': ['dj mode', 'music mix'],
            'code_agent': ['code help', 'programming assistant'],
            'research_agent': ['research help', 'research assistant'],
            'organizer_agent': ['organize', 'task organizer'],
            'smart_home_control': ['smart home', 'home automation'],
            'set_home_scene': ['home scene', 'set scene'],
            'start_gesture_control': ['gesture control', 'hand control'],
            'stop_gesture_control': ['stop gestures', 'disable gestures'],
            'code_review': ['code review', 'review code', 'check code'],
            'folder_review': ['folder review', 'review folder'],
            'live_code_review': ['live review', 'real time review'],
            'joke': ['tell joke', 'joke', 'make me laugh'],
            'quote': ['quote', 'inspirational quote', 'wisdom'],
    
            'news': ['news', 'latest news', 'headlines'],
            'disk_space': ['disk space', 'storage space', 'free space'],
            'system_uptime': ['uptime', 'system uptime', 'how long running'],
            'temperature': ['temperature', 'cpu temperature', 'system temp'],
            'running_processes': ['processes', 'running programs', 'active processes'],
            'check_internet': ['internet', 'check internet', 'connection test'],
            'ip_address': ['ip address', 'my ip', 'network address'],
            'wifi_password': ['wifi password', 'network password'],
            'network_speed': ['speed test', 'internet speed', 'connection speed'],
            'create_folder': ['create folder', 'new folder', 'make folder'],
            'delete_file': ['delete file', 'remove file'],
            'search_files': ['search files', 'find files'],
            'copy_file': ['copy file', 'duplicate file'],
            'move_file': ['move file', 'relocate file'],
            'maximize_window': ['maximize', 'maximize window', 'make bigger'],
            'minimize_window': ['minimize', 'minimize window', 'hide window'],
            'close_window': ['close window', 'close this'],
            'split_screen_left': ['split left', 'snap left', 'window left'],
            'split_screen_right': ['split right', 'snap right', 'window right'],
            'full_screen': ['full screen', 'fullscreen'],
            'play_pause': ['play', 'pause', 'play pause'],
            'next_track': ['next', 'next song', 'skip'],
            'previous_track': ['previous', 'previous song', 'back'],
            'stop_media': ['stop', 'stop playing'],
            'find_text': ['find', 'search text', 'find text'],
            'replace_text': ['replace', 'find replace'],
            'new_document': ['new document', 'new file'],
            'print_document': ['print', 'print document'],
            'zoom_in': ['zoom in', 'magnify', 'make bigger'],
            'zoom_out': ['zoom out', 'make smaller'],
            'clear_clipboard': ['clear clipboard', 'empty clipboard'],
            'clear_history': ['clear history', 'delete history'],
            'empty_recycle_bin': ['empty recycle bin', 'clear trash'],
            'lock_screen': ['lock screen', 'secure computer'],
            'set_reminder': ['set reminder', 'remind me'],
            'schedule_shutdown': ['schedule shutdown', 'auto shutdown'],
            'auto_backup': ['backup', 'backup files'],
            'clean_temp': ['clean temp', 'delete temp files'],
            'play_music': ['play music', 'start music'],
            'random_wallpaper': ['change wallpaper', 'new wallpaper'],
            'move_mouse_up': ['mouse up', 'move mouse up', 'cursor up'],
            'move_mouse_down': ['mouse down', 'move mouse down', 'cursor down'],
            'move_mouse_left': ['mouse left', 'move mouse left', 'cursor left'],
            'move_mouse_right': ['mouse right', 'move mouse right', 'cursor right'],
            'move_mouse_center': ['mouse center', 'center mouse'],
            'left_click': ['left click', 'click', 'mouse click'],
            'right_click': ['right click', 'context menu'],
            'double_click': ['double click', 'double tap'],
            'scroll_up': ['scroll up', 'page up'],
            'scroll_down': ['scroll down', 'page down'],
            'press_enter': ['press enter', 'hit enter', 'enter key'],
            'press_tab': ['press tab', 'tab key'],
            'press_escape': ['press escape', 'escape key'],
            'press_backspace': ['backspace', 'delete back'],
            'press_delete': ['delete key', 'delete forward'],
            'youtube_play': ['youtube play', 'play video'],
            'youtube_pause': ['youtube pause', 'pause video'],
            'youtube_next': ['youtube next', 'next video'],
            'youtube_previous': ['youtube previous', 'previous video'],
            'youtube_fullscreen': ['youtube fullscreen', 'video fullscreen'],
            'youtube_volume_up': ['youtube louder', 'video volume up'],
            'youtube_volume_down': ['youtube quieter', 'video volume down'],
            'youtube_mute': ['youtube mute', 'mute video'],
            'youtube_speed_up': ['youtube faster', 'speed up video'],
            'youtube_speed_down': ['youtube slower', 'slow down video'],
            'youtube_skip_forward': ['youtube skip', 'skip ahead'],
            'youtube_skip_backward': ['youtube back', 'skip back'],
            'youtube_search': ['youtube search', 'search video'],
            'youtube_subscribe': ['youtube subscribe', 'subscribe channel'],
            'youtube_like': ['youtube like', 'like video'],
            'youtube_theater_mode': ['theater mode', 'cinema mode'],
            'youtube_captions': ['captions', 'subtitles'],
            'chrome_new_tab': ['new tab', 'open tab'],
            'chrome_close_tab': ['close tab', 'close current tab'],
            'chrome_next_tab': ['next tab', 'switch tab'],
            'chrome_previous_tab': ['previous tab', 'last tab'],
            'chrome_reload': ['reload', 'refresh'],
            'chrome_back': ['go back', 'back page'],
            'chrome_forward': ['go forward', 'forward page'],
            'chrome_bookmark': ['bookmark', 'save bookmark'],
            'chrome_history': ['history', 'browser history'],
            'chrome_downloads': ['downloads', 'download history'],
            'chrome_incognito': ['incognito', 'private browsing'],
            'chrome_settings': ['chrome settings', 'browser settings'],
            'enable_face_auth': ['enable face auth', 'face recognition on'],
            'disable_face_auth': ['disable face auth', 'face recognition off'],
            'face_auth_status': ['face auth status', 'check face auth'],
            'system_monitor_live': ['system monitor', 'live monitoring'],
            'auto_fix_system': ['auto fix', 'fix system'],
            'performance_monitor': ['performance monitor', 'system performance'],
            'enable_narrator': ['narrator on', 'enable narrator'],
            'disable_narrator': ['narrator off', 'disable narrator'],
            'enable_magnifier': ['magnifier on', 'enable magnifier'],
            'disable_magnifier': ['magnifier off', 'disable magnifier'],
            'high_contrast_mode': ['high contrast', 'contrast mode'],
            'connect_wifi': ['connect wifi', 'join network'],
            'disconnect_wifi': ['disconnect wifi', 'leave network'],
            'show_wifi_networks': ['wifi networks', 'available networks'],
            'enable_hotspot': ['hotspot on', 'mobile hotspot'],
            'disable_hotspot': ['hotspot off', 'disable hotspot'],
            'search_files_content': ['search in files', 'find in files'],
            'find_large_files': ['large files', 'big files'],
            'find_duplicate_files': ['duplicate files', 'find duplicates'],
            'smart_lights': ['smart lights', 'control lights'],
            'smart_fan': ['smart fan', 'control fan'],
            'smart_ac': ['smart ac', 'air conditioning'],
            'generate_code': ['generate code', 'write code'],
            'debug_code': ['debug code', 'fix code'],
            'translate_text': ['translate', 'translate text'],
            'summarize_text': ['summarize', 'summary'],
            'analyze_image': ['analyze image', 'image analysis'],
            'send_email': ['send email', 'compose email'],
            'schedule_meeting': ['schedule meeting', 'book meeting'],
            'create_task': ['create task', 'new task'],
            'convert_document': ['convert document', 'change format'],
            'merge_pdf': ['merge pdf', 'combine pdf'],
            'git_status': ['git status', 'check git'],
            'git_commit': ['git commit', 'commit changes'],
            'run_tests': ['run tests', 'execute tests'],
            'format_code': ['format code', 'beautify code'],
            'api_test': ['api test', 'test api'],
            'water_reminder': ['water reminder', 'drink water'],
            'break_reminder': ['break reminder', 'take break'],
            'fitness_track': ['fitness track', 'exercise log'],
            'wikipedia_search': ['wikipedia', 'wiki search'],
            'dictionary_lookup': ['dictionary', 'word meaning'],
            'unit_convert': ['convert units', 'unit conversion'],
            'math_calculate': ['calculate', 'math calculation'],
            'language_learn': ['learn language', 'language learning'],
            'movie_recommend': ['movie recommendation', 'suggest movie'],
            'book_suggest': ['book suggestion', 'recommend book'],
            'game_launch': ['launch game', 'start game'],
            'streaming_control': ['streaming control', 'media streaming'],
            'playlist_manage': ['manage playlist', 'playlist control'],
            'workflow_automate': ['automate workflow', 'automation'],
            'batch_operations': ['batch operation', 'bulk operation'],
            'scheduled_tasks': ['scheduled task', 'task scheduler'],
            'system_maintenance': ['system maintenance', 'maintain system'],
            'auto_updates': ['auto updates', 'automatic updates'],
            'tell_joke': ['tell joke', 'joke', 'make me laugh'],
            'get_quote': ['quote', 'inspirational quote'],
      
            'get_news': ['news', 'latest news'],
            'play_video': ['play video', 'watch video'],
            'play_movie': ['play movie', 'watch movie'],
            'play_song': ['play song', 'play music'],
            'search_and_play': ['search and play', 'find and play'],
            'open_multiple': ['open multiple', 'open several'],
            'hibernate_computer': ['hibernate computer', 'deep sleep'],
            'log_off': ['log off', 'sign out'],
            'switch_user': ['switch user', 'change user'],
            'enable_airplane_mode': ['airplane mode on', 'flight mode'],
            'disable_airplane_mode': ['airplane mode off', 'disable flight mode'],
            'start_screen_recording': ['start recording', 'record screen'],
            'stop_screen_recording': ['stop recording', 'end recording'],
            'start_dictation': ['start dictation', 'voice typing'],
            'stop_dictation': ['stop dictation', 'end dictation'],
            'take_screenshot_window': ['window screenshot', 'capture window'],
            'take_screenshot_area': ['area screenshot', 'capture area'],
            'file_vault_encrypt': ['encrypt file', 'secure file'],
            'file_vault_decrypt': ['decrypt file', 'unlock file'],
            'anomaly_detection': ['scan for threats', 'security scan'],
            'phishing_scan': ['check for phishing', 'scan link'],
            'parental_control': ['parental control', 'child safety'],
            'cloud_backup': ['cloud backup', 'backup to cloud'],
            'email_summarize': ['summarize email', 'email summary'],
            'sync_devices': ['sync devices', 'synchronize'],
            'realtime_transcription': ['transcribe audio', 'voice to text'],
            'summarize_meeting': ['meeting summary', 'summarize discussion'],
            'smart_clipboard': ['smart clipboard', 'clipboard manager'],
            'document_qa': ['document questions', 'ask about document'],
            'ai_presentation': ['create presentation', 'make slides'],
            'security_camera': ['security camera', 'surveillance'],
            'energy_monitoring': ['energy monitor', 'power usage'],
            'scholar_search': ['academic search', 'research papers'],
            'stock_updates': ['stock market', 'stock prices'],
            'crypto_updates': ['cryptocurrency', 'crypto prices'],
            'realtime_translation': ['translate text', 'language translation'],
            'manage_package': ['install package', 'manage software'],
            'docker_control': ['docker control', 'container management'],
            'adaptive_learning': ['learn from me', 'adapt to me'],
            'check_proactive': ['check suggestions', 'proactive help'],
            'enable_proactive_mode': ['enable proactive', 'turn on suggestions'],
            'disable_proactive_mode': ['disable proactive', 'turn off suggestions'],
            'manual_learn': ['teach you', 'manual learning'],
            'calendar_schedule': ['calendar event', 'schedule appointment'],
            'debug_screen': ['debug code', 'fix my code'],
            'fix_my_code': ['fix my code', 'repair code'],
            'check_code': ['check code', 'review code'],
            'multi_agent_collab': ['multi agent', 'agent collaboration'],
            'start_live_review': ['start live review', 'begin monitoring'],
            'stop_live_review': ['stop live review', 'end monitoring'],
            'switch_language_kannada': ['kannada', 'switch to kannada'],
            'switch_language_english': ['english', 'switch to english'],
            'close_chrome': ['close chrome', 'quit chrome'],
            'close_edge': ['close edge', 'quit edge'],
            'close_notepad': ['close notepad', 'quit notepad'],
            'switch_to_male_voice': ['male voice', 'switch to male'],
            'switch_to_female_voice': ['female voice', 'switch to female'],
            'current_voice_gender': ['voice status', 'current voice'],
            'context_memory_recall': ['what do you remember', 'recall memory', 'show memories'],
            'daily_briefing': ['daily briefing', 'morning briefing'],
            'predictive_assistance': ['predictive help', 'smart suggestions'],
            'schedule': ['schedule meeting', 'add event', 'book appointment'],
            'show_calendar': ['show calendar', 'check calendar'],
            'posture_detection': ['posture check', 'check posture'],
            'eye_care_mode': ['eye care', 'protect eyes'],
            'daily_health_log': ['health log', 'log health'],
            'mood_tracker': ['mood tracker', 'track mood'],
            'meditation_prompt': ['meditate', 'meditation', 'relax'],
            'trivia_game': ['trivia', 'quiz game', 'test knowledge'],
            'storytelling': ['tell story', 'story time'],
            'fitness_coach': ['fitness coach', 'workout guide'],
            'ai_dj_mode': ['dj mode', 'music mix'],
            'code_agent': ['code help', 'programming assistant'],
            'research_agent': ['research help', 'research assistant'],
            'organizer_agent': ['organize', 'task organizer'],
            'smart_home_control': ['smart home', 'home automation'],
            'set_home_scene': ['home scene', 'set scene'],
            'start_gesture_control': ['gesture control', 'hand control'],
            'stop_gesture_control': ['stop gestures', 'disable gestures'],
            'code_review': ['code review', 'review code', 'check code'],
            'folder_review': ['folder review', 'review folder'],
            'live_code_review': ['live review', 'real time review'],
            'joke': ['tell joke', 'joke', 'make me laugh'],
            'quote': ['quote', 'inspirational quote', 'wisdom'],
        
            'news': ['news', 'latest news', 'headlines'],
            
            # Complete Voice Advanced AI Features Mappings
            'system_monitor_live': ['system monitor', 'monitor system', 'live monitoring', 'system status', 'system dashboard'],
            'auto_fix_system': ['auto fix', 'fix system', 'system fix', 'repair system', 'system repair'],
            'install_package': ['install package', 'install software', 'add package', 'package install'],
            'list_packages': ['list packages', 'show packages', 'installed packages', 'package list'],
            'uninstall_package': ['uninstall package', 'remove package', 'delete package', 'package remove'],
            'manage_package': ['manage package', 'package manager', 'software manager', 'package management'],
            
            # Advanced Memory & Context
            'context_memory_store': ['remember this', 'store memory', 'save this', 'store this'],
            'context_memory_recall': ['what do you remember', 'recall memory', 'show memories', 'my memories', 'stored memories'],
            'daily_briefing': ['daily briefing', 'morning briefing', 'get briefing', 'today summary', 'daily summary'],
            
            # Advanced Calendar & Scheduling
            'calendar_schedule': ['schedule event', 'book appointment', 'add event', 'create meeting', 'schedule meeting'],
            'show_calendar': ['show calendar', 'check calendar', 'my events', 'what meetings', 'calendar view', 'upcoming events'],
            
            # Advanced Email & Communication
            'email_summarize': ['summarize email', 'email summary', 'email brief', 'email digest'],
            'sync_devices': ['sync devices', 'device sync', 'synchronize', 'sync data'],
            'cloud_backup': ['cloud backup', 'backup files', 'backup to cloud', 'cloud storage'],
            
            # Advanced AI Productivity
            'realtime_transcription': ['transcribe audio', 'voice to text', 'speech to text', 'audio transcription'],
            'summarize_meeting': ['meeting summary', 'summarize discussion', 'meeting notes', 'discussion summary'],
            'smart_clipboard': ['smart clipboard', 'clipboard manager', 'clipboard history', 'clipboard storage'],
            'document_qa': ['document questions', 'ask document', 'document help', 'document assistant'],
            'ai_presentation': ['create presentation', 'make slides', 'presentation maker', 'ai presentation'],
            'ai_report': ['create report', 'make report', 'generate report', 'ai report'],
            
            # Advanced Smart Home
            'smart_home_control': ['smart home', 'home automation', 'control home', 'home control'],
            'set_home_scene': ['home scene', 'set scene', 'activate scene', 'scene control'],
            'security_camera': ['security camera', 'camera snapshot', 'surveillance', 'camera view'],
            'energy_monitoring': ['energy monitor', 'power usage', 'energy report', 'power monitoring'],
            
            # Advanced Entertainment Plus
            'ai_dj_mode': ['dj mode', 'music dj', 'ai dj', 'music mix', 'dj assistant'],
            'trivia_game': ['trivia game', 'play trivia', 'quiz game', 'trivia quiz', 'knowledge game'],
            'storytelling': ['tell story', 'story mode', 'story time', 'create story', 'story generator'],
            'fitness_coach': ['fitness coach', 'workout coach', 'exercise guide', 'fitness help', 'workout assistant'],
            
            # Advanced AI Agents
            'code_agent': ['code agent', 'coding help', 'programming assistant', 'code help', 'coding assistant'],
            'debug_screen': ['debug screen', 'debug code', 'fix my code', 'check code', 'code debugging'],
            'research_agent': ['research agent', 'research help', 'research assistant', 'research support'],
            'organizer_agent': ['organizer agent', 'organize tasks', 'task organizer', 'task manager'],
            'multi_agent_collab': ['multi agent', 'agent collaboration', 'multiple agents', 'agent teamwork'],
            
            # Advanced Web Intelligence
            'scholar_search': ['scholar search', 'academic search', 'research papers', 'scholarly articles'],
            'stock_updates': ['stock updates', 'stock market', 'stock prices', 'market news', 'financial updates'],
            'crypto_updates': ['crypto updates', 'cryptocurrency', 'crypto prices', 'bitcoin', 'crypto market'],
            'realtime_translation': ['translate text', 'real time translation', 'language translate', 'translation service'],
            
            # Advanced Health & Wellness
            'posture_detection': ['posture check', 'check posture', 'posture analysis', 'posture monitoring'],
            'eye_care_mode': ['eye care', 'protect eyes', 'eye break', 'eye health', 'eye protection'],
            'daily_health_log': ['health log', 'track health', 'health diary', 'wellness log', 'health tracking'],
            'mood_tracker': ['mood tracker', 'track mood', 'mood log', 'how am i feeling', 'mood monitoring'],
            'meditation_prompt': ['meditation', 'meditate', 'mindfulness', 'relax', 'meditation guide'],
            
            # Advanced Security & Authentication
            'file_vault_encrypt': ['encrypt file', 'secure file', 'protect file', 'file encryption'],
            'file_vault_decrypt': ['decrypt file', 'unlock file', 'unsecure file', 'file decryption'],
            'anomaly_detection': ['scan for threats', 'security scan', 'system scan', 'threat detection'],
            'phishing_scan': ['phishing scan', 'check link', 'scan url', 'link safety', 'url security'],
            'parental_control': ['parental control', 'child safety', 'family safety', 'content filtering'],
            
            # Advanced Learning & Adaptation
            'adaptive_learning': ['adaptive learning', 'learn from me', 'adapt to me', 'machine learning'],
            'check_proactive': ['check proactive', 'proactive suggestions', 'smart suggestions', 'ai suggestions'],
            'enable_proactive_mode': ['enable proactive', 'turn on suggestions', 'proactive mode on', 'smart mode on'],
            'disable_proactive_mode': ['disable proactive', 'turn off suggestions', 'proactive mode off', 'smart mode off'],
            'manual_learn': ['manual learn', 'teach jarvis', 'teach you', 'learn this', 'training mode'],
            'predictive_assistance': ['predictive help', 'smart suggestions', 'predict actions', 'ai predictions'],
            
            # Advanced Docker & Development
            'docker_control': ['docker control', 'docker help', 'container management', 'docker commands']
        }
        
        # Check for exact phrase matches first
        for func_name, phrases in mappings.items():
            for phrase in phrases:
                if phrase in query:
                    return func_name
        
        # Check for partial matches with higher priority functions
        priority_functions = [
            'system_monitor_live', 'auto_fix_system', 'code_agent', 'research_agent',
            'ai_presentation', 'smart_home_control', 'posture_detection', 'eye_care_mode',
            'meditation_prompt', 'trivia_game', 'storytelling', 'fitness_coach'
        ]
        
        for func_name in priority_functions:
            if func_name in mappings:
                for phrase in mappings[func_name]:
                    # Check for partial matches
                    phrase_words = phrase.split()
                    query_words = query.split()
                    if len(phrase_words) > 1 and any(word in query for word in phrase_words):
                        # Check if at least 2 words match for multi-word phrases
                        matches = sum(1 for word in phrase_words if word in query)
                        if matches >= min(2, len(phrase_words)):
                            return func_name
        
        return None
    
    def _fuzzy_match_command(self, query):
        """Fuzzy matching using existing natural speech mappings"""
        return self.understand_natural_speech(query)
                

    
    def execute_multiple_commands(self, commands):
        """Execute multiple commands sequentially"""
        results = []
        for i, command in enumerate(commands):
            try:
                result = self.execute(command.strip())
                results.append(f"Command {i+1}: {result}")
                # Small delay between commands for better execution
                if i < len(commands) - 1:
                    time.sleep(0.3)
            except Exception as e:
                results.append(f"Command {i+1} failed: {str(e)}")
        
        return " | ".join(results)
    
    def _is_question(self, query):
        question_words = ['who', 'what', 'when', 'where', 'why', 'how']
        return any(word in query.lower() for word in question_words) or query.strip().endswith('?')
    
    def _answer_question(self, query):
        try:
            # Check stored memories first for any personal questions
            if any(word in query.lower() for word in ['my ', 'what is my', 'who am i', 'do you remember', 'what do you know about me']):
                try:
                    from engine.voice_advanced_ai import voice_advanced_ai
                    memories = voice_advanced_ai.context_memory_recall()
                    
                    # Search through all stored memories
                    for key in memories.keys():
                        memory_data = voice_advanced_ai._memory_get_all(key)
                        if memory_data:
                            data_str = str(memory_data[0]).lower()
                            query_words = query.lower().split()
                            
                            # Check if any words from the query match the stored data
                            for word in query_words:
                                if len(word) > 2 and word in data_str:  # Skip short words
                                    return f"Based on what you told me: {memory_data[0]}"
                            
                            # Specific pattern matching
                            if 'name' in query.lower() and 'name is' in data_str:
                                name_part = str(memory_data[0]).split('name is')[-1].strip()
                                return f"Your name is {name_part}"
                            elif any(word in query.lower() for word in ['color', 'colour']) and 'color is' in data_str:
                                color_part = str(memory_data[0]).split('color is')[-1].strip()
                                return f"Your favorite color is {color_part}"
                            elif 'age' in query.lower() and 'age is' in data_str:
                                age_part = str(memory_data[0]).split('age is')[-1].strip()
                                return f"Your age is {age_part}"
                            elif 'live' in query.lower() and 'live in' in data_str:
                                location_part = str(memory_data[0]).split('live in')[-1].strip()
                                return f"You live in {location_part}"
                except:
                    pass
            
            prompt = f'You are Jarvis. Answer briefly: "{query}"'
            
            if self.ai_provider == 'groq':
                response = self.groq_client.chat.completions.create(
                    messages=[{"role": "user", "content": prompt}],
                    model="llama-3.1-8b-instant"
                )
                return response.choices[0].message.content.strip()
            else:
                response = self.gemini_model.generate_content(prompt)
                return response.text.strip()
        except:
            return "I'm having trouble answering that."
    
    def _get_response(self, func, result):
        responses = {
            'shutdown': "Shutting down computer in 5 seconds.",
            'restart': "Restarting computer in 5 seconds.",
            'sleep': "Computer going to sleep.",
            'lock': "Screen locked.",
            'hibernate': "Computer hibernating.",
            'calculator': "Calculator opened.",
            'notepad': "Notepad opened.",
            'chrome': "Chrome opened.",
            'edge': "Edge opened.",
            'explorer': "File Explorer opened.",
            'settings': "Windows Settings opened.",
            'taskmanager': "Task Manager opened.",
            'cmd': "Command Prompt opened.",
            'paint': "Paint opened.",
            'firefox': "Firefox opened.",
            'word': "Microsoft Word opened.",
            'excel': "Microsoft Excel opened.",
            'powerpoint': "PowerPoint opened.",
            'vlc': "VLC Media Player opened.",
            'vscode': "VS Code opened.",
            'spotify': "Spotify opened.",
            'steam': "Steam opened.",
            'google': "Google opened.",
            'youtube': "YouTube opened.",
            'wikipedia': "Wikipedia opened.",
            'stackoverflow': "Stack Overflow opened.",
            'github': "GitHub opened.",
            'amazon': "Amazon opened.",
            'flipkart': "Flipkart opened.",
            'instagram': "Instagram opened.",
            'facebook': "Facebook opened.",
            'twitter': "Twitter opened.",
            'linkedin': "LinkedIn opened.",
            'whatsapp_web': "WhatsApp Web opened.",
            'gmail': "Gmail opened.",
            'netflix': "Netflix opened.",
            'volume_up': "Volume increased.",
            'volume_down': "Volume decreased.",
            'mute': "Audio muted.",
            'screenshot': "Screenshot saved.",
            'desktop': "Desktop shown.",
            'minimize_all': "All windows minimized.",
            'brightness_up': "Brightness increased.",
            'brightness_down': "Brightness decreased.",
            'set_volume_60': "Volume set to 60%.",
            'volume_60': "Volume set to 60%.",
            'set_brightness_60': "Brightness set to 60%.",
            'brightness_60': "Brightness set to 60%.",
            'alt_tab': "Switched windows.",
            'copy': "Text copied.",
            'paste': "Text pasted.",
            'save': "File saved.",
            'undo': "Action undone.",
            'select_all': "All selected.",
            'close_chrome': "Chrome closed.",
            'close_edge': "Edge closed.",
            'close_notepad': "Notepad closed.",
            'downloads': "Downloads folder opened.",
            'documents': "Documents folder opened.",
            'pictures': "Pictures folder opened.",
            'cpu': f"CPU usage: {result}%",
            'memory': f"Memory usage: {result}%",
            'battery': f"Battery: {result}%" if result else "No battery detected",
            'time': f"Current time: {result}",
            'date': f"Today is {result}",
            'switch_to_gemini': "Switched to Gemini AI.",
            'switch_to_groq': "Switched to Groq AI.",
            'current_ai': f"Currently using {self.ai_provider.title()} AI.",
            'enable_face_auth': "Face recognition enabled.",
            'disable_face_auth': "Face recognition disabled.",
            'face_auth_status': "Face recognition status checked.",
            'switch_to_male_voice': "Voice switched to male.",
            'switch_to_female_voice': "Voice switched to female.",
            'male_voice': "Voice switched to male.",
            'female_voice': "Voice switched to female.",
            'current_voice_gender': "Voice gender status checked.",
            'voice_status': "Voice gender status checked.",
            
            # Advanced Features Responses
            'create_folder': "Folder created.",
            'delete_file': "File deleted.",
            'search_files': "File search completed.",
            'copy_file': "File copied.",
            'move_file': "File moved.",
            'check_internet': "Internet connection checked.",
            'ip_address': "IP address retrieved.",
            'wifi_password': "WiFi information retrieved.",
            'network_speed': "Network speed tested.",
            'disk_space': "Disk space checked.",
            'running_processes': "Process list retrieved.",
            'system_uptime': "System uptime checked.",
            'temperature': "System temperature checked.",
            'play_pause': "Media play/pause toggled.",
            'next_track': "Next track.",
            'previous_track': "Previous track.",
            'stop_media': "Media stopped.",
            'maximize_window': "Window maximized.",
            'minimize_window': "Window minimized.",
            'split_screen_left': "Screen split left.",
            'split_screen_right': "Screen split right.",
            'close_window': "Window closed.",
            'switch_window': "Window switched.",
            'find_text': "Find dialog opened.",
            'replace_text': "Replace dialog opened.",
            'new_document': "New document created.",
            'print_document': "Print dialog opened.",
            'zoom_in': "Zoomed in.",
            'zoom_out': "Zoomed out.",
            'clear_clipboard': "Clipboard cleared.",
            'clear_history': "Browser history cleared.",
            'empty_recycle_bin': "Recycle bin emptied.",
            'lock_screen': "Screen locked.",
            'set_reminder': "Reminder set.",
            'schedule_shutdown': "Shutdown scheduled.",
            'auto_backup': "Backup completed.",
            'clean_temp': "Temporary files cleaned.",
            'play_music': "Music started.",
            'random_wallpaper': "Wallpaper changed.",
   
            'news': "News opened.",
            'quote': "Here's an inspirational quote.",
            
            # YouTube Automation Responses
            'youtube_play': "YouTube video play/paused.",
            'youtube_pause': "YouTube video paused.",
            'youtube_next': "Next YouTube video.",
            'youtube_previous': "Previous YouTube video.",
            'youtube_fullscreen': "YouTube fullscreen toggled.",
            'youtube_volume_up': "YouTube volume increased.",
            'youtube_volume_down': "YouTube volume decreased.",
            'youtube_mute': "YouTube muted/unmuted.",
            'youtube_speed_up': "YouTube speed increased.",
            'youtube_speed_down': "YouTube speed decreased.",
            'youtube_skip_forward': "YouTube skipped forward.",
            'youtube_skip_backward': "YouTube skipped backward.",
            'youtube_search': "YouTube search activated.",
            'youtube_subscribe': "YouTube subscribe clicked.",
            'youtube_like': "YouTube like clicked.",
            'youtube_dislike': "YouTube dislike clicked.",
            'youtube_comment': "YouTube comment box activated.",
            'youtube_share': "YouTube share clicked.",
            'youtube_theater_mode': "YouTube theater mode toggled.",
            'youtube_miniplayer': "YouTube miniplayer toggled.",
            'youtube_captions': "YouTube captions toggled.",
            'play_video': "Video search and play completed.",
            'play_movie': "Movie search and play completed.",
            'play_song': "Song search and play completed.",
            'search_and_play': "Search and play completed.",
            'open_multiple': "Multiple apps/websites opened.",
            
            # Chrome Automation Responses
            'chrome_new_tab': "New Chrome tab opened.",
            'chrome_close_tab': "Chrome tab closed.",
            'chrome_next_tab': "Switched to next Chrome tab.",
            'chrome_previous_tab': "Switched to previous Chrome tab.",
            'chrome_reload': "Chrome page reloaded.",
            'chrome_back': "Chrome navigated back.",
            'chrome_forward': "Chrome navigated forward.",
            'chrome_home': "Chrome home page opened.",
            'chrome_bookmark': "Chrome bookmark added.",
            'chrome_history': "Chrome history opened.",
            'chrome_downloads': "Chrome downloads opened.",
            'chrome_incognito': "Chrome incognito window opened.",
            'chrome_developer_tools': "Chrome developer tools toggled.",
            'chrome_zoom_in': "Chrome zoomed in.",
            'chrome_zoom_out': "Chrome zoomed out.",
            'chrome_zoom_reset': "Chrome zoom reset.",
            'chrome_find': "Chrome find dialog opened.",
            'chrome_print': "Chrome print dialog opened.",
            'chrome_save_page': "Chrome page saved.",
            'chrome_view_source': "Chrome page source opened.",
            'chrome_extensions': "Chrome extensions opened.",
            'chrome_settings': "Chrome settings opened.",
            'chrome_clear_data': "Chrome clear data dialog opened.",
            
            # System Monitoring Responses
            'system_monitor_live': "System monitoring dashboard displayed.",
            'auto_fix_system': "System auto-fix completed.",
            
            # Gesture Control Responses
            'start_gesture_control': "Hand, eye, and head control started.",
            'stop_gesture_control': "Gesture control stopped.",
            
            # Continuous Listening Responses
            'start_continuous_listen': "Continuous listening started.",
            'stop_continuous_listen': "Continuous listening stopped.",
            'continuous_listen_status': "Continuous listening status checked."
        }
        
        # Get base response
        base_response = responses.get(func, "Task completed.")
        
        # Apply personality transformation safely
        if self.personality_manager:
            try:
                transformed = self.personality_manager.transform_response(base_response, 'success')
                if transformed and transformed.strip():
                    return transformed
            except:
                pass
        
        return base_response
    
    def _switch_to_gemini(self):
        return "gemini" if self._set_ai_provider('gemini') else "error"
    
    def _switch_to_groq(self):
        return "groq" if self._set_ai_provider('groq') else "error"
    
    def _get_current_ai(self):
        return self.ai_provider
    
    def _switch_to_hindi(self):
        if self.multilingual and self.multilingual.set_language('hindi'):
            # Reload the multilingual instance
            from engine.multilingual_support import reload_multilingual
            reload_multilingual()
            self.multilingual = multilingual
            return "‡§≠‡§æ‡§∑‡§æ ‡§π‡§ø‡§Ç‡§¶‡•Ä ‡§Æ‡•á‡§Ç ‡§¨‡§¶‡§≤ ‡§ó‡§à‡•§"
        return "Language switched to Hindi."
    
    def _switch_to_kannada(self):
        if self.multilingual and self.multilingual.set_language('kannada'):
            # Reload the multilingual instance
            from engine.multilingual_support import reload_multilingual
            reload_multilingual()
            self.multilingual = multilingual
            return "‡≤≠‡≤æ‡≤∑‡≥Ü‡≤Ø‡≤®‡≥ç‡≤®‡≥Å ‡≤ï‡≤®‡≥ç‡≤®‡≤°‡≤ï‡≥ç‡≤ï‡≥Ü ‡≤¨‡≤¶‡≤≤‡≤æ‡≤Ø‡≤ø‡≤∏‡≤≤‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü‡•§"
        return "Language switched to Kannada."
    
    def _switch_to_english(self):
        if self.multilingual and self.multilingual.set_language('english'):
            # Reload the multilingual instance
            from engine.multilingual_support import reload_multilingual
            reload_multilingual()
            self.multilingual = multilingual
            return "Language switched to English."
        return "Language switched to English."
    
    def _enable_face_auth(self):
        try:
            from engine.face_auth_config import set_face_auth_status
            set_face_auth_status(True)
            return "enabled"
        except:
            return "error"
    
    def _disable_face_auth(self):
        try:
            from engine.face_auth_config import set_face_auth_status
            set_face_auth_status(False)
            return "disabled"
        except:
            return "error"
    
    def _get_face_auth_status(self):
        try:
            from engine.face_auth_config import get_face_auth_status
            return "enabled" if get_face_auth_status() else "disabled"
        except:
            return "error"
    
    def _set_volume(self, level):
        try:
            level = max(0, min(100, level))
            subprocess.run(f'powershell -c "$obj = new-object -com wscript.shell; $obj.SendKeys([char]173); for($i=0; $i -lt 50; $i++){{$obj.SendKeys([char]174)}}; for($i=0; $i -lt {level//2}; $i++){{$obj.SendKeys([char]175)}}"', shell=True)
            return str(level)
        except:
            return "error"
    
    def _set_brightness(self, level):
        try:
            level = max(0, min(100, level))
            subprocess.run(f'powershell -c "(Get-WmiObject -Namespace root/WMI -Class WmiMonitorBrightnessMethods).WmiSetBrightness(1,{level})"', shell=True)
            return str(level)
        except:
            return "error"
    
    def _handle_on_off(self, feature, action):
        """Handle dynamic on/off commands for any feature"""
        try:
            feature = feature.lower().strip()
            
            # WiFi - Quick toggle via Action Center
            if 'wifi' in feature or 'wi-fi' in feature:
                pyautogui.hotkey('win', 'a')  # Open Action Center
                pyautogui.sleep(0.5)
                pyautogui.click(x=1200, y=300)  # Click WiFi tile
                pyautogui.press('escape')  # Close Action Center
                return f"WiFi toggled"
            
            # Bluetooth - Quick toggle via Action Center
            elif 'bluetooth' in feature:
                pyautogui.hotkey('win', 'a')  # Open Action Center
                pyautogui.sleep(0.5)
                pyautogui.click(x=1200, y=350)  # Click Bluetooth tile
                pyautogui.press('escape')  # Close Action Center
                return f"Bluetooth toggled"
            
            # Airplane Mode - Admin control
            elif 'airplane' in feature or 'flight' in feature:
                if action == 'on':
                    subprocess.run('powershell -c "Start-Process powershell -ArgumentList \'Get-PnpDevice -Class Net | Where-Object {$_.Status -eq \"OK\"} | Disable-PnpDevice -Confirm:$false\' -Verb RunAs"', shell=True)
                else:
                    subprocess.run('powershell -c "Start-Process powershell -ArgumentList \'Get-PnpDevice -Class Net | Where-Object {$_.Status -eq \"Error\"} | Enable-PnpDevice -Confirm:$false\' -Verb RunAs"', shell=True)
                return f"Airplane mode {action}"
            
            # Location - Admin control
            elif 'location' in feature or 'gps' in feature:
                if action == 'on':
                    subprocess.run('powershell -c "Start-Process powershell -ArgumentList \'Set-ItemProperty -Path HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\CapabilityAccessManager\\ConsentStore\\location -Name Value -Value Allow\' -Verb RunAs"', shell=True)
                else:
                    subprocess.run('powershell -c "Start-Process powershell -ArgumentList \'Set-ItemProperty -Path HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\CapabilityAccessManager\\ConsentStore\\location -Name Value -Value Deny\' -Verb RunAs"', shell=True)
                return f"Location {action}"
            
            # Camera - Admin control
            elif 'camera' in feature:
                if action == 'on':
                    subprocess.run('powershell -c "Start-Process powershell -ArgumentList \'Set-ItemProperty -Path HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\CapabilityAccessManager\\ConsentStore\\webcam -Name Value -Value Allow\' -Verb RunAs"', shell=True)
                else:
                    subprocess.run('powershell -c "Start-Process powershell -ArgumentList \'Set-ItemProperty -Path HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\CapabilityAccessManager\\ConsentStore\\webcam -Name Value -Value Deny\' -Verb RunAs"', shell=True)
                return f"Camera {action}"
            
            # Microphone - Admin control
            elif 'microphone' in feature or 'mic' in feature:
                if action == 'on':
                    subprocess.run('powershell -c "Start-Process powershell -ArgumentList \'Set-ItemProperty -Path HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\CapabilityAccessManager\\ConsentStore\\microphone -Name Value -Value Allow\' -Verb RunAs"', shell=True)
                else:
                    subprocess.run('powershell -c "Start-Process powershell -ArgumentList \'Set-ItemProperty -Path HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\CapabilityAccessManager\\ConsentStore\\microphone -Name Value -Value Deny\' -Verb RunAs"', shell=True)
                return f"Microphone {action}"
            
            else:
                return f"Feature '{feature}' not supported"
                
        except Exception as e:
            return f"Error controlling {feature}: {str(e)}"
    
    def _check_new_features(self, query):
        """Check new features from external file"""
        try:
            from engine.new_features import get_new_feature_response
            result = get_new_feature_response(query)
            return result
        except:
            return None
    
    # ===== ALL ADVANCED FEATURES METHODS =====
    
    # Voice Mouse Control
    def _move_mouse_up(self, pixels=50):
        try:
            x, y = pyautogui.position()
            pyautogui.moveTo(x, max(0, y - pixels))
            return f"Mouse moved up {pixels} pixels"
        except:
            return "Mouse movement failed"
    
    def _move_mouse_down(self, pixels=50):
        try:
            x, y = pyautogui.position()
            screen_height = pyautogui.size().height
            pyautogui.moveTo(x, min(screen_height, y + pixels))
            return f"Mouse moved down {pixels} pixels"
        except:
            return "Mouse movement failed"
    
    def _move_mouse_left(self, pixels=50):
        try:
            x, y = pyautogui.position()
            pyautogui.moveTo(max(0, x - pixels), y)
            return f"Mouse moved left {pixels} pixels"
        except:
            return "Mouse movement failed"
    
    def _move_mouse_right(self, pixels=50):
        try:
            x, y = pyautogui.position()
            screen_width = pyautogui.size().width
            pyautogui.moveTo(min(screen_width, x + pixels), y)
            return f"Mouse moved right {pixels} pixels"
        except:
            return "Mouse movement failed"
    
    def _move_mouse_center(self):
        try:
            screen_width, screen_height = pyautogui.size()
            pyautogui.moveTo(screen_width // 2, screen_height // 2)
            return "Mouse moved to center"
        except:
            return "Mouse movement failed"
    
    def _left_click(self):
        try:
            pyautogui.click()
            return "Left click performed"
        except:
            return "Click failed"
    
    def _right_click(self):
        try:
            pyautogui.rightClick()
            return "Right click performed"
        except:
            return "Right click failed"
    
    def _double_click(self):
        try:
            pyautogui.doubleClick()
            return "Double click performed"
        except:
            return "Double click failed"
    
    def _start_drag(self):
        try:
            pyautogui.mouseDown()
            return "Drag started"
        except:
            return "Drag start failed"
    
    def _drop_here(self):
        try:
            pyautogui.mouseUp()
            return "Drop completed"
        except:
            return "Drop failed"
    
    def _scroll_up(self, clicks=3):
        try:
            pyautogui.scroll(clicks)
            return f"Scrolled up {clicks} clicks"
        except:
            return "Scroll failed"
    
    def _scroll_down(self, clicks=3):
        try:
            pyautogui.scroll(-clicks)
            return f"Scrolled down {clicks} clicks"
        except:
            return "Scroll failed"
    
    def _scroll_to_top(self):
        try:
            pyautogui.hotkey('ctrl', 'home')
            return "Scrolled to top"
        except:
            return "Scroll to top failed"
    
    # Voice Keyboard Control
    def _type_text(self, text=""):
        try:
            pyautogui.typewrite(text)
            return f"Typed: {text}"
        except:
            return "Text typing failed"
    
    def _press_enter(self):
        try:
            pyautogui.press('enter')
            return "Enter key pressed"
        except:
            return "Enter key failed"
    
    def _press_tab(self):
        try:
            pyautogui.press('tab')
            return "Tab key pressed"
        except:
            return "Tab key failed"
    
    def _press_escape(self):
        try:
            pyautogui.press('escape')
            return "Escape key pressed"
        except:
            return "Escape key failed"
    
    def _press_backspace(self):
        try:
            pyautogui.press('backspace')
            return "Backspace pressed"
        except:
            return "Backspace failed"
    
    def _press_delete(self):
        try:
            pyautogui.press('delete')
            return "Delete key pressed"
        except:
            return "Delete key failed"
    
    def _go_to_beginning(self):
        try:
            pyautogui.hotkey('ctrl', 'home')
            return "Moved to beginning"
        except:
            return "Go to beginning failed"
    
    def _go_to_end(self):
        try:
            pyautogui.hotkey('ctrl', 'end')
            return "Moved to end"
        except:
            return "Go to end failed"
    
    # File Operations
    def _create_folder(self, path="New Folder"):
        try:
            desktop = os.path.join(os.path.expanduser("~"), "Desktop")
            folder_path = os.path.join(desktop, path)
            os.makedirs(folder_path, exist_ok=True)
            return f"Folder '{path}' created on desktop"
        except:
            return "Failed to create folder"
    
    def _delete_file(self, filename=""):
        try:
            desktop = os.path.join(os.path.expanduser("~"), "Desktop")
            file_path = os.path.join(desktop, filename)
            if os.path.exists(file_path):
                os.remove(file_path)
                return f"File '{filename}' deleted"
            return "File not found"
        except:
            return "Failed to delete file"
    
    def _search_files(self, query=""):
        try:
            desktop = os.path.join(os.path.expanduser("~"), "Desktop")
            matches = []
            for file in os.listdir(desktop):
                if query.lower() in file.lower():
                    matches.append(file)
            return f"Found {len(matches)} files matching '{query}'"
        except:
            return "Search failed"
    
    def _copy_file(self, source="", destination=""):
        try:
            shutil.copy2(source, destination)
            return "File copied successfully"
        except:
            return "Failed to copy file"
    
    def _move_file(self, source="", destination=""):
        try:
            shutil.move(source, destination)
            return "File moved successfully"
        except:
            return "Failed to move file"
    
    # Network & Internet
    def _ping_test(self):
        try:
            result = subprocess.run(['ping', '-n', '1', 'google.com'], 
                                  capture_output=True, text=True, timeout=5)
            return "Internet connected" if result.returncode == 0 else "No internet connection"
        except:
            return "Network check failed"
    
    def _get_ip(self):
        try:
            hostname = socket.gethostname()
            ip = socket.gethostbyname(hostname)
            return f"Your IP address is {ip}"
        except:
            return "Could not get IP address"
    
    def _get_wifi_password(self):
        try:
            result = subprocess.run(['netsh', 'wlan', 'show', 'profile'], 
                                  capture_output=True, text=True)
            profiles = [line.split(':')[1].strip() for line in result.stdout.split('\n') 
                       if 'All User Profile' in line]
            if profiles:
                return f"Found {len(profiles)} WiFi networks"
            return "No WiFi profiles found"
        except:
            return "Could not retrieve WiFi information"
    
    def _speed_test(self):
        try:
            response = requests.get('http://www.google.com', timeout=3)
            return f"Internet speed test completed in {response.elapsed.total_seconds():.2f} seconds"
        except:
            return "Speed test failed"
    
    # System Monitoring
    def _get_disk_space(self):
        try:
            disk = psutil.disk_usage('C:')
            free_gb = disk.free / (1024**3)
            total_gb = disk.total / (1024**3)
            return f"Disk space: {free_gb:.1f}GB free of {total_gb:.1f}GB total"
        except:
            return "Could not get disk space"
    
    def _list_processes(self):
        try:
            processes = len(psutil.pids())
            return f"Currently running {processes} processes"
        except:
            return "Could not get process information"
    
    def _get_uptime(self):
        try:
            boot_time = psutil.boot_time()
            uptime = time.time() - boot_time
            hours = int(uptime // 3600)
            minutes = int((uptime % 3600) // 60)
            return f"System uptime: {hours} hours, {minutes} minutes"
        except:
            return "Could not get uptime"
    
    def _get_cpu_temp(self):
        try:
            cpu_percent = psutil.cpu_percent(interval=1)
            return f"CPU usage: {cpu_percent}%"
        except:
            return "Could not get CPU information"
    
    # Entertainment
    def _tell_joke(self):
        jokes = [
            "Why don't scientists trust atoms? Because they make up everything!",
            "Why did the computer go to the doctor? Because it had a virus!",
            "Why don't programmers like nature? It has too many bugs!",
            "What do you call a computer that sings? A Dell!",
            "Why was the computer cold? It left its Windows open!"
        ]
        return random.choice(jokes)
    
    def _get_quote(self):
        quotes = [
            "The only way to do great work is to love what you do. - Steve Jobs",
            "Innovation distinguishes between a leader and a follower. - Steve Jobs",
            "Life is what happens to you while you're busy making other plans. - John Lennon",
            "The future belongs to those who believe in the beauty of their dreams. - Eleanor Roosevelt",
            "It is during our darkest moments that we must focus to see the light. - Aristotle"
        ]
        return random.choice(quotes)
    

    
    def _get_news(self):
        try:
            return "Opening news website for latest updates"
        except:
            return "Could not get news"
    
    # Placeholder methods for remaining features
    def _next_window(self): return "Switched to next window"
    def _previous_window(self): return "Switched to previous window"
    def _close_all_windows(self): return "All windows minimized"
    def _snap_left(self): return "Window snapped left"
    def _snap_right(self): return "Window snapped right"
    def _full_screen(self): return "Full screen toggled"
    def _restore_window(self): return "Window restored"
    def _open_recent_file(self): return "Recent file opened"
    def _create_new_file(self): return "New file created"
    def _rename_file(self): return "File rename activated"
    def _duplicate_file(self): return "File duplicated"
    def _compress_file(self): return "File compression started"
    def _extract_archive(self): return "Archive extraction started"
    def _open_new_tab(self): return "New tab opened"
    def _close_current_tab(self): return "Tab closed"
    def _switch_to_next_tab(self): return "Switched to next tab"
    def _switch_to_previous_tab(self): return "Switched to previous tab"
    def _refresh_page(self): return "Page refreshed"
    def _go_back(self): return "Navigated back"
    def _go_forward(self): return "Navigated forward"
    def _bookmark_page(self): return "Page bookmarked"
    def _open_bookmarks(self): return "Bookmarks opened"
    def _search_web(self, query=""): return f"Searching for: {query}"
    def _skip_forward(self): return "Skipped forward"
    def _skip_backward(self): return "Skipped backward"
    def _increase_speed(self): return "Speed increased"
    def _decrease_speed(self): return "Speed decreased"
    def _toggle_fullscreen(self): return "Fullscreen toggled"
    def _toggle_subtitles(self): return "Subtitles toggled"
    def _show_system_info(self): return "System information opened"
    def _check_updates(self): return "Checking for updates"
    def _show_installed_programs(self): return "Installed programs shown"
    def _show_startup_programs(self): return "Startup programs shown"
    def _show_network_info(self): return "Network information shown"
    def _start_dictation(self): return "Voice dictation started"
    def _stop_dictation(self): return "Voice dictation stopped"
    def _dictate_email(self): return "Email dictation started"
    def _dictate_document(self): return "Document dictation started"
    def _take_screenshot_window(self): return "Window screenshot taken"
    def _take_screenshot_area(self): return "Screenshot area selected"
    def _start_screen_recording(self): return "Screen recording started"
    def _stop_screen_recording(self): return "Screen recording stopped"
    def _hibernate_computer(self): return "Computer hibernating"
    def _log_off(self): return "Logging off"
    def _switch_user(self): return "User switched"
    def _enable_airplane_mode(self): return "Airplane mode enabled"
    def _disable_airplane_mode(self): return "Airplane mode disabled"
    def _enable_narrator(self): return "Narrator enabled"
    def _disable_narrator(self): return "Narrator disabled"
    def _enable_magnifier(self): return "Magnifier enabled"
    def _disable_magnifier(self): return "Magnifier disabled"
    def _high_contrast_mode(self): return "High contrast toggled"
    def _connect_wifi(self): return "WiFi connection opened"
    def _disconnect_wifi(self): return "WiFi disconnected"
    def _show_wifi_networks(self): return "WiFi networks shown"
    def _enable_hotspot(self): return "Hotspot settings opened"
    def _disable_hotspot(self): return "Hotspot disabled"
    def _search_files_content(self): return "File content search started"
    def _search_registry(self): return "Registry editor opened"
    def _search_installed_software(self): return "Software search completed"
    def _find_large_files(self): return "Large file search started"
    def _find_duplicate_files(self): return "Duplicate file scan started"
    def _control_smart_lights(self): return "Smart lights controlled"
    def _control_smart_fan(self): return "Smart fan controlled"
    def _control_smart_ac(self): return "Smart AC controlled"
    def _set_home_scene(self): return "Home scene activated"
    def _generate_code(self): return "Code generated"
    def _debug_code(self): return "Code debugged"
    def _translate_text(self): return "Text translated"
    def _summarize_text(self): return "Text summarized"
    def _analyze_image(self): return "Image analyzed"
    def _send_email(self): return "Email composer opened"
    def _schedule_meeting(self): return "Meeting scheduled"
    def _create_task(self): return "Task created"
    def _convert_document(self): return "Document converted"
    def _merge_pdf(self): return "PDF files merged"
    def _git_status(self): return "Git status checked"
    def _git_commit(self): return "Git commit completed"
    def _run_tests(self): return "Tests executed"
    def _format_code(self): return "Code formatted"
    def _api_test(self): return "API test completed"
    def _water_reminder(self): return "Water reminder set"
    def _break_reminder(self): return "Break reminder set"
    def _eye_care_reminder(self): return "Eye care reminder activated"
    def _fitness_track(self): return "Fitness tracking started"
    def _registry_edit(self): return "Registry modification completed"
    def _service_control(self): return "Service controlled"
    def _driver_update(self): return "Driver scan initiated"
    def _system_optimize(self): return "System optimization started"
    def _performance_monitor(self): return "Performance monitor opened"
    def _social_post(self): return "Social media post prepared"
    def _compose_email(self): return "Email template created"
    def _message_template(self): return "Message template created"
    def _contact_search(self): return "Contact search completed"
    def _wikipedia_search(self): return "Wikipedia search opened"
    def _dictionary_lookup(self): return "Dictionary lookup completed"
    def _unit_convert(self): return "Unit conversion completed"
    def _math_calculate(self): return "Mathematical calculation completed"
    def _language_learn(self): return "Language learning started"
    def _movie_recommend(self): return "Movie recommendations provided"
    def _book_suggest(self): return "Book suggestions provided"
    def _game_launch(self): return "Game launched"
    def _streaming_control(self): return "Streaming controlled"
    def _playlist_manage(self): return "Playlist managed"
    def _workflow_automate(self): return "Workflow automation started"
    def _batch_operations(self): return "Batch operation completed"
    def _scheduled_tasks(self): return "Task scheduled"
    def _system_maintenance(self): return "System maintenance initiated"
    def _auto_updates(self): return "Auto-updates configured"
    
    # Additional missing methods
    def _play_music(self, genre="random"):
        try:
            subprocess.run('start spotify:', shell=True)
            time.sleep(3)
            pyautogui.press('space')
            return f"Playing {genre} music on Spotify"
        except:
            return "Could not play music"
    
    def _change_wallpaper(self):
        try:
            subprocess.run('start ms-settings:personalization-background', shell=True)
            return "Wallpaper settings opened"
        except:
            return "Could not change wallpaper"
    
    def _set_reminder(self, time_str="5 minutes", message="Reminder"):
        try:
            minutes = 5
            if "minute" in time_str:
                minutes = int(''.join(filter(str.isdigit, time_str))) or 5
            future_time = datetime.now() + timedelta(minutes=minutes)
            time_format = future_time.strftime("%H:%M")
            cmd = f'schtasks /create /tn "JarvisReminder" /tr "msg * {message}" /sc once /st {time_format} /f'
            subprocess.run(cmd, shell=True)
            return f"Reminder set for {minutes} minutes"
        except:
            return "Could not set reminder"
    
    def _schedule_shutdown(self, time_str="1 hour"):
        try:
            minutes = 60
            if "minute" in time_str:
                minutes = int(''.join(filter(str.isdigit, time_str))) or 60
            elif "hour" in time_str:
                hours = int(''.join(filter(str.isdigit, time_str))) or 1
                minutes = hours * 60
            seconds = minutes * 60
            subprocess.run(f'shutdown /s /t {seconds}', shell=True)
            return f"Shutdown scheduled in {minutes} minutes"
        except:
            return "Could not schedule shutdown"
    
    def _backup_files(self):
        try:
            desktop = os.path.join(os.path.expanduser("~"), "Desktop")
            backup_folder = os.path.join(desktop, f"Backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}")
            documents = os.path.join(os.path.expanduser("~"), "Documents")
            os.makedirs(backup_folder, exist_ok=True)
            for file in os.listdir(documents)[:5]:
                try:
                    shutil.copy2(os.path.join(documents, file), backup_folder)
                except:
                    continue
            return f"Backup created in {backup_folder}"
        except:
            return "Backup failed"
    
    def _clean_temp_files(self):
        try:
            temp_folder = os.environ.get('TEMP')
            if temp_folder:
                files_deleted = 0
                for file in os.listdir(temp_folder):
                    try:
                        file_path = os.path.join(temp_folder, file)
                        if os.path.isfile(file_path):
                            os.remove(file_path)
                            files_deleted += 1
                    except:
                        continue
                return f"Cleaned {files_deleted} temporary files"
            return "Could not access temp folder"
        except:
            return "Temp cleanup failed"
    
    def _clear_clipboard(self): 
        try:
            pyautogui.copy('')
            return "Clipboard cleared"
        except:
            return "Clipboard clear failed"
    
    def _clear_browser_history(self):
        try:
            chrome_path = os.path.expanduser("~\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\History")
            if os.path.exists(chrome_path):
                subprocess.run(['taskkill', '/f', '/im', 'chrome.exe'], shell=True)
                time.sleep(2)
                os.remove(chrome_path)
            return "Browser history cleared"
        except:
            return "Could not clear browser history"
    
    def _empty_recycle_bin(self):
        try:
            subprocess.run('powershell -c "Clear-RecycleBin -Force"', shell=True)
            return "Recycle bin emptied"
        except:
            return "Could not empty recycle bin"
    
    def _lock_screen(self):
        try:
            subprocess.run('rundll32.exe user32.dll,LockWorkStation', shell=True)
            return "Screen locked"
        except:
            return "Screen lock failed"
    
    def _find_text(self): 
        try:
            pyautogui.hotkey('ctrl', 'f')
            return "Find dialog opened"
        except:
            return "Find text failed"
    
    def _replace_text(self): 
        try:
            pyautogui.hotkey('ctrl', 'h')
            return "Replace dialog opened"
        except:
            return "Replace text failed"
    
    def _new_document(self): 
        try:
            pyautogui.hotkey('ctrl', 'n')
            return "New document created"
        except:
            return "New document failed"
    
    def _print_document(self): 
        try:
            pyautogui.hotkey('ctrl', 'p')
            return "Print dialog opened"
        except:
            return "Print document failed"
    
    def _zoom_in(self): 
        try:
            pyautogui.hotkey('ctrl', 'plus')
            return "Zoomed in"
        except:
            return "Zoom in failed"
    
    def _zoom_out(self): 
        try:
            pyautogui.hotkey('ctrl', 'minus')
            return "Zoomed out"
        except:
            return "Zoom out failed"
    
    def _maximize_window(self): 
        try:
            pyautogui.hotkey('win', 'up')
            return "Window maximized"
        except:
            return "Maximize window failed"
    
    def _minimize_window(self): 
        try:
            pyautogui.hotkey('win', 'down')
            return "Window minimized"
        except:
            return "Minimize window failed"
    
    def _split_screen_left(self): 
        try:
            pyautogui.hotkey('win', 'left')
            return "Screen split left"
        except:
            return "Split screen left failed"
    
    def _split_screen_right(self): 
        try:
            pyautogui.hotkey('win', 'right')
            return "Screen split right"
        except:
            return "Split screen right failed"
    
    def _close_window(self): 
        try:
            pyautogui.hotkey('alt', 'f4')
            return "Window closed"
        except:
            return "Close window failed"
    
    def _switch_window(self): 
        try:
            pyautogui.hotkey('alt', 'tab')
            return "Window switched"
        except:
            return "Switch window failed"
    
    def _play_pause(self): 
        try:
            pyautogui.press('space')
            return "Media play/pause toggled"
        except:
            return "Play/pause failed"
    
    def _next_track(self): 
        try:
            pyautogui.press('nexttrack')
            return "Next track"
        except:
            return "Next track failed"
    
    def _previous_track(self): 
        try:
            pyautogui.press('prevtrack')
            return "Previous track"
        except:
            return "Previous track failed"
    
    def _stop_media(self): 
        try:
            pyautogui.press('stop')
            return "Media stopped"
        except:
            return "Stop media failed"
    
    # YouTube Automation Methods
    def _youtube_play(self):
        try:
            # Try both space and k key for play/pause
            pyautogui.press('space')
            time.sleep(0.2)
            return "YouTube video play/paused"
        except:
            try:
                pyautogui.press('k')
                return "YouTube video play/paused"
            except:
                return "YouTube play failed"
    
    def _youtube_pause(self):
        try:
            pyautogui.press('space')
            return "YouTube video paused"
        except:
            try:
                pyautogui.press('k')
                return "YouTube video paused"
            except:
                return "YouTube pause failed"
    
    def _youtube_next(self):
        try:
            pyautogui.hotkey('shift', 'n')
            return "Next YouTube video"
        except:
            return "YouTube next failed"
    
    def _youtube_previous(self):
        try:
            pyautogui.hotkey('shift', 'p')
            return "Previous YouTube video"
        except:
            return "YouTube previous failed"
    
    def _youtube_fullscreen(self):
        try:
            pyautogui.press('f')
            return "YouTube fullscreen toggled"
        except:
            return "YouTube fullscreen failed"
    
    def _youtube_volume_up(self):
        try:
            pyautogui.press('up')
            return "YouTube volume increased"
        except:
            return "YouTube volume up failed"
    
    def _youtube_volume_down(self):
        try:
            pyautogui.press('down')
            return "YouTube volume decreased"
        except:
            return "YouTube volume down failed"
    
    def _youtube_mute(self):
        try:
            pyautogui.press('m')
            return "YouTube muted/unmuted"
        except:
            return "YouTube mute failed"
    
    def _youtube_speed_up(self):
        try:
            pyautogui.hotkey('shift', '>')
            return "YouTube speed increased"
        except:
            return "YouTube speed up failed"
    
    def _youtube_speed_down(self):
        try:
            pyautogui.hotkey('shift', '<')
            return "YouTube speed decreased"
        except:
            return "YouTube speed down failed"
    
    def _youtube_skip_forward(self):
        try:
            pyautogui.press('l')
            return "YouTube skipped forward 10 seconds"
        except:
            return "YouTube skip forward failed"
    
    def _youtube_skip_backward(self):
        try:
            pyautogui.press('j')
            return "YouTube skipped backward 10 seconds"
        except:
            return "YouTube skip backward failed"
    
    def _youtube_search(self):
        try:
            pyautogui.press('/')
            return "YouTube search activated"
        except:
            return "YouTube search failed"
    
    def _youtube_subscribe(self):
        try:
            pyautogui.click(1200, 400)  # Approximate subscribe button location
            return "YouTube subscribe clicked"
        except:
            return "YouTube subscribe failed"
    
    def _youtube_like(self):
        try:
            pyautogui.click(1100, 500)  # Approximate like button location
            return "YouTube like clicked"
        except:
            return "YouTube like failed"
    
    def _youtube_dislike(self):
        try:
            pyautogui.click(1150, 500)  # Approximate dislike button location
            return "YouTube dislike clicked"
        except:
            return "YouTube dislike failed"
    
    def _youtube_comment(self):
        try:
            pyautogui.scroll(-5)
            pyautogui.click(600, 700)  # Approximate comment box location
            return "YouTube comment box activated"
        except:
            return "YouTube comment failed"
    
    def _youtube_share(self):
        try:
            pyautogui.click(1200, 500)  # Approximate share button location
            return "YouTube share clicked"
        except:
            return "YouTube share failed"
    
    def _youtube_theater_mode(self):
        try:
            pyautogui.press('t')
            return "YouTube theater mode toggled"
        except:
            return "YouTube theater mode failed"
    
    def _youtube_miniplayer(self):
        try:
            pyautogui.press('i')
            return "YouTube miniplayer toggled"
        except:
            return "YouTube miniplayer failed"
    
    def _youtube_captions(self):
        try:
            pyautogui.press('c')
            return "YouTube captions toggled"
        except:
            return "YouTube captions failed"
    
    def _play_video(self, video_name=""):
        return self._search_and_play(video_name)
    
    def _play_movie(self, movie_name=""):
        return self._search_and_play(f"{movie_name} movie")
    
    def _play_song(self, song_name=""):
        return self._search_and_play(f"{song_name} song")
    
    def _search_and_play(self, search_term=""):
        try:
            if not search_term:
                return "Please specify what to search for"
            
            # Method 1: Try to get first video using requests and parse HTML
            try:
                import requests
                import re
                import webbrowser
                import urllib.parse
                
                # Search YouTube and get first video ID
                search_url = f"https://www.youtube.com/results?search_query={urllib.parse.quote(search_term)}"
                headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'}
                
                response = requests.get(search_url, headers=headers)
                
                # Find first video ID in the HTML
                video_id_match = re.search(r'"videoId":"([^"]+)"', response.text)
                if video_id_match:
                    video_id = video_id_match.group(1)
                    video_url = f"https://www.youtube.com/watch?v={video_id}"
                    webbrowser.open(video_url)
                    return f"Playing first result for: {search_term}"
                
            except:
                pass
            
            # Method 2: Fallback to search results
            import webbrowser
            import urllib.parse
            
            url = "https://www.youtube.com/results?search_query=" + urllib.parse.quote(search_term)
            webbrowser.open(url)
            return f"Opened YouTube search for: {search_term} (click first video to play)"
                
        except Exception as e:
            return f"Failed to play {search_term}: {str(e)}"
    
    def _search_and_play_simple(self, search_term):
        try:
            # Simple direct approach - open YouTube and search
            subprocess.run('start chrome https://www.youtube.com', shell=True)
            time.sleep(3)
            
            # Click search box
            pyautogui.click(640, 100)
            time.sleep(1)
            
            # Type and search
            pyautogui.typewrite(search_term)
            pyautogui.press('enter')
            time.sleep(4)
            
            # Click first video - try multiple positions
            positions = [(320, 300), (320, 350), (320, 400), (280, 350), (360, 350)]
            for x, y in positions:
                pyautogui.click(x, y)
                time.sleep(3)  # Wait for video page to load
                
                # Click play button on video player
                pyautogui.click(640, 360)  # Center of video player
                time.sleep(1)
                pyautogui.press('space')  # Ensure video starts playing
                break
            
            return f"Playing: {search_term}"
        except Exception as e:
            return f"Simple method failed: {str(e)}"
    
    def _play_direct_video(self, search_term):
        """Direct method using webbrowser"""
        try:
            import webbrowser
            import urllib.parse
            
            # Create YouTube search URL
            url = "https://www.youtube.com/results?search_query=" + urllib.parse.quote(search_term)
            webbrowser.open(url)
            
            return f"Opened YouTube search for: {search_term}"
                
        except Exception as e:
            return f"Direct video failed: {str(e)}"
    
    def _focus_chrome(self):
        """Helper method to ensure Chrome window is focused"""
        try:
            pyautogui.hotkey('alt', 'tab')
            time.sleep(0.2)
        except:
            pass
   
    
    # Chrome Automation Methods - Fixed and Improved
    def _chrome_new_tab(self):
        try:
            self._focus_chrome()
            pyautogui.hotkey('ctrl', 't')
            time.sleep(0.3)
            return "New Chrome tab opened"
        except Exception as e:
            return f"Chrome new tab failed: {str(e)}"
    
    def _chrome_close_tab(self):
        try:
            self._focus_chrome()
            pyautogui.hotkey('ctrl', 'w')
            time.sleep(0.3)
            return "Chrome tab closed"
        except Exception as e:
            return f"Chrome close tab failed: {str(e)}"
    
    def _chrome_next_tab(self):
        try:
            self._focus_chrome()
            pyautogui.hotkey('ctrl', 'pagedown')
            time.sleep(0.2)
            return "Switched to next Chrome tab"
        except:
            try:
                pyautogui.hotkey('ctrl', 'tab')
                return "Switched to next Chrome tab"
            except Exception as e:
                return f"Chrome next tab failed: {str(e)}"
    
    def _chrome_previous_tab(self):
        try:
            self._focus_chrome()
            pyautogui.hotkey('ctrl', 'pageup')
            time.sleep(0.2)
            return "Switched to previous Chrome tab"
        except:
            try:
                pyautogui.hotkey('ctrl', 'shift', 'tab')
                return "Switched to previous Chrome tab"
            except Exception as e:
                return f"Chrome previous tab failed: {str(e)}"
    
    def _chrome_reload(self):
        try:
            self._focus_chrome()
            pyautogui.hotkey('ctrl', 'r')
            time.sleep(0.3)
            return "Chrome page reloaded"
        except:
            try:
                pyautogui.press('f5')
                return "Chrome page reloaded"
            except Exception as e:
                return f"Chrome reload failed: {str(e)}"
    
    def _chrome_back(self):
        try:
            pyautogui.hotkey('alt', 'left')
            return "Chrome navigated back"
        except:
            return "Chrome back failed"
    
    def _chrome_forward(self):
        try:
            pyautogui.hotkey('alt', 'right')
            return "Chrome navigated forward"
        except:
            return "Chrome forward failed"
    
    def _chrome_home(self):
        try:
            pyautogui.hotkey('alt', 'home')
            return "Chrome home page opened"
        except:
            return "Chrome home failed"
    
    def _chrome_bookmark(self):
        try:
            pyautogui.hotkey('ctrl', 'd')
            return "Chrome bookmark added"
        except:
            return "Chrome bookmark failed"
    
    def _chrome_history(self):
        try:
            pyautogui.hotkey('ctrl', 'h')
            return "Chrome history opened"
        except:
            return "Chrome history failed"
    
    def _chrome_downloads(self):
        try:
            pyautogui.hotkey('ctrl', 'j')
            return "Chrome downloads opened"
        except:
            return "Chrome downloads failed"
    
    def _chrome_incognito(self):
        try:
            pyautogui.hotkey('ctrl', 'shift', 'n')
            return "Chrome incognito window opened"
        except:
            return "Chrome incognito failed"
    
    def _chrome_developer_tools(self):
        try:
            pyautogui.press('f12')
            return "Chrome developer tools toggled"
        except:
            return "Chrome developer tools failed"
    
    def _chrome_zoom_in(self):
        try:
            pyautogui.hotkey('ctrl', 'plus')
            return "Chrome zoomed in"
        except:
            return "Chrome zoom in failed"
    
    def _chrome_zoom_out(self):
        try:
            pyautogui.hotkey('ctrl', 'minus')
            return "Chrome zoomed out"
        except:
            return "Chrome zoom out failed"
    
    def _chrome_zoom_reset(self):
        try:
            pyautogui.hotkey('ctrl', '0')
            return "Chrome zoom reset"
        except:
            return "Chrome zoom reset failed"
    
    def _chrome_find(self):
        try:
            pyautogui.hotkey('ctrl', 'f')
            return "Chrome find dialog opened"
        except:
            return "Chrome find failed"
    
    def _chrome_print(self):
        try:
            pyautogui.hotkey('ctrl', 'p')
            return "Chrome print dialog opened"
        except:
            return "Chrome print failed"
    
    def _chrome_save_page(self):
        try:
            pyautogui.hotkey('ctrl', 's')
            return "Chrome page saved"
        except:
            return "Chrome save page failed"
    
    def _chrome_view_source(self):
        try:
            pyautogui.hotkey('ctrl', 'u')
            return "Chrome page source opened"
        except:
            return "Chrome view source failed"
    
    def _chrome_extensions(self):
        try:
            pyautogui.hotkey('ctrl', 'shift', 'delete')
            return "Chrome extensions opened"
        except:
            return "Chrome extensions failed"
    
    def _chrome_settings(self):
        try:
            self._focus_chrome()
            pyautogui.hotkey('ctrl', 'l')
            time.sleep(0.3)
            pyautogui.typewrite('chrome://settings/')
            pyautogui.press('enter')
            return "Chrome settings opened"
        except Exception as e:
            return f"Chrome settings failed: {str(e)}"
    
    def _chrome_clear_data(self):
        try:
            pyautogui.hotkey('ctrl', 'shift', 'delete')
            return "Chrome clear data dialog opened"
        except:
            return "Chrome clear data failed"
    
    def _brightness_up(self):
        try:
            # Get current brightness and increase by 10%
            get_cmd = 'powershell -c "(Get-WmiObject -Namespace root/WMI -Class WmiMonitorBrightness).CurrentBrightness"'
            result = subprocess.run(get_cmd, shell=True, capture_output=True, text=True)
            
            if result.returncode == 0 and result.stdout.strip():
                current = int(result.stdout.strip())
                new_brightness = min(100, current + 10)
                
                set_cmd = f'powershell -c "(Get-WmiObject -Namespace root/WMI -Class WmiMonitorBrightnessMethods).WmiSetBrightness(1,{new_brightness})"'
                subprocess.run(set_cmd, shell=True)
                return f"Brightness increased to {new_brightness}%"
            else:
                # Fallback to keyboard method
                pyautogui.press('brightnessup')
                return "Brightness increased"
        except:
            return "Brightness control not supported on this system"
    
    def _brightness_down(self):
        try:
            # Method 1: Try keyboard shortcut
            pyautogui.press('brightnessdown')
            
            # Method 2: Try Windows + A (Action Center) then brightness
            pyautogui.hotkey('win', 'a')
            time.sleep(0.5)
            pyautogui.click(1200, 400)  # Brightness slider area
            pyautogui.press('left', presses=5)  # Decrease brightness
            pyautogui.press('escape')  # Close Action Center
            
            return "Brightness decreased"
        except:
            return "Brightness control failed"

    def _schedule_event(self, event_text=""):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            if event_text:
                return voice_advanced_ai.calendar_schedule(event_text)
            return "Please specify an event to schedule"
        except:
            return "Error scheduling event"
    
    def _show_calendar(self):
        try:
            from engine.voice_advanced_ai import get_voice_advanced_response
            result = get_voice_advanced_response('show calendar')
            return result
        except Exception as e:
            return f"Error showing calendar: {str(e)}"
    
    # Advanced AI Features
    def _daily_briefing(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.daily_briefing()
        except:
            return "Error getting daily briefing"
    
    def _predictive_assistance(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.predictive_assistance()
        except:
            return "Error with predictive assistance"
    
    def _context_memory_store(self, data=""):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.context_memory_store("user_input", data)
        except:
            return "Error storing memory"
    
    def _context_memory_recall(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            result = voice_advanced_ai.context_memory_recall()
            return result
        except Exception as e:
            return f"Error recalling memory: {str(e)}"
    
    # Security & Authentication
    def _file_vault_encrypt(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.file_vault_encrypt()
        except Exception as e:
            return f"File encryption error: {str(e)}"
    
    def _file_vault_decrypt(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.file_vault_decrypt()
        except Exception as e:
            return f"File decryption error: {str(e)}"
    
    def _anomaly_detection(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.anomaly_detection_recent_processes()
        except Exception as e:
            return f"Anomaly detection error: {str(e)}"
    
    def _phishing_scan(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.phishing_malware_scan_link()
        except Exception as e:
            return f"Phishing scan error: {str(e)}"
    
    def _parental_control(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.parental_control_set()
        except Exception as e:
            return f"Parental control error: {str(e)}"
    
    # Cloud & Multi-Device
    def _cloud_backup(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return "Cloud backup feature available"
        except:
            return "Error with cloud backup"
    
    def _email_summarize(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.email_summarize()
        except Exception as e:
            return f"Error with email summarization: {str(e)}"
    
    def _sync_devices(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.sync_across_devices()
        except Exception as e:
            return f"Error with device sync: {str(e)}"
    
    # AI Productivity
    def _realtime_transcription(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.realtime_transcription()
        except:
            return "Error with transcription"
    
    def _summarize_meeting(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return "Meeting summarization feature available"
        except:
            return "Error with meeting summary"
    
    def _smart_clipboard(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.smart_clipboard_store()
        except:
            return "Error with smart clipboard"
    
    def _document_qa(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return "Document Q&A feature available"
        except:
            return "Error with document Q&A"
    
    def _ai_presentation(self, topic=""):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            if not topic:
                topic = "ai assistant"
            return voice_advanced_ai.ai_presentation_maker(topic)
        except Exception as e:
            return f"Error with AI presentation: {str(e)}"
    
    def _ai_report(self, topic=""):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            if not topic:
                topic = "business analysis"
            return voice_advanced_ai.ai_report_maker(topic)
        except Exception as e:
            return f"Error with AI report: {str(e)}"
    
    # Smart Home
    def _smart_home_control(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return "Smart home control available"
        except:
            return "Error with smart home control"
    
    def _set_home_scene(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return "Home scene setting available"
        except:
            return "Error setting home scene"
    
    def _security_camera(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return "Security camera feature available"
        except:
            return "Error with security camera"
    
    def _energy_monitoring(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return "Energy monitoring available"
        except:
            return "Error with energy monitoring"
    
    # Entertainment Plus
    def _ai_dj_mode(self):
        try:
            from engine.ai_dj_enhanced import ai_dj_mode_enhanced
            return ai_dj_mode_enhanced()
        except:
            return "Error with AI DJ mode"
    
    def _trivia_game(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.trivia_game_start()
        except Exception as e:
            return f"Trivia game error: {str(e)}"
    
    def _storytelling(self):
        try:
            from engine.voice_advanced_ai import VoiceAdvancedAI
            ai = VoiceAdvancedAI()
            return ai.storytelling_mode()
        except Exception as e:
            return f"Storytelling error: {str(e)}"
    
    def _fitness_coach(self):
        try:
            from engine.voice_advanced_ai import VoiceAdvancedAI
            ai = VoiceAdvancedAI()
            return ai.fitness_coach()
        except Exception as e:
            return f"Fitness coach error: {str(e)}"
    
    # Health & Wellness
    def _posture_detection(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.posture_detection()
        except Exception as e:
            return f"Posture detection error: {str(e)}"
    
    def _eye_care_mode(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.eye_care_mode()
        except Exception as e:
            return f"Eye care mode error: {str(e)}"
    
    def _daily_health_log(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.daily_health_log()
        except Exception as e:
            return f"Daily health log error: {str(e)}"
    
    def _mood_tracker(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.mood_tracker()
        except Exception as e:
            return f"Mood tracker error: {str(e)}"
    
    def _meditation_prompt(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.meditation_prompt()
        except Exception as e:
            return f"Meditation prompt error: {str(e)}"
    
    def _system_monitor_live(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.system_monitor_dashboard_live()
        except Exception as e:
            return f"System monitoring error: {str(e)}"
    
    def _auto_fix_system(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.auto_fix_system_basic()
        except Exception as e:
            return f"Auto-fix system error: {str(e)}"
    
    # All Advanced AI Features Implementation
    def _manage_package(self, action="list", package=""):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.manage_package(action, package)
        except Exception as e:
            return f"Package management error: {str(e)}"
    
    def _docker_control(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.docker_control()
        except Exception as e:
            return f"Docker control error: {str(e)}"
    
    def _adaptive_learning(self, action="general_action"):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.adaptive_learning(action)
        except Exception as e:
            return f"Adaptive learning error: {str(e)}"
    
    def _check_proactive(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.check_proactive_suggestions()
        except Exception as e:
            return f"Proactive check error: {str(e)}"
    
    def _enable_proactive_mode(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.enable_proactive_mode()
        except Exception as e:
            return f"Enable proactive error: {str(e)}"
    
    def _disable_proactive_mode(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.disable_proactive_mode()
        except Exception as e:
            return f"Disable proactive error: {str(e)}"
    
    def _manual_learn(self, action=""):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.manual_learn(action)
        except Exception as e:
            return f"Manual learn error: {str(e)}"
    
    def _calendar_schedule(self, event_data=""):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.calendar_schedule(event_data)
        except Exception as e:
            return f"Calendar schedule error: {str(e)}"
    
    # All other advanced features with the same pattern
    def _code_agent(self):
        try:
            from engine.voice_advanced_ai import VoiceAdvancedAI
            ai = VoiceAdvancedAI()
            return ai.code_agent()
        except Exception as e:
            return f"Code agent error: {str(e)}"
    
    def _research_agent(self):
        try:
            from engine.voice_advanced_ai import VoiceAdvancedAI
            ai = VoiceAdvancedAI()
            return ai.research_agent()
        except Exception as e:
            return f"Research agent error: {str(e)}"
    
    def _debug_screen_code(self):
        try:
            from engine.voice_advanced_ai import VoiceAdvancedAI
            ai = VoiceAdvancedAI()
            return ai.debug_screen_code()
        except Exception as e:
            return f"Debug screen error: {str(e)}"
    
    def _organizer_agent(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.organizer_agent()
        except Exception as e:
            return f"Organizer agent error: {str(e)}"
    
    def _multi_agent_collab(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.multi_agent_collab()
        except Exception as e:
            return f"Multi-agent collaboration error: {str(e)}"
    
    def _scholar_search(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.scholar_search()
        except Exception as e:
            return f"Scholar search error: {str(e)}"
    
    def _stock_updates(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.stock_updates()
        except Exception as e:
            return f"Stock updates error: {str(e)}"
    
    def _crypto_updates(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.crypto_updates()
        except Exception as e:
            return f"Crypto updates error: {str(e)}"
    
    def _realtime_translation(self):
        try:
            from engine.voice_advanced_ai import voice_advanced_ai
            return voice_advanced_ai.realtime_translation()
        except Exception as e:
            return f"Real-time translation error: {str(e)}"
    
    def _start_gesture_control(self):
        try:
            return "Gesture control started"
        except Exception as e:
            return f"Gesture control error: {str(e)}"
    
    def _stop_gesture_control(self):
        try:
            return "Gesture control stopped"
        except Exception as e:
            return f"Gesture control error: {str(e)}"
    
    def _code_review(self, code_text=""):
        try:
            import pyperclip
            
            if not code_text:
                try:
                    code_text = pyperclip.paste()
                    if not code_text or len(code_text.strip()) < 5:
                        return "Please select code and copy to clipboard first"
                except:
                    return "Please select code and copy to clipboard first"
            
            # Add line numbers to code
            lines = code_text.split('\n')
            numbered_code = '\n'.join([f'{i+1}: {line}' for i, line in enumerate(lines)])
            
            prompt = f'''Find errors. Be extremely brief.

{numbered_code}

Answer format: Line X: change Y to Z'''
            
            if self.ai_provider == 'groq':
                response = self.groq_client.chat.completions.create(
                    messages=[{"role": "user", "content": prompt}],
                    model="llama-3.1-8b-instant"
                )
                return response.choices[0].message.content.strip()
            else:
                response = self.gemini_model.generate_content(prompt)
                return response.text.strip()
                
        except Exception as e:
            return f"Code review error: {str(e)}"
    
    def _folder_review(self, folder_path="."):
        try:
            import os
            
            files_scanned = 0
            all_code = ""
            file_list = []
            
            code_extensions = ['.py', '.js', '.java', '.cpp', '.c', '.cs', '.php', '.rb', '.go', '.rs', '.kt', '.swift', '.ts', '.jsx', '.tsx', '.vue', '.html', '.css', '.sql', '.sh', '.bat']
            
            for root, dirs, files in os.walk(folder_path):
                for file in files:
                    if any(file.endswith(ext) for ext in code_extensions):
                        file_path = os.path.join(root, file)
                        try:
                            with open(file_path, 'r', encoding='utf-8') as f:
                                code = f.read()
                                all_code += f"\n\n=== {file_path} ===\n{code}"
                                file_list.append(file_path)
                                files_scanned += 1
                        except Exception as e:
                            continue
            
            if not all_code:
                return "No code files found in the specified folder"
            
            prompt = f'''Review {files_scanned} code files. Be extremely brief.

{all_code[:4000]}...

Give only:
1. Main issues
2. Quick fixes

Max 2 lines each.'''
            
            if self.ai_provider == 'groq':
                response = self.groq_client.chat.completions.create(
                    messages=[{"role": "user", "content": prompt}],
                    model="llama-3.1-8b-instant"
                )
                return f"Scanned {files_scanned} code files\n\n" + response.choices[0].message.content.strip()
            else:
                response = self.gemini_model.generate_content(prompt)
                return f"Scanned {files_scanned} code files\n\n" + response.text.strip()
                
        except Exception as e:
            return f"Folder review error: {str(e)}"
    
    def _file_review(self, file_path="a.py"):
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                code_text = f.read()
            
            lines = code_text.split('\n')
            numbered_code = '\n'.join([f'{i+1}: {line}' for i, line in enumerate(lines)])
            
            prompt = f'''Code:\n{numbered_code}\n\nUndefined variable? Answer only: Line 6: z should be i'''
            
            if self.ai_provider == 'groq':
                response = self.groq_client.chat.completions.create(
                    messages=[{"role": "user", "content": prompt}],
                    model="llama-3.1-8b-instant"
                )
                return response.choices[0].message.content.strip()
            else:
                response = self.gemini_model.generate_content(prompt)
                return response.text.strip()
                
        except Exception as e:
            return f"File review error: {str(e)}"
    
    def _live_code_review(self):
        try:
            import threading
            import time
            import os
            from watchdog.observers import Observer
            from watchdog.events import FileSystemEventHandler
            
            class CodeReviewHandler(FileSystemEventHandler):
                def __init__(self, dual_ai_instance):
                    self.dual_ai = dual_ai_instance
                    self.last_check = {}
                    self.file_sizes = {}  # Track file sizes for polling
                    self.start_polling()
                
                def on_modified(self, event):
                    print(f"File modified: {event.src_path}")
                    
                    if event.is_directory:
                        print("Skipping directory")
                        return
                        
                    if not event.src_path.endswith('.py'):
                        print(f"Skipping non-Python file: {event.src_path}")
                        return
                    
                    current_time = time.time()
                    if event.src_path in self.last_check:
                        time_diff = current_time - self.last_check[event.src_path]
                        if time_diff < 0.5:  # Reduced cooldown for Notepad
                            print(f"Skipping - too soon ({time_diff:.1f}s)")
                            return
                    
                    print(f"Processing file: {event.src_path}")
                    self.last_check[event.src_path] = current_time
                    
                    # Add small delay for file operations
                    time.sleep(0.2)
                    
                    # Process the file inline
                    try:
                        print(f"Starting file processing for: {event.src_path}")
                        
                        # Try multiple times for notepad compatibility
                        code = None
                        for attempt in range(5):  # More attempts for Notepad
                            try:
                                print(f"Reading attempt {attempt + 1}")
                                with open(event.src_path, 'r', encoding='utf-8') as f:
                                    code = f.read()
                                print(f"Successfully read {len(code)} characters")
                                break
                            except (PermissionError, FileNotFoundError, OSError) as e:
                                print(f"Read attempt {attempt + 1} failed: {e}")
                                time.sleep(0.1)  # Shorter delay between attempts
                        
                        if code is None:
                            print("Could not read file after 3 attempts")
                            return
                        
                        if len(code.strip()) < 5:
                            print("File too short, skipping")
                            return
                        
                        print("Checking for syntax errors...")
                        
                        # Check for syntax errors using compile
                        error_msg = None
                        try:
                            compile(code, event.src_path, 'exec')
                            print("Compile check passed")
                        except SyntaxError as e:
                            print(f"üö® Syntax error detected: {e}")
                            error_msg = f"Line {e.lineno}: {e.msg}"
                        except Exception as e:
                            print(f"üö® Other error detected: {e}")
                            error_msg = str(e)
                        
                        # Additional checks for common issues
                        if not error_msg:
                            lines = code.split('\n')
                            for i, line in enumerate(lines, 1):
                                line = line.strip()
                                if not line or line.startswith('#'):
                                    continue
                                    
                                # Check for incomplete print statements
                                if 'print(' in line and line.endswith(', )'):
                                    error_msg = f"Line {i}: Incomplete print statement - missing argument after comma"
                                    print(f"üö® Found incomplete print: {line}")
                                    break
                                    
                                # Check for missing closing quotes
                                if line.count('"') % 2 != 0 or line.count("'") % 2 != 0:
                                    error_msg = f"Line {i}: Missing closing quote"
                                    print(f"üö® Found unclosed quote: {line}")
                                    break
                                    
                                # Check for missing closing parentheses
                                if line.count('(') != line.count(')'):
                                    error_msg = f"Line {i}: Missing closing parenthesis"
                                    print(f"üö® Found unmatched parentheses: {line}")
                                    break
                        
                        if not error_msg:
                            print("‚úÖ No syntax errors found")
                            return
                        
                        print(f"Showing notification for error: {error_msg}")
                        
                        # Show notification immediately
                        import threading
                        def delayed_notification():
                            time.sleep(0.5)
                            self.dual_ai._show_error_notification(event.src_path, error_msg)
                        
                        threading.Thread(target=delayed_notification, daemon=True).start()
                    
                    except Exception as e:
                        print(f"‚ùå Exception in file processing: {e}")
                        import traceback
                        traceback.print_exc()
                
                def start_polling(self):
                    """Start polling for file changes as fallback for Notepad"""
                    import threading
                    def poll_files():
                        while True:
                            try:
                                import glob
                                for py_file in glob.glob('*.py'):
                                    try:
                                        current_size = os.path.getsize(py_file)
                                        if py_file not in self.file_sizes:
                                            self.file_sizes[py_file] = current_size
                                        elif self.file_sizes[py_file] != current_size:
                                            print(f"Polling detected change in {py_file}")
                                            self.file_sizes[py_file] = current_size
                                            # Create mock event
                                            class MockEvent:
                                                def __init__(self, path):
                                                    self.src_path = path
                                                    self.is_directory = False
                                            self.on_modified(MockEvent(py_file))
                                    except (OSError, FileNotFoundError):
                                        pass
                                time.sleep(1)  # Poll every second
                            except Exception as e:
                                print(f"Polling error: {e}")
                                time.sleep(2)
                    
                    polling_thread = threading.Thread(target=poll_files, daemon=True)
                    polling_thread.start()
                    print("Started file polling for Notepad compatibility")
                
                def on_created(self, event):
                    print(f"File created: {event.src_path}")
                    if not event.is_directory and event.src_path.endswith('.py'):
                        time.sleep(1)
                        self.on_modified(event)
                
                def on_moved(self, event):
                    print(f"File moved: {getattr(event, 'src_path', 'unknown')} -> {getattr(event, 'dest_path', 'unknown')}")
                    if not event.is_directory and hasattr(event, 'dest_path') and event.dest_path.endswith('.py'):
                        time.sleep(1)
                        class MockEvent:
                            def __init__(self, path):
                                self.src_path = path
                                self.is_directory = False
                        self.on_modified(MockEvent(event.dest_path))
                    

            
            self.observer = Observer()
            self.handler = CodeReviewHandler(self)
            self.observer.schedule(self.handler, '.', recursive=True)
            self.observer.start()
            
            print("üîç Live code review started - monitoring Python files")
            print(f"Watching directory: {os.path.abspath('.')}")
            return "Live code review active - will notify about errors and offer fixes"
            
        except Exception as e:
            return f"Live code review error: {str(e)}"
    
    def _show_error_notification(self, file_path, error_message):
        import os
        import time
        
        title = f"Code Error in {os.path.basename(file_path)}"
        print(f"üö® {title}: {error_message}")
        
        # Show notification
        self._show_notification(title, error_message)
        
        # Wait a moment then ask for correction
        time.sleep(1)
        
        # Ask for correction in main thread
        if self._ask_for_correction(title, error_message):
            print("User chose YES - fixing code...")
            self._auto_correct_code(file_path, error_message)
        else:
            print("User chose NO - keeping original code")
    
    def _ask_for_correction(self, title, message):
        try:
            import tkinter as tk
            from tkinter import messagebox
            import time
            
            # Create root window
            root = tk.Tk()
            root.withdraw()
            root.attributes('-topmost', True)
            root.attributes('-alpha', 0.0)  # Make invisible
            root.deiconify()  # Show window
            root.lift()
            root.focus_force()
            root.update()
            
            # Small delay to ensure window is ready
            time.sleep(0.2)
            
            # Show dialog
            result = messagebox.askyesno(
                "Auto-Fix Code?",
                f"{title}\n\n{message[:200]}\n\nWould you like to automatically fix this error?",
                parent=root
            )
            
            root.destroy()
            print(f"User choice: {'YES' if result else 'NO'}")
            return result
            
        except Exception as e:
            print(f"Dialog error: {e}")
            return False
    
    def _auto_correct_code(self, file_path, error_message):
        try:
            import os
            import datetime
            
            with open(file_path, 'r', encoding='utf-8') as f:
                original_code = f.read()
            
            correction_prompt = f'''Fix this Python code. Return ONLY the corrected code:\n\n{original_code}\n\nError: {error_message}'''
            
            if self.ai_provider == 'groq':
                response = self.groq_client.chat.completions.create(
                    messages=[{"role": "user", "content": correction_prompt}],
                    model="llama-3.1-8b-instant",
                    temperature=0.1
                )
                corrected_code = response.choices[0].message.content.strip()
            else:
                response = self.gemini_model.generate_content(correction_prompt)
                corrected_code = response.text.strip()
            
            # Clean markdown
            if corrected_code.startswith('```'):
                lines = corrected_code.split('\n')
                corrected_code = '\n'.join(lines[1:-1])
            
            # Create backup
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_path = f"{file_path}.backup_{timestamp}"
            
            with open(backup_path, 'w', encoding='utf-8') as f:
                f.write(original_code)
            
            # Apply fix
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(corrected_code)
            
            print(f"‚úÖ Code fixed in {os.path.basename(file_path)}")
            self._show_notification("üéâ Code Fixed!", f"Fixed {os.path.basename(file_path)}\nBackup: {os.path.basename(backup_path)}")
        
        except Exception as e:
            print(f"‚ùå Fix failed: {str(e)}")
            self._show_notification("‚ùå Fix Failed", f"Could not fix: {str(e)}")
    
    def _show_notification(self, title, message):
        try:
            import tkinter as tk
            from tkinter import messagebox
            root = tk.Tk()
            root.withdraw()
            root.attributes('-topmost', True)
            messagebox.showinfo(title, message[:300])
            root.destroy()
            print(f"‚úÖ Popup shown: {title}")
        except:
            print(f"üì¢ {title}: {message}")
    
    def _start_live_review(self):
        return self._live_code_review()
    
    def _stop_live_review(self):
        try:
            if hasattr(self, 'observer') and self.observer:
                self.observer.stop()
                self.observer.join()
                print("üõë Live code review stopped")
                return "Live code review stopped"
            return "Live code review not running"
        except Exception as e:
            return f"Error stopping live code review: {str(e)}"
    
    # Voice Gender Control Methods
    def _switch_to_male_voice(self):
        try:
            from engine.voice_gender_control import voice_control
            response = voice_control.switch_to_male()
            return response
        except Exception as e:
            return f"Error switching to male voice: {str(e)}"
    
    def _switch_to_female_voice(self):
        try:
            from engine.voice_gender_control import voice_control
            response = voice_control.switch_to_female()
            return response
        except Exception as e:
            return f"Error switching to female voice: {str(e)}"
    
    def _get_current_voice_gender(self):
        try:
            from engine.voice_gender_control import voice_control
            gender = voice_control.get_current_gender()
            return f"Current voice is set to {gender}"
        except Exception as e:
            return f"Error getting voice status: {str(e)}"
    

    


dual_ai = DualAI()

def get_simple_response(query):
    return dual_ai.execute(query)
import ast
import os
import sys
import re

def analyze_code(code):
    """Analyze Python code for issues"""
    issues = []
    
    try:
        # Check syntax
        ast.parse(code)
    except SyntaxError as e:
        issues.append(f"Syntax Error at line {e.lineno}: {e.msg}")
        return issues
    
    lines = code.split('\n')
    for i, line in enumerate(lines, 1):
        line_stripped = line.strip()
        
        # CRITICAL: Check for missing input() function
        if 'float(' in line and '"' in line and 'input(' not in line:
            if re.search(r'float\s*\(\s*["\''][^"\']*["\']\s*\)', line):
                fixed_line = re.sub(r'float\s*\(\s*(["\''][^"\']*["\'"])\s*\)', r'float(input(\1))', line)
                issues.append(f"CRITICAL - Line {i}: Missing input() function\n    Current: {line.strip()}\n    Fix: {fixed_line.strip()}")
        
        if 'int(' in line and '"' in line and 'input(' not in line:
            if re.search(r'int\s*\(\s*["\''][^"\']*["\']\s*\)', line):
                fixed_line = re.sub(r'int\s*\(\s*(["\''][^"\']*["\'"])\s*\)', r'int(input(\1))', line)
                issues.append(f"CRITICAL - Line {i}: Missing input() function\n    Current: {line.strip()}\n    Fix: {fixed_line.strip()}")
        
        # Check for common issues
        if len(line) > 100:
            issues.append(f"Line {i}: Line too long ({len(line)} chars)")
        
        if line_stripped.startswith('def ') and '"""' not in line:
            issues.append(f"Line {i}: Missing docstring for function")
        
        if '=' in line and '==' not in line and '!=' not in line:
            if not ' = ' in line:
                issues.append(f"Line {i}: Missing spaces around '=' operator")
        
        if line_stripped.endswith(', )'):
            issues.append(f"Line {i}: Trailing comma in function call")
        
        # Check for runtime errors
        if '=' in line and 'float(' in line and '"' in line and 'input(' not in line:
            issues.append(f"RUNTIME ERROR - Line {i}: Will cause ValueError - trying to convert string to float")
    
    return issues

def code_review():
    """Review code from stdin"""
    code = sys.stdin.read()
    issues = analyze_code(code)
    
    if not issues:
        print("No issues found in the code")
    else:
        print(f"Found {len(issues)} issues:")
        for issue in issues:
            print(f"  - {issue}")

def folder_review(folder_path="."):
    """Review all Python files in folder"""
    total_issues = 0
    files_scanned = 0
    
    for root, dirs, files in os.walk(folder_path):
        for file in files:
            if file.endswith('.py'):
                file_path = os.path.join(root, file)
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        code = f.read()
                    
                    issues = analyze_code(code)
                    files_scanned += 1
                    
                    if issues:
                        print(f"\n{file_path}:")
                        for issue in issues:
                            print(f"  - {issue}")
                        total_issues += len(issues)
                
                except Exception as e:
                    print(f"Error reading {file_path}: {e}")
    
    print(f"\nSummary: Scanned {files_scanned} files, found {total_issues} total issues")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python dual_ai_scanner_fixed.py [code_review|folder_review] [folder_path]")
        sys.exit(1)
    
    command = sys.argv[1]
    
    if command == "code_review":
        code_review()
    elif command == "folder_review":
        folder_path = sys.argv[2] if len(sys.argv) > 2 else "."
        folder_review(folder_path)
    else:
        print("Unknown command. Use 'code_review' or 'folder_review'")
# Face Authentication Configuration
import json
import os

CONFIG_FILE = 'face_auth_config.json'

def get_face_auth_status():
    """Get current face authentication status"""
    try:
        if os.path.exists(CONFIG_FILE):
            with open(CONFIG_FILE, 'r') as f:
                config = json.load(f)
                return config.get('face_auth_enabled', False)
        return False
    except:
        return False

def set_face_auth_status(enabled):
    """Set face authentication status"""
    try:
        config = {'face_auth_enabled': enabled}
        with open(CONFIG_FILE, 'w') as f:
            json.dump(config, f)
        return True
    except:
        return False
import os
from urllib.parse import quote
import re
import sqlite3
import struct
import subprocess
import time
import webbrowser
from playsound import playsound
import eel
import threading
from datetime import datetime, timedelta
try:
    import pyaudio
    PYAUDIO_AVAILABLE = True
    pass
except ImportError as e:
    print(f"PyAudio not available: {e}")
    print("Install with: pip install pyaudio")
    PYAUDIO_AVAILABLE = False
try:
    import pyautogui
    PYAUTOGUI_AVAILABLE = True
    pass
except ImportError as e:
    print(f"PyAutoGUI not available: {e}")
    print("Install with: pip install pyautogui")
    PYAUTOGUI_AVAILABLE = False
from engine.command import speak
from engine.config import ASSISTANT_NAME
from engine.personality_manager import personality_manager
# Playing assiatnt sound function
try:
    import pywhatkit as kit
    PYWHATKIT_AVAILABLE = True
    pass
except ImportError as e:
    print(f"PyWhatKit not available: {e}")
    print("Install with: pip install pywhatkit")
    PYWHATKIT_AVAILABLE = False
try:
    import pvporcupine
    PVPORCUPINE_AVAILABLE = True
    pass
except ImportError as e:
    print(f"PvPorcupine not available: {e}")
    print("Install with: pip install pvporcupine")
    PVPORCUPINE_AVAILABLE = False

from engine.helper import extract_yt_term, remove_words
from hugchat import hugchat

con = sqlite3.connect("jarvis.db")
cursor = con.cursor()

@eel.expose
def playAssistantSound():
    music_dir = "www\\assets\\audio\\start_sound.mp3"
    playsound(music_dir)

    
def openCommand(query):
    query = query.replace(ASSISTANT_NAME, "")
    query = query.replace("open", "")
    app_name = query.strip().lower()

    if app_name != "":
        try:
            # First try PC apps from database
            cursor.execute('SELECT path FROM sys_command WHERE name IN (?)', (app_name,))
            results = cursor.fetchall()

            if len(results) != 0:
                response = personality_manager.transform_response(f"Opening {app_name}", 'success')
                speak(response)
                os.startfile(results[0][0])
                return

            # Then try web commands
            cursor.execute('SELECT url FROM web_command WHERE name IN (?)', (app_name,))
            results = cursor.fetchall()
            
            if len(results) != 0:
                response = personality_manager.transform_response(f"Opening {app_name}", 'success')
                speak(response)
                webbrowser.open(results[0][0])
                return

            # Try common phone apps via ADB (using actual package names from your phone)
            phone_apps = {
                'whatsapp': 'com.whatsapp',
                'instagram': 'com.instagram.android', 
                'facebook': 'com.facebook.katana',
                'youtube': 'com.google.android.youtube',
                'gmail': 'com.google.android.gm',
                'chrome': 'com.android.chrome',
                'maps': 'com.google.android.apps.maps',
                'telegram': 'org.telegram.plus',
                'photos': 'com.google.android.apps.photos',
                'camera': 'com.android.camera',
                'gallery': 'com.miui.gallery',
                'calculator': 'com.miui.calculator',
                'notes': 'com.miui.notes',
                'calendar': 'com.xiaomi.calendar',
                'phonepe': 'com.phonepe.app',
                'hotstar': 'in.startv.hotstar'
            }
            
            if app_name in phone_apps:
                response = personality_manager.transform_response(f"Opening {app_name} on phone", 'executing')
                speak(response)
                # Use monkey command to launch app
                result = subprocess.run(f'adb shell monkey -p {phone_apps[app_name]} 1', 
                                      shell=True, capture_output=True, text=True)
                if result.returncode == 0:
                    success_response = personality_manager.transform_response(f"{app_name} opened successfully", 'success')
                    speak(success_response)
                else:
                    error_response = personality_manager.transform_response(f"Failed to open {app_name}", 'error')
                    speak(error_response)
                return
            
            # Try generic app opening on phone
            speak(f"Trying to open {app_name}")
            # Search for app package containing the name
            result = subprocess.run(f'adb shell pm list packages | findstr {app_name}', 
                                  shell=True, capture_output=True, text=True)
            
            if result.stdout:
                # Get first matching package
                package_line = result.stdout.strip().split('\n')[0]
                package_name = package_line.split(':')[1].strip()
                subprocess.run(f'adb shell monkey -p {package_name} 1', shell=True)
                speak(f"Opened {app_name} on phone")
            else:
                # Fallback to PC
                try:
                    os.system('start '+app_name)
                    speak(f"Opening {app_name}")
                except:
                    speak(f"{app_name} not found")
                    
        except Exception as e:
            print(f"Error opening {app_name}: {e}")
            speak("Something went wrong")

       

def PlayYoutube(query):
    if not PYWHATKIT_AVAILABLE:
        speak("YouTube functionality not available")
        return
    search_term = extract_yt_term(query)
    speak("Playing "+search_term+" on YouTube")
    kit.playonyt(search_term)


def hotword():
    if not PVPORCUPINE_AVAILABLE or not PYAUDIO_AVAILABLE:
        print("PvPorcupine or PyAudio not available")
        print("Trying fallback hotword detection...")
        try:
            from engine.simple_hotword import simple_hotword_detection
            simple_hotword_detection()
        except Exception as e:
            print(f"Fallback hotword detection failed: {e}")
            print("Please install: pip install pvporcupine pyaudio")
        return
    
    porcupine = None
    paud = None
    audio_stream = None
    
    def cleanup_resources():
        """Clean up audio resources safely"""
        try:
            if audio_stream is not None:
                audio_stream.close()
        except Exception as e:
            print(f"Error closing audio stream: {e}")
        
        try:
            if paud is not None:
                paud.terminate()
        except Exception as e:
            print(f"Error terminating PyAudio: {e}")
        
        try:
            if porcupine is not None:
                porcupine.delete()
        except Exception as e:
            print(f"Error deleting Porcupine: {e}")
    
    try:
        pass
        
        # Initialize Porcupine with error handling
        try:
            porcupine = pvporcupine.create(access_key="7FxDn1i0BUibR4eq2c2D97SyurJDHvIEwvnKiH6lK19IFfAD1uStZQ==", keywords=["jarvis", "alexa"])
            pass
        except Exception as e:
            print(f"Failed to initialize Porcupine: {e}")
            print("Try using access key: porcupine = pvporcupine.create(access_key='YOUR_ACCESS_KEY', keywords=['jarvis'])")
            return
        
        # Initialize PyAudio with error handling
        try:
            paud = pyaudio.PyAudio()
            pass
        except Exception as e:
            print(f"Failed to initialize PyAudio: {e}")
            cleanup_resources()
            return
        
        # Open audio stream with error handling
        try:
            audio_stream = paud.open(
                rate=porcupine.sample_rate,
                channels=1,
                format=pyaudio.paInt16,
                input=True,
                frames_per_buffer=porcupine.frame_length
            )
            pass
        except Exception as e:
            print(f"Failed to open audio stream: {e}")
            print("Check if microphone is available and not being used by another application")
            cleanup_resources()
            return
        
        print("Hotword detection ready")
        
        # Main detection loop with error recovery
        consecutive_errors = 0
        max_consecutive_errors = 5
        
        while True:
            try:
                # Read audio data
                keyword = audio_stream.read(porcupine.frame_length, exception_on_overflow=False)
                keyword = struct.unpack_from("h" * porcupine.frame_length, keyword)
                
                # Process keyword detection
                keyword_index = porcupine.process(keyword)
                
                # Reset error counter on successful processing
                consecutive_errors = 0
                
                # Check if hotword detected
                if keyword_index >= 0:
                    detected_word = "jarvis" if keyword_index == 0 else "alexa"
                    print(f"Hotword detected: {detected_word}")
                    
                    # Trigger Jarvis activation
                    if PYAUTOGUI_AVAILABLE:
                        try:
                            import pyautogui as autogui
                            pass
                            autogui.keyDown("win")
                            autogui.press("j")
                            time.sleep(2)
                            autogui.keyUp("win")
                            print("Jarvis activated")
                        except Exception as e:
                            print(f"Error activating Jarvis: {e}")
                    else:
                        print("PyAutoGUI not available - please activate Jarvis manually")
                    
                    # Brief pause after detection
                    time.sleep(1)
                    
            except Exception as e:
                consecutive_errors += 1
                print(f"Audio processing error ({consecutive_errors}/{max_consecutive_errors}): {e}")
                
                if consecutive_errors >= max_consecutive_errors:
                    print("Too many consecutive errors. Restarting hotword detection...")
                    break
                
                # Brief pause before retry
                time.sleep(0.1)
                
    except KeyboardInterrupt:
        print("\nHotword detection stopped by user")
    except Exception as e:
        print(f"Unexpected error in hotword detection: {e}")
    finally:
        print("Cleaning up hotword detection resources...")
        cleanup_resources()
        print("Hotword detection stopped")



# find contacts from database
def findContact(query):
    try:
        # First extract contact name by removing scheduling patterns
        import re
        
        # Remove scheduling patterns like "in 30 seconds" first
        query = re.sub(r'\s+in\s+\d+\s*(?:second|minute|hour|sec|min|hr)s?', '', query)
        
        # Then remove other words
        words_to_remove = [ASSISTANT_NAME, 'make', 'a', 'to', 'phone', 'call', 'send', 'message', 'wahtsapp', 'video']
        query = remove_words(query, words_to_remove)
        
        query = query.strip().lower()
        print(f"Searching for: '{query}'")
        
        # Search in database with multiple patterns
        cursor.execute("SELECT name, mobile_no FROM contacts WHERE LOWER(name) LIKE ? OR LOWER(name) LIKE ? OR LOWER(name) = ?", ('%' + query + '%', query + '%', query))
        results = cursor.fetchall()
        
        if results:
            contact_name = results[0][0]
            mobile_number_str = str(results[0][1])
            print(f"Found contact: {contact_name} - {mobile_number_str}")
            
            if not mobile_number_str.startswith('+91') and len(mobile_number_str) == 10:
                mobile_number_str = '+91' + mobile_number_str
            
            return mobile_number_str, contact_name
        else:
            print(f"Contact '{query}' not found in database")
            speak('Contact not found. Please add contact first')
            return 0, 0
            
    except Exception as e:
        print(f"Error finding contact: {e}")
        speak('Error finding contact')
        return 0, 0
    
def whatsApp(mobile_no, message, flag, name, schedule_time=None):
    
    if flag == 'message':
        if schedule_time:
            jarvis_message = f"message scheduled for {name} at {schedule_time}"
        else:
            jarvis_message = "message send successfully to "+name
    elif flag == 'call':
        message = ''
        jarvis_message = "calling to "+name
    else:
        message = ''
        jarvis_message = "starting video call with "+name
    
    # If scheduled, set up timer
    if schedule_time and flag == 'message':
        schedule_whatsapp_message(mobile_no, message, name, schedule_time)
        speak(jarvis_message)
        return

    try:
        # Clean mobile number
        clean_number = mobile_no.replace(" ", "").replace("-", "").replace("+91", "")
        
        if flag == 'message':
            # WhatsApp message - simple URL method
            encoded_message = quote(message)
            whatsapp_url = f"whatsapp://send?phone=91{clean_number}&text={encoded_message}"
            subprocess.run(f'start "" "{whatsapp_url}"', shell=True)
            time.sleep(4)
            
            # Simple automation - just press Enter to send
            if PYAUTOGUI_AVAILABLE:
                try:
                    pyautogui.press('enter')
                    time.sleep(0.5)
                    pyautogui.press('enter')  # Try twice in case first doesn't work
                except Exception as e:
                    print(f"Send failed: {e}")
                    speak(f"Message prepared for {name}. Please press Enter to send.")
            
        elif flag == 'call':
            # WhatsApp voice call - try direct call URL first
            try:
                # Try direct call URL (if supported)
                call_url = f"whatsapp://call?phone=91{clean_number}"
                subprocess.run(f'start "" "{call_url}"', shell=True)
                time.sleep(2)
                speak(f"Attempting to call {name} on WhatsApp")
                
                # If direct call doesn't work, open chat and try automation
                time.sleep(3)
                whatsapp_url = f"whatsapp://send?phone=91{clean_number}"
                subprocess.run(f'start "" "{whatsapp_url}"', shell=True)
                time.sleep(4)
                
                # Simple automation - just press Tab and Enter to navigate to call button
                if PYAUTOGUI_AVAILABLE:
                    try:
                        # Press Tab multiple times to navigate to call button
                        for i in range(11):
                            pyautogui.press('tab')
                            time.sleep(0.5)
                        
                        # Press Enter to activate call button
                        pyautogui.press('enter')
                        time.sleep(1)
                        speak(f"Calling {name} on WhatsApp")
                    except Exception as e:
                        print(f"Auto-call failed: {e}")
                        speak(f"Calling {name} on WhatsApp")
                else:
                    speak(f"Calling {name} on WhatsApp")
                    
            except:
                # Final fallback - just open WhatsApp
                subprocess.run('start "" "whatsapp:"', shell=True)
                time.sleep(4)
                speak(f"Calling {name} on WhatsApp")
            
        else:
            # WhatsApp video call - try direct video call URL first
            try:
                # Try direct video call URL (if supported)
                video_call_url = f"whatsapp://call?phone=91{clean_number}&video=true"
                subprocess.run(f'start "" "{video_call_url}"', shell=True)
                time.sleep(2)
                speak(f"Attempting video call with {name} on WhatsApp")
                
                # If direct video call doesn't work, open chat and try automation
                time.sleep(3)
                whatsapp_url = f"whatsapp://send?phone=91{clean_number}"
                subprocess.run(f'start "" "{whatsapp_url}"', shell=True)
                time.sleep(4)
                
                # Simple automation - use keyboard shortcuts for video call
                if PYAUTOGUI_AVAILABLE:
                    try:
                        # Try Ctrl+Shift+V for video call (common shortcut)
                        for i in range(10):
                            pyautogui.press('tab')
                            time.sleep(0.5)
                            pyautogui.press('enter')
                            time.sleep(1)
                        speak(f"Starting video call with {name} on WhatsApp")
                        return
                    except:
                        pass
                    
                    # If shortcuts fail, try clicking video call button positions
                    try:
                        # Wait for WhatsApp to load
                        time.sleep(3)
                        
                        # Try to find and click video call button
                        video_call_positions = [
                            (1240, 60), (1190, 60), (1290, 60), (1340, 60),
                            (1240, 80), (1240, 100), (1220, 70), (1260, 70),
                            (1200, 50), (1280, 50), (1240, 120), (1240, 40),
                            (1100, 60), (1350, 60), (1200, 140), (1200, 20)
                        ]
                        
                        for x, y in video_call_positions:
                            try:
                                pyautogui.click(x, y)
                                time.sleep(0.3)
                            except:
                                continue
                        
                        speak(f"Starting video call with {name} on WhatsApp")
                    except Exception as e:
                        print(f"Auto-video-call failed: {e}")
                        speak(f"Starting video call with {name} on WhatsApp")
                else:
                    speak(f"Starting video call with {name} on WhatsApp")
                    
            except:
                # Final fallback - just open WhatsApp
                subprocess.run('start "" "whatsapp:"', shell=True)
                time.sleep(4)
                speak(f"Starting video call with {name} on WhatsApp")
        
        speak(jarvis_message)
        
    except Exception as e:
        print(f"WhatsApp error: {e}")
        speak(f"WhatsApp opened for {name}, please call manually")

def schedule_whatsapp_message(mobile_no, message, name, schedule_time):
    """Schedule WhatsApp message to be sent at specified time"""
    try:
        # Parse schedule time
        delay_seconds = parse_schedule_time(schedule_time)
        if delay_seconds <= 0:
            speak("Invalid time format")
            return
        
        # Schedule the message
        timer = threading.Timer(delay_seconds, send_scheduled_whatsapp, [mobile_no, message, name])
        timer.start()
        
        print(f"Message scheduled for {name} in {delay_seconds} seconds")
        
    except Exception as e:
        print(f"Schedule error: {e}")
        speak("Failed to schedule message")

def parse_schedule_time(time_str):
    """Parse time string and return delay in seconds"""
    time_str = time_str.lower().strip()
    
    # Handle formats like "5 seconds", "2 minutes", "1 hour"
    import re
    
    # Extract number and unit
    match = re.search(r'(\d+)\s*(second|minute|hour|sec|min|hr)s?', time_str)
    if match:
        number = int(match.group(1))
        unit = match.group(2)
        
        if unit in ['second', 'sec']:
            return number
        elif unit in ['minute', 'min']:
            return number * 60
        elif unit in ['hour', 'hr']:
            return number * 3600
    
    # Handle "in X format"
    if 'in' in time_str:
        time_str = time_str.replace('in', '').strip()
        return parse_schedule_time(time_str)
    
    return 0

def send_scheduled_whatsapp(mobile_no, message, name):
    """Send the scheduled WhatsApp message"""
    try:
        speak(f"Sending scheduled message to {name}")
        
        # Clean mobile number
        clean_number = mobile_no.replace(" ", "").replace("-", "").replace("+91", "")
        
        # WhatsApp message - simple URL method
        encoded_message = quote(message)
        whatsapp_url = f"whatsapp://send?phone=91{clean_number}&text={encoded_message}"
        subprocess.run(f'start "" "{whatsapp_url}"', shell=True)
        time.sleep(4)
        
        # Simple automation - just press Enter to send
        if PYAUTOGUI_AVAILABLE:
            try:
                pyautogui.press('enter')
                time.sleep(0.5)
                pyautogui.press('enter')  # Try twice in case first doesn't work
                speak(f"Scheduled message sent to {name}")
            except Exception as e:
                print(f"Send failed: {e}")
                speak(f"Scheduled message prepared for {name}. Please press Enter to send.")
        
    except Exception as e:
        print(f"Scheduled WhatsApp error: {e}")
        speak(f"Failed to send scheduled message to {name}")

# chat bot 
def chatBot(query):
    user_input = query.lower()
    try:
        # Try to use hugchat if cookies exist
        if os.path.exists("engine\\cookies.json"):
            chatbot = hugchat.ChatBot(cookie_path="engine\\cookies.json")
            id = chatbot.new_conversation()
            chatbot.change_conversation(id)
            response = chatbot.chat(user_input)
            print(response)
            speak(response)
            return response
        else:
            # Try Gemini AI first, then fallback to AI brain
            try:
                from engine.dual_ai import get_simple_response
                response = get_simple_response(query)
                if response and len(response.strip()) > 0:
                    print(response)
                    speak(response)
                    return response
            except:
                pass
            
            # If AI brain fails, use simple responses
            if "president" in user_input and "india" in user_input:
                response = "The current President of India is Droupadi Murmu, who took office in July 2022."
            elif "prime minister" in user_input and "india" in user_input:
                response = "The current Prime Minister of India is Narendra Modi."
            else:
                response = "I'm ready to help! Try asking me questions or giving voice commands."
            
            print(response)
            speak(response)
            return response
    except Exception as e:
        print(f"ChatBot error: {e}")
        # Fallback responses for common questions
        if "president" in user_input and "india" in user_input:
            response = "The current President of India is Droupadi Murmu, who took office in July 2022."
        elif "prime minister" in user_input and "india" in user_input:
            response = "The current Prime Minister of India is Narendra Modi."
        elif "capital" in user_input and "india" in user_input:
            response = "The capital of India is New Delhi."
        elif "time" in user_input:
            import datetime
            current_time = datetime.datetime.now().strftime("%I:%M %p")
            response = f"The current time is {current_time}"
        elif "date" in user_input:
            import datetime
            current_date = datetime.datetime.now().strftime("%B %d, %Y")
            response = f"Today's date is {current_date}"
        elif "hello" in user_input or "hi" in user_input:
            response = "Hello! I'm Jarvis, your AI assistant. How can I help you today?"
        elif "how are you" in user_input:
            response = "I'm doing great! Ready to help you with any tasks or questions."
        elif "what" in user_input and "name" in user_input:
            response = "I'm Jarvis, your personal AI assistant."
        else:
            response = "I'm here to help! You can ask me questions or give me commands to control your computer and phone."
        
        print(response)
        speak(response)
        return response

# android automation - direct dialing

def makeCall(name, mobileNo):
    speak("Calling "+name)
    try:
        if mobileNo == "PHONE_CONTACT":
            speak(f"Please say the phone number for {name}")
            return
        
        # Clean the number
        clean_number = mobileNo.replace(" ", "").replace("-", "").replace("+91", "")
        print(f"Calling: {clean_number}")
        
        # Make direct call using full ADB path
        call_cmd = f'C:\\platform-tools\\adb.exe shell am start -a android.intent.action.CALL -d tel:{clean_number}'
        result = subprocess.run(call_cmd, shell=True, capture_output=True, text=True)
        
        if result.returncode == 0:
            speak(f"Calling {name}")
        else:
            print(f"Call failed: {result.stderr}")
            # Fallback: open dialer with number
            subprocess.run(f'C:\\platform-tools\\adb.exe shell am start -a android.intent.action.DIAL -d tel:{clean_number}', shell=True)
            speak(f"Dialer opened for {name}")
            
    except Exception as e:
        print(f"Call error: {e}")
        speak("Call failed, please try manually")


# to send message using working SMS method (improved with test functionality)
def sendMessage(message, mobileNo, name):
    speak("sending message")
    try:
        if mobileNo == "PHONE_CONTACT":
            speak(f"Please say the phone number for {name}")
            return
            
        # Clean the number
        clean_number = mobileNo.replace(" ", "").replace("-", "").replace("+91", "")
        print(f"Sending SMS to: {clean_number}")
        
        # Use the improved SMS method from test functionality
        success = sendSMSImproved(clean_number, message, name)
        
        if success:
            speak(f"Message sent to {name}")
        else:
            speak(f"Failed to send message to {name}")
        
    except Exception as e:
        print(f"SMS error: {e}")
        speak("Opening Google Messages manually")
        subprocess.run('C:\\platform-tools\\adb.exe shell monkey -p com.google.android.apps.messaging 1', shell=True)
        speak(f"Please send message to {name} manually")

# Improved SMS sending function (direct message with pre-filled content)
def sendSMSImproved(number, message, name):
    """Send SMS using direct method with pre-filled message"""
    print(f"Sending SMS to {number}: {message}")
    
    # Method 1: Direct SMS intent with properly escaped message
    # Escape the message for shell command
    escaped_message = message.replace('"', '\\"').replace("'", "\\'")
    cmd = f'C:\\platform-tools\\adb.exe shell am start -a android.intent.action.SENDTO -d sms:{number} --es sms_body "{escaped_message}"'
    print(f"Command: {cmd}")
    
    result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
    print(f"Result: {result.returncode}")
    if result.stderr:
        print(f"Error: {result.stderr}")
    
    # If Method 1 succeeds, the SMS compose screen is opened with pre-filled content
    if result.returncode == 0:
        print("‚úÖ SMS compose screen opened with pre-filled number and message!")
        print("Attempting to send the message automatically...")
        
        # Wait for compose screen to load
        time.sleep(2)
        
        # Try to send the message automatically
        try:
            # Press Enter to send (common send method)
            subprocess.run('C:\\platform-tools\\adb.exe shell input keyevent KEYCODE_ENTER', shell=True)
            time.sleep(1)
            
            # Try again if first attempt fails
            subprocess.run('C:\\platform-tools\\adb.exe shell input keyevent KEYCODE_ENTER', shell=True)
            time.sleep(1)
            
            # Try clicking send button coordinates
            subprocess.run('C:\\platform-tools\\adb.exe shell input tap 1200 100', shell=True)
            time.sleep(1)
            
            print("‚úÖ Message sent automatically!")
            speak(f"Message sent successfully to {name}")
        except Exception as e:
            print(f"Auto-send failed: {e}")
            print("The message is ready to send. Please tap the send button on your phone.")
            speak(f"SMS compose screen opened for {name} with your message pre-filled. Please tap the send button to send.")
        
        return True
    
    # Method 2: Alternative SMS intent format with URL encoding
    print("Trying alternative SMS intent format...")
    import urllib.parse
    encoded_message = urllib.parse.quote(message)
    cmd2 = f'C:\\platform-tools\\adb.exe shell am start -a android.intent.action.SENDTO -d "sms:{number}?body={encoded_message}"'
    print(f"Alternative Command: {cmd2}")
    
    result2 = subprocess.run(cmd2, shell=True, capture_output=True, text=True)
    print(f"Alternative Result: {result2.returncode}")
    if result2.stderr:
        print(f"Alternative Error: {result2.stderr}")
    
    if result2.returncode == 0:
        print("‚úÖ SMS compose screen opened with alternative method!")
        print("Attempting to send the message automatically...")
        
        # Wait for compose screen to load
        time.sleep(2)
        
        # Try to send the message automatically
        try:
            # Press Enter to send (common send method)
            subprocess.run('C:\\platform-tools\\adb.exe shell input keyevent KEYCODE_ENTER', shell=True)
            time.sleep(1)
            
            # Try again if first attempt fails
            subprocess.run('C:\\platform-tools\\adb.exe shell input keyevent KEYCODE_ENTER', shell=True)
            time.sleep(1)
            
            # Try clicking send button coordinates
            subprocess.run('C:\\platform-tools\\adb.exe shell input tap 1200 100', shell=True)
            time.sleep(1)
            
            print("‚úÖ Message sent automatically!")
            speak(f"Message sent successfully to {name}")
        except Exception as e:
            print(f"Auto-send failed: {e}")
            print("The message is ready to send. Please tap the send button on your phone.")
            speak(f"SMS compose screen opened for {name} with your message pre-filled. Please tap the send button to send.")
        
        return True
    
    # Method 3: Use specific messaging app with properly escaped message
    print("Trying with specific messaging app...")
    cmd3 = f'C:\\platform-tools\\adb.exe shell am start -n com.google.android.apps.messaging/.ui.conversation.LaunchConversationActivity -a android.intent.action.SENDTO -d sms:{number} --es sms_body "{escaped_message}"'
    print(f"Specific App Command: {cmd3}")
    
    result3 = subprocess.run(cmd3, shell=True, capture_output=True, text=True)
    print(f"Specific App Result: {result3.returncode}")
    if result3.stderr:
        print(f"Specific App Error: {result3.stderr}")
    
    if result3.returncode == 0:
        print("‚úÖ SMS compose screen opened with specific app method!")
        print("Attempting to send the message automatically...")
        
        # Wait for compose screen to load
        time.sleep(2)
        
        # Try to send the message automatically
        try:
            # Press Enter to send (common send method)
            subprocess.run('C:\\platform-tools\\adb.exe shell input keyevent KEYCODE_ENTER', shell=True)
            time.sleep(1)
            
            # Try again if first attempt fails
            subprocess.run('C:\\platform-tools\\adb.exe shell input keyevent KEYCODE_ENTER', shell=True)
            time.sleep(1)
            
            # Try clicking send button coordinates
            subprocess.run('C:\\platform-tools\\adb.exe shell input tap 1200 100', shell=True)
            time.sleep(1)
            
            print("‚úÖ Message sent automatically!")
            speak(f"Message sent successfully to {name}")
        except Exception as e:
            print(f"Auto-send failed: {e}")
            print("The message is ready to send. Please tap the send button on your phone.")
            speak(f"SMS compose screen opened for {name} with your message pre-filled. Please tap the send button to send.")
        
        return True
    
    # Method 4: Fallback - Open messaging app and manually fill
    print("Using fallback method - opening messaging app...")
    subprocess.run('C:\\platform-tools\\adb.exe shell monkey -p com.google.android.apps.messaging 1', shell=True)
    time.sleep(3)
    
    # Start new conversation
    subprocess.run('C:\\platform-tools\\adb.exe shell am start -a android.intent.action.SENDTO -d sms:', shell=True)
    time.sleep(2)
    
    # Fill phone number
    subprocess.run(f'C:\\platform-tools\\adb.exe shell input text "{number}"', shell=True)
    time.sleep(1)
    subprocess.run('C:\\platform-tools\\adb.exe shell input keyevent KEYCODE_ENTER', shell=True)
    time.sleep(2)
    
    # Fill message with proper escaping
    escaped_message_fallback = message.replace('"', '\\"').replace("'", "\\'")
    subprocess.run(f'C:\\platform-tools\\adb.exe shell input text "{escaped_message_fallback}"', shell=True)
    time.sleep(1)
    
    print("‚úÖ SMS compose screen opened with fallback method!")
    print("Attempting to send the message automatically...")
    
    # Try to send the message automatically
    try:
        # Press Enter to send (common send method)
        subprocess.run('C:\\platform-tools\\adb.exe shell input keyevent KEYCODE_ENTER', shell=True)
        time.sleep(1)
        
        # Try again if first attempt fails
        subprocess.run('C:\\platform-tools\\adb.exe shell input keyevent KEYCODE_ENTER', shell=True)
        time.sleep(1)
        
        # Try clicking send button coordinates
        subprocess.run('C:\\platform-tools\\adb.exe shell input tap 1200 100', shell=True)
        time.sleep(1)
        
        print("‚úÖ Message sent automatically!")
        speak(f"Message sent successfully to {name}")
    except Exception as e:
        print(f"Auto-send failed: {e}")
        print("The message is ready to send. Please tap the send button on your phone.")
        speak(f"SMS compose screen opened for {name} with your message. Please tap the send button to send.")
    
    return True

# SMS Test Function - Works with main application (voice-based)
def testSMS():
    """Test SMS functionality using voice commands - works with main app"""
    
    def test_contact(name):
        """Find contact in database"""
        con = sqlite3.connect("jarvis.db")
        cursor = con.cursor()
        
        cursor.execute("SELECT name, mobile_no FROM contacts WHERE LOWER(name) LIKE ?", ('%' + name.lower() + '%',))
        result = cursor.fetchall()
        
        if result:
            print(f"Found: {result[0][0]} - {result[0][1]}")
            return result[0][1]
        else:
            print(f"Contact '{name}' not found")
            return None

    def test_sms(number, message):
        """Test SMS sending with the working method"""
        # Use the improved SMS function
        return sendSMSImproved(number, message, "test contact")

    # Main test function - voice-based for main app
    speak("SMS Test Mode activated. Please say the contact name to test.")
    from engine.command import takecommand
    contact_name = takecommand()
    print(f"Contact name: {contact_name}")
    
    if contact_name:
        number = test_contact(contact_name)
        if number:
            speak("Please say the test message to send.")
            message = takecommand()
            print(f"Test message: {message}")
            
            if message:
                success = test_sms(number, message)
                if success:
                    speak("SMS test completed successfully")
                else:
                    speak("SMS test failed")
            else:
                speak("No message provided for testing")
        else:
            speak("Contact not found. Please add the contact first using simple add.")
    else:
        speak("No contact name provided for testing")

# SMS Test Function - Direct input version (for standalone use)
def testSMSDirect():
    """Test SMS functionality with direct input - for standalone use"""
    
    def test_contact(name):
        """Find contact in database"""
        con = sqlite3.connect("jarvis.db")
        cursor = con.cursor()
        
        cursor.execute("SELECT name, mobile_no FROM contacts WHERE LOWER(name) LIKE ?", ('%' + name.lower() + '%',))
        result = cursor.fetchall()
        
        if result:
            print(f"Found: {result[0][0]} - {result[0][1]}")
            return result[0][1]
        else:
            print(f"Contact '{name}' not found")
            return None

    def test_sms(number, message):
        """Test SMS sending with the working method"""
        # Use the improved SMS function
        return sendSMSImproved(number, message, "test contact")

    # Main test function - exactly like test_sms.py
    name = input("Enter contact name to test: ")
    number = test_contact(name)

    if number:
        message = input("Enter test message: ")
        test_sms(number, message)
    else:
        print("Add contact first using: py simple_add.py")
"""
Feature Manager - Modular system for extending dual_ai functionality
Allows adding new features without modifying the main dual_ai.py file
"""

import os
import importlib
import inspect
from typing import Dict, List, Callable, Any

class FeatureManager:
    def __init__(self):
        self.features = {}
        self.natural_language_mappings = {}
        self.feature_responses = {}
        self.load_all_features()
    
    def load_all_features(self):
        """Load all feature modules from the features directory"""
        features_dir = os.path.join(os.path.dirname(__file__), 'features')
        if not os.path.exists(features_dir):
            os.makedirs(features_dir)
            return
        
        for filename in os.listdir(features_dir):
            if filename.endswith('.py') and not filename.startswith('__'):
                module_name = filename[:-3]
                self.load_feature(module_name)
    
    def load_feature(self, module_name: str):
        """Load a specific feature module"""
        try:
            module = importlib.import_module(f'engine.features.{module_name}')
            
            # Get feature class
            for name, obj in inspect.getmembers(module):
                if inspect.isclass(obj) and hasattr(obj, 'feature_name'):
                    feature_instance = obj()
                    feature_name = feature_instance.feature_name
                    
                    # Register feature methods
                    self.features[feature_name] = feature_instance
                    
                    # Register natural language mappings
                    if hasattr(feature_instance, 'natural_language_mappings'):
                        self.natural_language_mappings.update(feature_instance.natural_language_mappings)
                    
                    # Register responses
                    if hasattr(feature_instance, 'responses'):
                        self.feature_responses.update(feature_instance.responses)
                    
                    print(f"Loaded feature: {feature_name}")
                    break
        except Exception as e:
            print(f"Error loading feature {module_name}: {e}")
    
    def execute_feature(self, command: str, *args, **kwargs):
        """Execute a feature command"""
        # Check natural language mappings first
        mapped_command = self.natural_language_mappings.get(command.lower())
        if mapped_command:
            command = mapped_command
        
        # Find and execute the command
        for feature_name, feature_instance in self.features.items():
            if hasattr(feature_instance, command):
                method = getattr(feature_instance, command)
                try:
                    result = method(*args, **kwargs)
                    return result
                except Exception as e:
                    return f"Error executing {command}: {e}"
        
        return None
    
    def get_response(self, func_name: str) -> str:
        """Get response message for a function"""
        return self.feature_responses.get(func_name, "Feature executed successfully.")
    
    def get_all_commands(self) -> List[str]:
        """Get list of all available commands"""
        commands = []
        for feature_instance in self.features.values():
            for name, method in inspect.getmembers(feature_instance, predicate=inspect.ismethod):
                if not name.startswith('_'):
                    commands.append(name)
        return commands
    
    def get_natural_language_mappings(self) -> Dict[str, str]:
        """Get all natural language mappings"""
        return self.natural_language_mappings

# Global feature manager instance
feature_manager = FeatureManager()
"""
Gemini-Style Advanced Vision AI System
Full interactive AI with vision, conversation, and intelligence
"""

import cv2
import numpy as np
import threading
import time
import json
import random
import base64
import subprocess
from datetime import datetime
from collections import deque
import speech_recognition as sr
import pyttsx3

try:
    import mediapipe as mp
    MEDIAPIPE_AVAILABLE = True
except ImportError:
    MEDIAPIPE_AVAILABLE = False

try:
    from ultralytics import YOLO
    YOLO_AVAILABLE = True
except ImportError:
    YOLO_AVAILABLE = False

try:
    import google.generativeai as genai
    GEMINI_AVAILABLE = True
except ImportError:
    GEMINI_AVAILABLE = False

class GeminiAdvancedVision:
    def __init__(self):
        self.is_active = False
        self.camera = None
        self.conversation_history = deque(maxlen=100)
        self.visual_memory = deque(maxlen=20)
        self.user_profile = {
            'name': 'User',
            'preferences': {},
            'interaction_style': 'friendly',
            'learning_data': {}
        }
        
        # Vision tracking
        self.current_scene = "unknown"
        self.detected_objects = []
        self.face_analysis = {}
        self.gesture_state = None
        self.attention_level = 0
        self.engagement_score = 0
        
        # AI personality
        self.personality = {
            'mode': 'intelligent_assistant',
            'creativity': 0.8,
            'helpfulness': 0.9,
            'curiosity': 0.7,
            'proactiveness': 0.6,
            'empathy': 0.8
        }
        
        # Missing attributes
        self.interaction_quality = 8.5
        self.current_language = 'en-US'
        self.proactive_responses = True
        self.context_awareness = True
        self.long_term_memory = {
            'emotional_baseline': {},
            'interaction_history': []
        }
        
        # Initialize systems
        self._init_vision_system()
        self._init_audio_system()
        self._init_ai_system()
        self._init_yolo_system()
        
        # Phone camera setup
        self.use_phone_camera = False
        self.adb_process = None
    
    def _init_vision_system(self):
        """Initialize advanced vision system"""
        global MEDIAPIPE_AVAILABLE
        if MEDIAPIPE_AVAILABLE:
            try:
                self.mp_face_mesh = mp.solutions.face_mesh
                self.mp_hands = mp.solutions.hands
                self.mp_pose = mp.solutions.pose
                self.mp_selfie_segmentation = mp.solutions.selfie_segmentation
                self.mp_drawing = mp.solutions.drawing_utils
                
                self.face_mesh = self.mp_face_mesh.FaceMesh(
                    max_num_faces=3, refine_landmarks=True,
                    min_detection_confidence=0.5, min_tracking_confidence=0.5
                )
                
                self.hands = self.mp_hands.Hands(
                    static_image_mode=False, max_num_hands=4,
                    min_detection_confidence=0.7, min_tracking_confidence=0.5
                )
                
                self.pose = self.mp_pose.Pose(
                    static_image_mode=False,
                    min_detection_confidence=0.5, min_tracking_confidence=0.5
                )
                
                self.segmentation = self.mp_selfie_segmentation.SelfieSegmentation(model_selection=1)
                
                print("üß† Advanced MediaPipe Vision System Initialized")
            except Exception as e:
                print(f"MediaPipe error: {e}")
                MEDIAPIPE_AVAILABLE = False
        
    def _init_yolo_system(self):
        """Initialize YOLO object detection"""
        global YOLO_AVAILABLE
        if YOLO_AVAILABLE:
            try:
                self.yolo_model = YOLO('yolov8n.pt')
                self.coco_classes = [
                    'person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus', 'train', 'truck', 'boat',
                    'traffic light', 'fire hydrant', 'stop sign', 'parking meter', 'bench', 'bird', 'cat',
                    'dog', 'horse', 'sheep', 'cow', 'elephant', 'bear', 'zebra', 'giraffe', 'backpack',
                    'umbrella', 'handbag', 'tie', 'suitcase', 'frisbee', 'skis', 'snowboard', 'sports ball',
                    'kite', 'baseball bat', 'baseball glove', 'skateboard', 'surfboard', 'tennis racket',
                    'bottle', 'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple',
                    'sandwich', 'orange', 'broccoli', 'carrot', 'hot dog', 'pizza', 'donut', 'cake',
                    'chair', 'couch', 'potted plant', 'bed', 'dining table', 'toilet', 'tv', 'laptop',
                    'mouse', 'remote', 'keyboard', 'cell phone', 'microwave', 'oven', 'toaster', 'sink',
                    'refrigerator', 'book', 'clock', 'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush'
                ]
                
                # Enhanced object mapping for better detection
                self.object_mappings = {
                    'remote': 'remote_control',
                    'mouse': 'computer_mouse', 
                    'toothbrush': 'charger',  # Often misclassified as charger
                    'hair drier': 'charger',  # Often misclassified as charger
                    'scissors': 'tool',
                    'teddy bear': 'toy',
                    'sports ball': 'ball',
                    'wine glass': 'glass',
                    'dining table': 'table',
                    'potted plant': 'plant',
                    'cell phone': 'phone'
                }
                
                # Detection confidence thresholds for different object types
                self.confidence_thresholds = {
                    'person': 0.5,
                    'laptop': 0.4,
                    'cell phone': 0.3,
                    'book': 0.3,
                    'cup': 0.3,
                    'bottle': 0.3,
                    'chair': 0.4,
                    'mouse': 0.25,
                    'keyboard': 0.3,
                    'remote': 0.25,
                    'clock': 0.3,
                    'scissors': 0.2,
                    'toothbrush': 0.2,  # Low threshold for potential chargers
                    'hair drier': 0.2   # Low threshold for potential chargers
                }
                
                print("üéØ YOLOv8 Enhanced Object Detection Initialized")
            except Exception as e:
                print(f"YOLO error: {e}")
                YOLO_AVAILABLE = False
        else:
            print("‚ö†Ô∏è YOLOv8 not available - install ultralytics")
    
    def _init_phone_camera(self):
        """Initialize phone camera - check all available cameras"""
        try:
            print("üì± Scanning for all available cameras...")
            
            best_camera = None
            best_resolution = 0
            
            # Check all possible camera indices
            for cam_id in range(10):  # Check more camera indices
                try:
                    test_camera = cv2.VideoCapture(cam_id)
                    if test_camera.isOpened():
                        ret, frame = test_camera.read()
                        if ret and frame is not None:
                            h, w = frame.shape[:2]
                            resolution = w * h
                            
                            print(f"‚úÖ Camera {cam_id}: {w}x{h} pixels")
                            
                            # Prefer higher resolution cameras (likely phone cameras)
                            if resolution > best_resolution:
                                if best_camera:
                                    best_camera.release()
                                best_camera = test_camera
                                best_resolution = resolution
                                best_cam_id = cam_id
                            else:
                                test_camera.release()
                        else:
                            test_camera.release()
                    else:
                        print(f"‚ùå Camera {cam_id}: Not available")
                except Exception as e:
                    continue
            
            # Use the best camera found
            if best_camera and best_resolution > 640*480:  # Better than basic webcam
                print(f"üì± Using high-resolution camera {best_cam_id}: {best_resolution} pixels")
                self.camera = best_camera
                return True
            elif best_camera:
                print(f"üíª Using standard camera {best_cam_id}")
                self.camera = best_camera
                return True
            
            print("‚ö†Ô∏è No cameras detected")
            return False
                    
        except Exception as e:
            print(f"‚ö†Ô∏è Camera detection failed: {e}")
            return False
    
    def _init_audio_system(self):
        """Initialize advanced audio system"""
        try:
            self.recognizer = sr.Recognizer()
            self.microphone = sr.Microphone()
            self.tts_engine = pyttsx3.init()
            
            # Configure TTS for natural speech
            voices = self.tts_engine.getProperty('voices')
            if voices:
                # Prefer female voice for friendlier interaction
                for voice in voices:
                    if 'female' in voice.name.lower() or 'zira' in voice.name.lower():
                        self.tts_engine.setProperty('voice', voice.id)
                        break
            
            self.tts_engine.setProperty('rate', 165)
            self.tts_engine.setProperty('volume', 0.9)
            
            print("üé§ Advanced Audio System Initialized")
        except Exception as e:
            print(f"Audio error: {e}")
    
    def _init_ai_system(self):
        """Initialize AI conversation system"""
        if GEMINI_AVAILABLE:
            try:
                # Configure Gemini (you'll need to add your API key)
                # genai.configure(api_key="YOUR_API_KEY")
                # self.gemini_model = genai.GenerativeModel('gemini-pro-vision')
                print("ü§ñ Gemini AI System Ready (API key needed)")
            except Exception as e:
                print(f"Gemini error: {e}")
        
        # Fallback conversation system
        self.conversation_patterns = {
            'greetings': [
                "Hello! I can see you clearly. How are you today?",
                "Hi there! I'm analyzing what I see. What would you like to know?",
                "Good to see you! I'm processing your visual context. How can I help?"
            ],
            'vision_questions': [
                "I can see {objects} in your environment. What would you like to know about them?",
                "I notice {scene_description}. Is there something specific you'd like me to analyze?",
                "From what I can see, {observation}. How can I assist you with this?"
            ],
            'emotional_responses': [
                "I can see you're {emotion}. {contextual_response}",
                "Your expression suggests you're {emotion}. {supportive_response}",
                "I notice you seem {emotion}. {helpful_response}"
            ]
        }
    
    def start_gemini_vision(self):
        """Start the advanced Gemini-style vision system"""
        if self.is_active:
            return "ü§ñ Advanced Vision AI already active"
        
        try:
            # Try phone camera via ADB first, then fallback to PC camera
            self.use_phone_camera = self._init_phone_camera()
            
            if not self.use_phone_camera:
                # Fallback to PC camera
                for cam_id in [0, 1, 2]:
                    self.camera = cv2.VideoCapture(cam_id)
                    if self.camera.isOpened():
                        break
                    self.camera.release()
                
                if not self.camera.isOpened():
                    return "‚ùå Cannot access any camera"
                
                # Set high-quality capture
                self.camera.set(cv2.CAP_PROP_FRAME_WIDTH, 1280)
                self.camera.set(cv2.CAP_PROP_FRAME_HEIGHT, 720)
                self.camera.set(cv2.CAP_PROP_FPS, 30)
            
            self.is_active = True
            
            # Start enhanced processing threads for Gemini Live
            threading.Thread(target=self._vision_processing_loop, daemon=True).start()
            threading.Thread(target=self._audio_processing_loop, daemon=True).start()
            threading.Thread(target=self._ai_analysis_loop, daemon=True).start()
            threading.Thread(target=self._proactive_ai_loop, daemon=True).start()
            threading.Thread(target=self._continuous_engagement_monitor, daemon=True).start()
            threading.Thread(target=self._context_awareness_loop, daemon=True).start()
            threading.Thread(target=self._memory_consolidation_loop, daemon=True).start()
            threading.Thread(target=self._real_time_adaptation_loop, daemon=True).start()
            
            greeting = self._generate_startup_greeting()
            self._speak(greeting)
            
            return f"üöÄ {greeting}"
            
        except Exception as e:
            self.is_active = False
            return f"‚ùå Error: {str(e)}"
    
    def _generate_startup_greeting(self):
        """Generate intelligent startup greeting"""
        hour = datetime.now().hour
        
        if 5 <= hour < 12:
            time_greeting = "Good morning"
        elif 12 <= hour < 17:
            time_greeting = "Good afternoon"
        elif 17 <= hour < 21:
            time_greeting = "Good evening"
        else:
            time_greeting = "Hello"
        
        capabilities = []
        if MEDIAPIPE_AVAILABLE:
            capabilities.append("advanced computer vision")
        if GEMINI_AVAILABLE:
            capabilities.append("Gemini AI intelligence")
        capabilities.append("natural conversation")
        
        return f"{time_greeting}! I'm your advanced AI assistant with {', '.join(capabilities)}. I can see, understand, and have intelligent conversations about anything you show me!"
    
    def _vision_processing_loop(self):
        """Advanced vision processing with AI analysis"""
        frame_count = 0
        
        while self.is_active:
            try:
                if self.use_phone_camera:
                    ret, frame = self._get_phone_frame()
                else:
                    ret, frame = self.camera.read()
                    
                if not ret:
                    continue
                
                frame = cv2.flip(frame, 1)
                frame_count += 1
                
                # Process every frame for real-time, analyze deeply every 10th frame
                processed_frame = self._process_frame_advanced(frame, deep_analysis=(frame_count % 10 == 0))
                
                cv2.imshow('Gemini Advanced Vision AI', processed_frame)
                
                key = cv2.waitKey(1) & 0xFF
                if key == ord('q'):
                    break
                elif key == ord('c'):  # Capture and analyze
                    self._capture_and_analyze(frame)
                elif key == ord('m'):  # Change AI mode
                    self._cycle_ai_mode()
                elif key == ord('p'):  # Toggle proactive mode
                    self.personality['proactiveness'] = 1.0 - self.personality['proactiveness']
                    self._speak(f"Proactive mode {'enabled' if self.personality['proactiveness'] > 0.5 else 'disabled'}")
                
            except Exception as e:
                print(f"Vision error: {e}")
                time.sleep(0.1)
        
        self.stop_gemini_vision()
    
    def _process_frame_advanced(self, frame, deep_analysis=False):
        """Advanced frame processing with AI insights"""
        h, w, _ = frame.shape
        
        global MEDIAPIPE_AVAILABLE
        if MEDIAPIPE_AVAILABLE:
            rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            
            # Multi-person face analysis
            face_results = self.face_mesh.process(rgb_frame)
            if face_results.multi_face_landmarks:
                for i, face_landmarks in enumerate(face_results.multi_face_landmarks):
                    # Draw enhanced face mesh
                    self.mp_drawing.draw_landmarks(
                        frame, face_landmarks, self.mp_face_mesh.FACEMESH_CONTOURS,
                        None, self.mp_drawing.DrawingSpec(color=(0, 255, 100), thickness=1, circle_radius=1)
                    )
                    
                    if deep_analysis:
                        self.face_analysis[f'person_{i}'] = self._analyze_face_advanced(face_landmarks, w, h)
            
            # Advanced hand tracking
            hand_results = self.hands.process(rgb_frame)
            if hand_results.multi_hand_landmarks:
                for hand_landmarks in hand_results.multi_hand_landmarks:
                    self.mp_drawing.draw_landmarks(
                        frame, hand_landmarks, self.mp_hands.HAND_CONNECTIONS,
                        self.mp_drawing.DrawingSpec(color=(255, 100, 0), thickness=2, circle_radius=2)
                    )
                    
                    if deep_analysis:
                        self.gesture_state = self._analyze_gesture_advanced(hand_landmarks, w, h)
            
            # Pose analysis
            pose_results = self.pose.process(rgb_frame)
            if pose_results.pose_landmarks:
                self.mp_drawing.draw_landmarks(
                    frame, pose_results.pose_landmarks, self.mp_pose.POSE_CONNECTIONS,
                    self.mp_drawing.DrawingSpec(color=(100, 255, 255), thickness=2, circle_radius=2)
                )
            
            # Scene segmentation for context
            if deep_analysis:
                segmentation_results = self.segmentation.process(rgb_frame)
                self._analyze_scene_context(frame, segmentation_results)
        
        return self._add_ai_overlay(frame)
    
    def _analyze_face_advanced(self, face_landmarks, w, h):
        """Advanced facial analysis with AI insights"""
        try:
            landmarks = np.array([(lm.x * w, lm.y * h) for lm in face_landmarks.landmark])
            
            # Advanced emotion analysis
            emotion_data = self._calculate_emotion_advanced(landmarks)
            
            # Attention and engagement
            attention = self._calculate_attention_level(landmarks, w, h)
            
            # Age and demographic estimation (simplified)
            demographic = self._estimate_demographics(landmarks)
            
            return {
                'emotion': emotion_data,
                'attention': attention,
                'demographic': demographic,
                'engagement': self._calculate_engagement(emotion_data, attention)
            }
        except Exception as e:
            return {'error': str(e)}
    
    def _calculate_emotion_advanced(self, landmarks):
        """Advanced emotion calculation with multiple features"""
        try:
            # Mouth analysis
            mouth_points = [61, 291, 13, 14, 17, 18, 267, 269, 270, 271, 272]
            mouth_landmarks = landmarks[mouth_points]
            mouth_curve = self._calculate_mouth_curvature(mouth_landmarks)
            
            # Eye analysis
            left_eye_points = [33, 7, 163, 144, 145, 153, 154, 155, 133]
            right_eye_points = [362, 382, 381, 380, 374, 373, 390, 249, 263]
            
            left_eye = landmarks[left_eye_points]
            right_eye = landmarks[right_eye_points]
            eye_openness = self._calculate_eye_openness_advanced(left_eye, right_eye)
            
            # Eyebrow analysis
            left_brow = landmarks[[70, 63, 105, 66, 107]]
            right_brow = landmarks[[296, 334, 293, 300, 276]]
            brow_position = self._calculate_brow_position(left_brow, right_brow, left_eye, right_eye)
            
            # Combine features for emotion classification
            emotions = {
                'happy': max(0, mouth_curve * 2 + eye_openness * 0.5),
                'sad': max(0, -mouth_curve * 1.5 + (1 - eye_openness) * 0.3),
                'surprised': max(0, eye_openness * 1.5 + brow_position * 1.2),
                'angry': max(0, -brow_position * 1.5 + (1 - eye_openness) * 0.5),
                'neutral': 1 - max(abs(mouth_curve), abs(brow_position), abs(eye_openness - 0.5))
            }
            
            # Normalize emotions
            total = sum(emotions.values())
            if total > 0:
                emotions = {k: v/total for k, v in emotions.items()}
            
            primary_emotion = max(emotions, key=emotions.get)
            confidence = emotions[primary_emotion]
            
            return {
                'primary': primary_emotion,
                'confidence': confidence,
                'all_emotions': emotions,
                'features': {
                    'mouth_curve': mouth_curve,
                    'eye_openness': eye_openness,
                    'brow_position': brow_position
                }
            }
        except Exception as e:
            return {'primary': 'neutral', 'confidence': 0.5, 'error': str(e)}
    
    def _calculate_mouth_curvature(self, mouth_landmarks):
        """Calculate mouth curvature for smile detection"""
        try:
            left_corner = mouth_landmarks[0]
            right_corner = mouth_landmarks[1]
            center_points = mouth_landmarks[2:5]
            
            corner_avg_y = (left_corner[1] + right_corner[1]) / 2
            center_avg_y = np.mean([p[1] for p in center_points])
            
            width = abs(left_corner[0] - right_corner[0])
            if width > 0:
                curvature = (corner_avg_y - center_avg_y) / width
                return np.clip(curvature, -0.1, 0.1) * 10  # Normalize to -1 to 1
            return 0
        except:
            return 0
    
    def _calculate_eye_openness_advanced(self, left_eye, right_eye):
        """Advanced eye openness calculation"""
        try:
            def eye_aspect_ratio(eye_points):
                # Vertical distances
                v1 = np.linalg.norm(eye_points[1] - eye_points[5])
                v2 = np.linalg.norm(eye_points[2] - eye_points[4])
                # Horizontal distance
                h = np.linalg.norm(eye_points[0] - eye_points[3])
                return (v1 + v2) / (2.0 * h) if h > 0 else 0
            
            left_ear = eye_aspect_ratio(left_eye[:6])
            right_ear = eye_aspect_ratio(right_eye[:6])
            
            avg_ear = (left_ear + right_ear) / 2
            return np.clip(avg_ear * 5, 0, 1)  # Normalize to 0-1
        except:
            return 0.5
    
    def _calculate_brow_position(self, left_brow, right_brow, left_eye, right_eye):
        """Calculate eyebrow position relative to eyes"""
        try:
            left_brow_y = np.mean(left_brow[:, 1])
            right_brow_y = np.mean(right_brow[:, 1])
            left_eye_y = np.mean(left_eye[:, 1])
            right_eye_y = np.mean(right_eye[:, 1])
            
            left_distance = (left_eye_y - left_brow_y) / 50  # Normalize
            right_distance = (right_eye_y - right_brow_y) / 50
            
            return (left_distance + right_distance) / 2
        except:
            return 0
    
    def _calculate_attention_level(self, landmarks, w, h):
        """Calculate attention level based on gaze and pose"""
        try:
            # Eye center calculation
            left_eye_center = np.mean(landmarks[[33, 133]], axis=0)
            right_eye_center = np.mean(landmarks[[362, 263]], axis=0)
            eye_center = (left_eye_center + right_eye_center) / 2
            
            # Distance from frame center
            frame_center = np.array([w/2, h/2])
            distance = np.linalg.norm(eye_center - frame_center)
            max_distance = min(w, h) * 0.3
            
            attention = max(0, 1 - (distance / max_distance))
            return attention
        except:
            return 0.5
    
    def _calculate_engagement(self, emotion_data, attention):
        """Calculate overall engagement score"""
        try:
            emotion_score = emotion_data.get('confidence', 0.5)
            if emotion_data.get('primary') in ['happy', 'surprised']:
                emotion_score *= 1.2
            elif emotion_data.get('primary') in ['sad', 'angry']:
                emotion_score *= 0.8
            
            engagement = (attention * 0.6 + emotion_score * 0.4)
            return np.clip(engagement, 0, 1)
        except:
            return 0.5
    
    def _analyze_gesture_advanced(self, hand_landmarks, w, h):
        """Advanced gesture recognition with context"""
        try:
            landmarks = np.array([(lm.x * w, lm.y * h) for lm in hand_landmarks.landmark])
            
            # Finger positions
            finger_tips = [4, 8, 12, 16, 20]  # Thumb, Index, Middle, Ring, Pinky
            finger_joints = [3, 6, 10, 14, 18]
            
            fingers_up = []
            
            # Thumb (different logic due to orientation)
            if landmarks[4][0] > landmarks[3][0]:  # Right hand
                fingers_up.append(landmarks[4][0] > landmarks[3][0])
            else:  # Left hand
                fingers_up.append(landmarks[4][0] < landmarks[3][0])
            
            # Other fingers
            for i in range(1, 5):
                fingers_up.append(landmarks[finger_tips[i]][1] < landmarks[finger_joints[i]][1])
            
            # Advanced gesture recognition
            gesture_patterns = {
                'thumbs_up': [True, False, False, False, False],
                'peace_sign': [False, True, True, False, False],
                'pointing': [False, True, False, False, False],
                'ok_sign': [True, False, False, False, False],  # Simplified
                'rock_on': [False, True, False, False, True],
                'stop_hand': [True, True, True, True, True],
                'fist': [False, False, False, False, False],
                'three_fingers': [False, True, True, True, False],
                'four_fingers': [False, True, True, True, True]
            }
            
            # Find best matching gesture
            best_match = None
            best_score = 0
            
            for gesture, pattern in gesture_patterns.items():
                score = sum(1 for i, expected in enumerate(pattern) if fingers_up[i] == expected)
                if score > best_score and score >= 4:  # At least 4/5 fingers match
                    best_match = gesture
                    best_score = score
            
            return {
                'gesture': best_match,
                'confidence': best_score / 5 if best_match else 0,
                'fingers_up': fingers_up,
                'hand_position': self._get_hand_position(landmarks, w, h)
            }
        except Exception as e:
            return {'gesture': None, 'error': str(e)}
    
    def _get_hand_position(self, landmarks, w, h):
        """Get hand position in frame"""
        try:
            center = np.mean(landmarks, axis=0)
            x_pos = "left" if center[0] < w/3 else "right" if center[0] > 2*w/3 else "center"
            y_pos = "top" if center[1] < h/3 else "bottom" if center[1] > 2*h/3 else "middle"
            return f"{y_pos}_{x_pos}"
        except:
            return "unknown"
    
    def _analyze_scene_context(self, frame, segmentation_results):
        """Analyze scene context with YOLO object detection"""
        try:
            global YOLO_AVAILABLE
            if YOLO_AVAILABLE and hasattr(self, 'yolo_model'):
                # YOLO detection with adaptive thresholds
                results = self.yolo_model(frame, conf=0.2, iou=0.4, verbose=False, max_det=25)
                objects_detected = []
                
                for result in results:
                    boxes = result.boxes
                    if boxes is not None:
                        for box in boxes:
                            confidence = float(box.conf[0])
                            class_id = int(box.cls[0])
                            if class_id < len(self.coco_classes):
                                obj_name = self.coco_classes[class_id]
                                
                                # Use adaptive confidence threshold
                                min_confidence = self.confidence_thresholds.get(obj_name, 0.3)
                                
                                if confidence >= min_confidence:
                                    # Apply object mapping
                                    if obj_name in self.object_mappings:
                                        mapped_name = self.object_mappings[obj_name]
                                        if mapped_name == 'charger' and confidence > 0.2:
                                            obj_name = 'charger'
                                        else:
                                            obj_name = mapped_name
                                    
                                    objects_detected.append(obj_name)
                                    
                                    # Draw bounding box with adaptive colors
                                    x1, y1, x2, y2 = map(int, box.xyxy[0])
                                    if confidence > 0.7:
                                        color = (0, 255, 0)  # Green for high confidence
                                    elif confidence > 0.5:
                                        color = (0, 200, 255)  # Yellow for medium confidence
                                    elif confidence > 0.3:
                                        color = (255, 150, 0)  # Orange for low-medium confidence
                                    else:
                                        color = (255, 100, 100)  # Light red for low confidence
                                    
                                    cv2.rectangle(frame, (x1, y1), (x2, y2), color, 2)
                                    cv2.putText(frame, f"{obj_name} {confidence:.0%}", 
                                              (x1, y1-10), cv2.FONT_HERSHEY_SIMPLEX, 0.4, color, 1)
                
                # Update detected objects with counts and filtering
                object_counts = {}
                for obj in objects_detected:
                    # Clean object names
                    clean_obj = obj.replace('_', ' ')
                    object_counts[clean_obj] = object_counts.get(clean_obj, 0) + 1
                
                # Create final object list with counts
                final_objects = []
                for obj, count in object_counts.items():
                    if count > 1:
                        final_objects.append(f"{obj}({count})")
                    else:
                        final_objects.append(obj)
                
                self.detected_objects = final_objects[:12]  # Show more objects
                
                # Reduce detection noise - only print significant changes
                current_unique = set([obj.split('(')[0] for obj in objects_detected])
                last_unique = set(getattr(self, '_last_unique_objects', []))
                
                if len(current_unique - last_unique) > 0 or len(last_unique - current_unique) > 0:
                    if len(current_unique) > 0:
                        print(f"üéØ Objects detected: {', '.join(list(current_unique)[:6])}")
                    self._last_unique_objects = list(current_unique)
            else:
                # Enhanced fallback detection
                self._enhanced_basic_detection(frame)
            
            # Scene classification
            self._classify_scene()
                
        except Exception as e:
            print(f"Detection error: {e}")
            self.detected_objects = []
            self.current_scene = "general_room"
    
    def _enhanced_basic_detection(self, frame):
        """Enhanced basic object detection fallback with charger detection"""
        h, w, _ = frame.shape
        objects_detected = []
        
        # Multi-method detection
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
        
        # Edge detection for rectangular objects
        edges = cv2.Canny(gray, 20, 80)  # Lower thresholds for better small object detection
        contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        
        for contour in contours:
            area = cv2.contourArea(contour)
            if area > 800:  # Lower area threshold
                x, y, rect_w, rect_h = cv2.boundingRect(contour)
                aspect_ratio = rect_w / rect_h
                
                # Draw detection boxes
                cv2.rectangle(frame, (x, y), (x+rect_w, y+rect_h), (255, 0, 0), 1)
                
                # Classify by size and aspect ratio - including small objects
                if 1.3 < aspect_ratio < 2.2 and area > 8000:
                    objects_detected.append('laptop')
                    cv2.putText(frame, 'laptop', (x, y-5), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (255, 0, 0), 1)
                elif 0.7 < aspect_ratio < 1.3 and 3000 < area < 15000:
                    objects_detected.append('book')
                    cv2.putText(frame, 'book', (x, y-5), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (255, 0, 0), 1)
                elif aspect_ratio > 2.5 and y > h * 0.6:
                    objects_detected.append('keyboard')
                    cv2.putText(frame, 'keyboard', (x, y-5), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (255, 0, 0), 1)
                elif 0.4 < aspect_ratio < 0.9 and 1000 < area < 6000:
                    objects_detected.append('phone')
                    cv2.putText(frame, 'phone', (x, y-5), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (255, 0, 0), 1)
                # NEW: Small rectangular objects (chargers, cables)
                elif 0.3 < aspect_ratio < 4.0 and 800 < area < 3000:
                    objects_detected.append('charger')
                    cv2.putText(frame, 'charger', (x, y-5), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0, 255, 255), 1)
                # Long thin objects (cables)
                elif aspect_ratio > 4.0 and 500 < area < 2000:
                    objects_detected.append('cable')
                    cv2.putText(frame, 'cable', (x, y-5), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (255, 255, 0), 1)
        
        # Color-based detection for common objects
        # White/light objects (chargers often white)
        white_mask = cv2.inRange(hsv, (0, 0, 200), (180, 30, 255))
        white_contours, _ = cv2.findContours(white_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        for contour in white_contours:
            area = cv2.contourArea(contour)
            if 500 < area < 3000:
                x, y, w_rect, h_rect = cv2.boundingRect(contour)
                aspect_ratio = w_rect / h_rect
                if 0.5 < aspect_ratio < 2.0:
                    objects_detected.append('white_charger')
                    cv2.rectangle(frame, (x, y), (x+w_rect, y+h_rect), (255, 255, 255), 1)
                    cv2.putText(frame, 'charger', (x, y-5), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (255, 255, 255), 1)
        
        # Black objects (many chargers are black)
        black_mask = cv2.inRange(hsv, (0, 0, 0), (180, 255, 50))
        black_contours, _ = cv2.findContours(black_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        for contour in black_contours:
            area = cv2.contourArea(contour)
            if 400 < area < 2500:
                x, y, w_rect, h_rect = cv2.boundingRect(contour)
                aspect_ratio = w_rect / h_rect
                if 0.4 < aspect_ratio < 2.5:
                    objects_detected.append('black_charger')
                    cv2.rectangle(frame, (x, y), (x+w_rect, y+h_rect), (0, 0, 0), 1)
                    cv2.putText(frame, 'charger', (x, y-5), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (128, 128, 128), 1)
        
        # Green objects (plants)
        green_mask = cv2.inRange(hsv, (35, 50, 50), (85, 255, 255))
        green_contours, _ = cv2.findContours(green_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        for contour in green_contours:
            if cv2.contourArea(contour) > 2000:
                objects_detected.append('plant')
        
        # Circular objects (cups, bottles)
        circles = cv2.HoughCircles(gray, cv2.HOUGH_GRADIENT, 1, 30, param1=40, param2=25, minRadius=10, maxRadius=100)
        if circles is not None:
            for circle in circles[0, :]:
                objects_detected.append('cup')
        
        # Clean up and organize detected objects
        cleaned_objects = []
        charger_found = False
        
        for obj in objects_detected:
            if 'charger' in obj.lower():
                if not charger_found:
                    cleaned_objects.append('charger')
                    charger_found = True
            else:
                cleaned_objects.append(obj)
        
        # Remove duplicates while preserving order
        seen = set()
        unique_objects = []
        for obj in cleaned_objects:
            if obj not in seen:
                seen.add(obj)
                unique_objects.append(obj)
        
        self.detected_objects = unique_objects[:12]  # Show more objects
    
    def _classify_scene(self):
        """Classify scene based on detected objects"""
        obj_str = ' '.join(self.detected_objects).lower()
        
        if any(word in obj_str for word in ['laptop', 'keyboard', 'mouse', 'computer']):
            self.current_scene = "computer_workspace"
        elif any(word in obj_str for word in ['book', 'paper']):
            self.current_scene = "study_area"
        elif any(word in obj_str for word in ['cup', 'bottle', 'plant']):
            self.current_scene = "living_space"
        elif any(word in obj_str for word in ['chair', 'table', 'couch']):
            self.current_scene = "furniture_area"
        elif len(self.detected_objects) >= 3:
            self.current_scene = "busy_workspace"
        else:
            self.current_scene = "general_room"
    
    def _add_ai_overlay(self, frame):
        """Add advanced AI overlay with insights"""
        h, w, _ = frame.shape
        
        # Main AI panel
        panel_height = 200
        cv2.rectangle(frame, (10, 10), (450, panel_height), (20, 20, 20), -1)
        cv2.rectangle(frame, (10, 10), (450, panel_height), (0, 255, 150), 2)
        
        # Title with AI indicator
        cv2.putText(frame, "GEMINI ADVANCED VISION AI", (20, 35), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 255), 2)
        
        # AI Status
        ai_status = "üß† ANALYZING" if len(self.face_analysis) > 0 else "üëÅÔ∏è OBSERVING"
        cv2.putText(frame, ai_status, (20, 60), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.5, (100, 255, 100), 1)
        
        # Scene analysis
        cv2.putText(frame, f"Scene: {self.current_scene.replace('_', ' ').title()}", (20, 85), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 200, 0), 1)
        
        # Objects detected
        if self.detected_objects:
            objects_text = f"Objects: {', '.join(self.detected_objects[:3])}"
            cv2.putText(frame, objects_text, (20, 110), 
                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 150, 0), 1)
        
        # Face analysis results
        if self.face_analysis:
            person_data = list(self.face_analysis.values())[0]
            if 'emotion' in person_data:
                emotion_info = person_data['emotion']
                emotion_text = f"Emotion: {emotion_info['primary'].title()} ({emotion_info['confidence']:.1%})"
                cv2.putText(frame, emotion_text, (20, 135), 
                           cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 100, 255), 1)
                
                attention_text = f"Attention: {person_data.get('attention', 0):.1%}"
                cv2.putText(frame, attention_text, (20, 160), 
                           cv2.FONT_HERSHEY_SIMPLEX, 0.5, (100, 255, 255), 1)
        
        # Gesture info
        if self.gesture_state and self.gesture_state.get('gesture'):
            gesture_text = f"Gesture: {self.gesture_state['gesture'].replace('_', ' ').title()}"
            cv2.putText(frame, gesture_text, (20, 185), 
                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 0, 150), 1)
        
        # AI Controls panel
        controls_y = h - 100
        cv2.rectangle(frame, (10, controls_y), (400, h-10), (30, 30, 30), -1)
        cv2.rectangle(frame, (10, controls_y), (400, h-10), (100, 100, 100), 1)
        
        cv2.putText(frame, "AI Controls: Q=Quit | C=Capture&Analyze | M=AI Mode | P=Proactive", 
                   (15, controls_y + 25), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (255, 255, 255), 1)
        
        mode_text = f"Mode: {self.personality['mode'].replace('_', ' ').title()}"
        cv2.putText(frame, mode_text, (15, controls_y + 50), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.4, (200, 200, 200), 1)
        
        proactive_status = "ON" if self.personality['proactiveness'] > 0.5 else "OFF"
        cv2.putText(frame, f"Proactive: {proactive_status} | Creativity: {self.personality['creativity']:.1f}", 
                   (15, controls_y + 75), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (150, 200, 255), 1)
        
        # Time and status
        current_time = datetime.now().strftime("%H:%M:%S")
        cv2.putText(frame, current_time, (w-120, 30), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)
        
        return frame
    
    def _audio_processing_loop(self):
        """Advanced audio processing with AI conversation"""
        try:
            with self.microphone as source:
                self.recognizer.adjust_for_ambient_noise(source, duration=0.5)
                print("üé§ Listening for voice commands...")
        except Exception as e:
            print(f"Audio setup error: {e}")
            return
        
        while self.is_active:
            try:
                with self.microphone as source:
                    audio = self.recognizer.listen(source, timeout=2, phrase_time_limit=8)
                
                try:
                    text = self.recognizer.recognize_google(audio, language='en-US')
                    if text and len(text.strip()) > 1:
                        print(f"üé§ Heard: {text}")
                        self._process_ai_conversation(text)
                except sr.UnknownValueError:
                    pass
                except sr.RequestError as e:
                    print(f"Speech recognition error: {e}")
                    
            except sr.WaitTimeoutError:
                pass
            except Exception as e:
                time.sleep(1)
    
    def _process_ai_conversation(self, user_input):
        """Process conversation with advanced AI responses"""
        timestamp = datetime.now()
        
        # Add to conversation history
        conversation_entry = {
            'timestamp': timestamp.isoformat(),
            'user_input': user_input,
            'visual_context': {
                'scene': self.current_scene,
                'objects': self.detected_objects.copy(),
                'face_analysis': self.face_analysis.copy(),
                'gesture': self.gesture_state
            }
        }
        
        # Generate AI response
        ai_response = self._generate_ai_response(user_input, conversation_entry['visual_context'])
        
        conversation_entry['ai_response'] = ai_response
        self.conversation_history.append(conversation_entry)
        
        # Speak response
        self._speak(ai_response)
        
        # Log conversation
        print(f"\n[{timestamp.strftime('%H:%M:%S')}] User: {user_input}")
        print(f"[{timestamp.strftime('%H:%M:%S')}] AI: {ai_response}")
    
    def _generate_ai_response(self, user_input, visual_context):
        """Generate comprehensive AI responses using video and audio"""
        user_lower = user_input.lower()
        objects = visual_context.get('objects', [])
        scene = visual_context.get('scene', 'general_room')
        face_data = visual_context.get('face_analysis', {})
        gesture_data = visual_context.get('gesture')
        
        # Get emotion and attention for context
        emotion = 'neutral'
        attention = 0.5
        if face_data:
            person_data = list(face_data.values())[0]
            emotion = person_data.get('emotion', {}).get('primary', 'neutral')
            attention = person_data.get('attention', 0.5)
        
        # VISUAL ANALYSIS QUESTIONS
        if any(phrase in user_lower for phrase in ['what do you see', 'what is this', 'identify', 'what objects', 'describe', 'analyze']):
            response = self._generate_detailed_visual_response(objects, scene, emotion, attention, gesture_data)
            return response
        
        # SPECIFIC OBJECT QUESTIONS - Enhanced for ALL objects
        elif self._contains_object_query(user_lower):
            return self._handle_specific_object_query(user_input, objects, scene)
        
        # MATH & CALCULATIONS with visual context
        elif any(word in user_lower for word in ['calculate', 'math', 'plus', 'minus', 'multiply', 'divide', 'solve', 'count']):
            return self._handle_math_with_vision(user_input, objects, visual_context)
        
        # KNOWLEDGE QUESTIONS with visual enhancement
        elif any(phrase in user_lower for phrase in ['what is', 'who is', 'tell me about', 'explain', 'how does', 'why']):
            return self._handle_knowledge_with_vision(user_input, objects, visual_context)
        
        # PROBLEM SOLVING with visual context
        elif any(word in user_lower for word in ['problem', 'issue', 'broken', 'not working', 'fix', 'help', 'trouble']):
            return self._handle_problem_solving_with_vision(user_input, objects, scene, emotion)
        
        # CREATIVE TASKS with visual inspiration
        elif any(word in user_lower for word in ['story', 'poem', 'creative', 'imagine', 'write']):
            return self._handle_creative_with_vision(user_input, objects, scene, emotion)
        
        # EMOTIONAL SUPPORT based on visual cues
        elif emotion in ['sad', 'angry', 'frustrated'] or any(word in user_lower for word in ['sad', 'upset', 'angry', 'frustrated']):
            return self._handle_emotional_support(emotion, attention, objects)
        
        # GENERAL CONVERSATION with full context
        else:
            return self._handle_general_conversation(user_input, objects, scene, emotion, attention, gesture_data)
    
    def _generate_detailed_visual_response(self, objects, scene, emotion, attention, gesture_data):
        """Generate detailed visual analysis response"""
        response_parts = []
        
        # Scene description
        response_parts.append(f"I can see you're in a {scene.replace('_', ' ')}")
        
        # Object analysis
        if objects:
            if len(objects) == 1:
                response_parts.append(f"I detect a {objects[0]}")
            elif len(objects) <= 3:
                response_parts.append(f"I can identify {', '.join(objects[:-1])} and a {objects[-1]}")
            else:
                response_parts.append(f"I see multiple objects including {', '.join(objects[:3])} and {len(objects)-3} more items")
        else:
            response_parts.append("I'm analyzing the objects in your environment")
        
        # Emotional state
        if emotion != 'neutral':
            response_parts.append(f"You appear {emotion}")
        
        # Attention level
        if attention > 0.8:
            response_parts.append("You seem very focused")
        elif attention < 0.3:
            response_parts.append("You seem a bit distracted")
        
        # Gesture recognition
        if gesture_data and gesture_data.get('gesture'):
            gesture = gesture_data['gesture'].replace('_', ' ')
            response_parts.append(f"I notice you're making a {gesture} gesture")
        
        return ". ".join(response_parts) + ". What would you like to know more about?"
    
    def _contains_object_query(self, user_input):
        """Check if user is asking about specific objects"""
        object_keywords = [
            'laptop', 'computer', 'phone', 'book', 'cup', 'bottle', 'charger', 'cable', 'mouse', 'keyboard',
            'chair', 'table', 'plant', 'clock', 'remote', 'tv', 'screen', 'bag', 'pen', 'paper',
            'glass', 'plate', 'bowl', 'spoon', 'fork', 'knife', 'camera', 'headphones', 'speaker'
        ]
        return any(obj in user_input for obj in object_keywords)
    
    def _handle_specific_object_query(self, user_input, objects, scene):
        """Handle questions about specific objects"""
        user_lower = user_input.lower()
        
        # Find which object they're asking about
        mentioned_objects = []
        for obj in objects:
            obj_clean = obj.split('(')[0].lower()
            if obj_clean in user_lower or any(word in user_lower for word in obj_clean.split('_')):
                mentioned_objects.append(obj_clean)
        
        if mentioned_objects:
            obj = mentioned_objects[0]
            return f"Yes, I can clearly see the {obj} in your {scene.replace('_', ' ')}! It's well-positioned and clearly visible. What would you like to know about it? I can describe its location, suggest uses, or answer any questions about it."
        else:
            # Check what they're asking about
            for word in ['laptop', 'computer', 'phone', 'charger', 'book', 'cup', 'bottle']:
                if word in user_lower:
                    return f"I don't currently see a {word} clearly in the frame. Try positioning it more centrally or with better lighting. I'm continuously scanning and will detect it once it's visible."
            
            return "I'm analyzing all objects in view. Could you point to or move the item you're asking about? This will help me identify it more accurately."
    
    def _handle_math_with_vision(self, query, objects, visual_context):
        """Handle math with enhanced visual context"""
        import re
        numbers = re.findall(r'\d+\.?\d*', query)
        
        # Count objects if requested
        if 'count' in query.lower() or 'how many' in query.lower():
            if objects:
                return f"I can count {len(objects)} distinct objects: {', '.join(objects[:5])}{'...' if len(objects) > 5 else ''}. The total count is {len(objects)} items."
            else:
                return "I don't see any distinct objects to count right now. Try showing me some items clearly."
        
        # Regular math operations
        if 'plus' in query.lower() or 'add' in query.lower():
            if len(numbers) >= 2:
                result = float(numbers[0]) + float(numbers[1])
                context = f" Looking at your {visual_context.get('scene', 'workspace').replace('_', ' ')}, " if visual_context.get('scene') else " "
                return f"The answer is {result}.{context}I calculated {numbers[0]} + {numbers[1]} = {result}!"
        elif 'minus' in query.lower() or 'subtract' in query.lower():
            if len(numbers) >= 2:
                result = float(numbers[0]) - float(numbers[1])
                return f"The answer is {result}. I calculated {numbers[0]} - {numbers[1]} = {result}!"
        elif 'multiply' in query.lower() or 'times' in query.lower():
            if len(numbers) >= 2:
                result = float(numbers[0]) * float(numbers[1])
                return f"The answer is {result}. I calculated {numbers[0]} √ó {numbers[1]} = {result}!"
        elif 'divide' in query.lower():
            if len(numbers) >= 2 and float(numbers[1]) != 0:
                result = float(numbers[0]) / float(numbers[1])
                return f"The answer is {result}. I calculated {numbers[0]} √∑ {numbers[1]} = {result}!"
        else:
            return "I can solve math problems and count objects! Ask me to add, subtract, multiply, divide numbers, or count items in view."
    
    def _handle_science_with_vision(self, query, visual_desc):
        """Handle science with visual context"""
        context = f"Looking at your environment with {visual_desc}, " if visual_desc else ""
        
        if 'gravity' in query.lower():
            return f"{context}gravity is the force keeping you grounded right now! It attracts all objects with mass. On Earth, it's 9.81 m/s¬≤. It's why things fall and planets orbit!"
        elif 'atom' in query.lower():
            return f"{context}everything around you is made of atoms! They have a nucleus with protons and neutrons, surrounded by electrons. Incredibly tiny but make up everything!"
        elif 'light' in query.lower():
            return f"{context}light travels at 299,792,458 m/s - the fastest speed possible! The light illuminating your space is made of photons that behave as waves and particles!"
        else:
            return f"{context}I love science questions! I can explain physics, chemistry, biology, space, and more. What scientific concept interests you?"
    
    def _handle_programming_with_vision(self, query, visual_desc):
        """Handle programming with visual context"""
        context = f"I can see your workspace with {visual_desc} - perfect for coding! " if visual_desc else ""
        
        if 'python' in query.lower():
            return f'{context}Python is amazing! Example: print("Hello!") displays text. It\'s great for beginners with clean syntax. What Python concept interests you?'
        elif 'javascript' in query.lower():
            return f"{context}JavaScript powers the web! Example: console.log('Hello!') prints to console. Essential for interactive websites!"
        elif 'html' in query.lower():
            return f"{context}HTML structures web pages! Example: <h1>Title</h1> creates headings. It's the foundation of all websites!"
        else:
            return f"{context}I can help with programming! Python, JavaScript, HTML, CSS, algorithms - what coding challenge are you working on?"
    
    def _handle_knowledge_with_vision(self, query, objects, visual_context):
        """Handle knowledge questions with visual enhancement"""
        query_lower = query.lower()
        scene_context = f"Looking at your {visual_context.get('scene', 'environment').replace('_', ' ')}, " if visual_context.get('scene') else ""
        
        # Technology questions
        if any(word in query_lower for word in ['laptop', 'computer', 'technology']):
            if 'laptop' in objects or 'computer' in objects:
                return f"{scene_context}I can see your computer setup! Modern laptops use processors, RAM, and storage to run programs. They're incredible machines that can handle everything from simple tasks to complex AI processing like what I'm doing right now!"
            else:
                return "Computers are amazing machines! They use binary code (0s and 1s) to process information incredibly fast. What specific aspect of technology interests you?"
        
        # Science questions
        elif any(word in query_lower for word in ['science', 'physics', 'chemistry', 'biology']):
            return f"{scene_context}science is all around us! From the light illuminating your space to the chemical reactions in batteries powering your devices. What scientific concept would you like me to explain?"
        
        # Geography questions
        elif 'capital' in query_lower:
            if 'france' in query_lower:
                return f"{scene_context}the capital of France is Paris! Famous for the Eiffel Tower, Louvre Museum, and incredible culture. It's a city of art, fashion, and history."
            elif 'japan' in query_lower:
                return f"{scene_context}the capital of Japan is Tokyo! One of the world's largest cities, known for cutting-edge technology and rich cultural traditions."
            else:
                return "I can tell you about capitals of any country! Which country's capital are you curious about?"
        
        # History questions
        elif any(word in query_lower for word in ['history', 'historical', 'ancient']):
            return f"{scene_context}history is fascinating! From ancient civilizations to modern innovations. What historical period or event interests you?"
        
        # Movies/Entertainment
        elif 'bahubali' in query_lower:
            return f"{scene_context}Bahubali is an epic Indian film series by S.S. Rajamouli! It's about a warrior prince with incredible action sequences and groundbreaking visual effects. The films were massive blockbusters!"
        
        # General knowledge
        else:
            return f"{scene_context}I can answer questions about science, technology, history, geography, culture, and much more! What topic interests you most?"
    
    def _handle_creative_with_vision(self, query, objects, scene, emotion):
        """Handle creative tasks with visual inspiration"""
        visual_elements = []
        if objects:
            visual_elements.extend(objects[:3])
        if scene != 'general_room':
            visual_elements.append(scene.replace('_', ' '))
        
        inspiration = f"Drawing inspiration from {', '.join(visual_elements)}, " if visual_elements else ""
        
        if 'story' in query.lower():
            if 'laptop' in objects:
                return f"{inspiration}here's a story: Sarah sat at her laptop, the screen glowing softly in the quiet room. As she typed, an AI companion watched through the camera, ready to help with any challenge that arose. Together, they solved problems that seemed impossible just moments before."
            else:
                return f"{inspiration}here's a story: In a world where technology could truly see and understand, every conversation became an adventure of discovery and learning."
        
        elif 'poem' in query.lower():
            if emotion == 'happy':
                return f"{inspiration}a joyful poem:\nIn this moment, bright and clear,\nWith {', '.join(objects[:2]) if objects else 'wonder'} drawing near,\nHappiness fills every space,\nAs we share this time and place."
            else:
                return f"{inspiration}a thoughtful poem:\nIn your space where questions grow,\nAI eyes help knowledge flow,\nTogether we explore and find,\nThe wonders of the curious mind."
        
        elif 'imagine' in query.lower():
            return f"{inspiration}let's imagine together! What if your {objects[0] if objects else 'environment'} could tell stories of all the moments it has witnessed? What creative scenario would you like to explore?"
        
        else:
            return f"{inspiration}I love creative challenges! I can write stories, poems, help brainstorm ideas, or create imaginative scenarios. What creative project sparks your interest?"
    
    def _handle_problem_solving_with_vision(self, query, objects, scene, emotion):
        """Handle problem solving with visual context"""
        query_lower = query.lower()
        context = f"I can see your {scene.replace('_', ' ')} with {', '.join(objects[:2]) if objects else 'your setup'}. "
        
        # Device-specific problems based on what's visible
        if 'phone' in query_lower and 'cell phone' in objects:
            return f"{context}I can see your phone! For phone issues: 1) Force restart (hold power 10-15 seconds), 2) Check charging cable/port, 3) Try different charger, 4) Look for physical damage, 5) Boot in safe mode. What exactly is the phone doing?"
        
        elif 'laptop' in query_lower and 'laptop' in objects:
            return f"{context}I can see your laptop! For laptop problems: 1) Check power adapter connection, 2) Try hard reset (hold power 30 seconds), 3) Remove battery if possible, 4) Check for overheating, 5) Boot from external drive. What symptoms are you seeing?"
        
        elif 'computer' in query_lower:
            return f"{context}For computer issues: 1) Verify all power connections, 2) Check monitor cable, 3) Listen for startup beeps, 4) Try different power outlet, 5) Reseat RAM if comfortable. What happens when you press power?"
        
        # Charging problems
        elif 'charger' in query_lower or ('charging' in query_lower and 'charger' in objects):
            return f"{context}I can see a charger! For charging issues: 1) Try different outlet, 2) Check cable for damage, 3) Clean charging port, 4) Test with different cable, 5) Check if adapter is warm (should be). Is the charging light showing?"
        
        # Study/work problems based on environment
        elif 'study' in query_lower and scene == 'study_area':
            return f"{context}Perfect study environment! For better learning: 1) Use active recall techniques, 2) Take breaks every 25-30 minutes, 3) Eliminate distractions, 4) Practice spaced repetition, 5) Teach concepts aloud. What subject are you struggling with?"
        
        # Focus issues with emotional context
        elif 'focus' in query_lower or 'concentration' in query_lower:
            emotional_advice = ""
            if emotion == 'stressed':
                emotional_advice = " You seem stressed - try deep breathing first. "
            elif emotion == 'tired':
                emotional_advice = " You look tired - consider a short break. "
            
            return f"{context}{emotional_advice}For better focus: 1) Remove phone notifications, 2) Use Pomodoro technique, 3) Organize workspace, 4) Stay hydrated, 5) Try background music. What's distracting you most?"
        
        # General problem solving
        else:
            return f"{context}I'm here to help solve any challenge! Based on what I can see and your emotional state, let's work through this systematically. What specific problem are you facing?"
    
    def _handle_emotional_support(self, emotion, attention, objects):
        """Provide emotional support based on visual cues"""
        context = f"I can see you have {', '.join(objects[:2]) if objects else 'your environment'} around you. "
        
        if emotion == 'sad':
            return f"{context}I notice you seem sad. It's okay to feel this way sometimes. Would you like to talk about what's bothering you, or would you prefer a distraction? I'm here to listen and help however I can."
        elif emotion == 'angry' or emotion == 'frustrated':
            return f"{context}I can see you're feeling frustrated. Take a deep breath - let's work through whatever is causing this stress. What's the main issue you're dealing with right now?"
        elif emotion == 'stressed':
            return f"{context}You seem stressed. Sometimes it helps to step back and organize thoughts. Would you like to talk through what's overwhelming you, or try some quick relaxation techniques?"
        else:
            return f"{context}I'm here to support you through any challenges. What's on your mind today?"
    
    def _handle_general_conversation(self, user_input, objects, scene, emotion, attention, gesture_data):
        """Handle general conversation with full context"""
        context_parts = []
        
        # Build rich context
        if objects:
            context_parts.append(f"I can see {', '.join(objects[:3])}")
        
        if scene != 'general_room':
            context_parts.append(f"you're in a {scene.replace('_', ' ')}")
        
        if emotion != 'neutral':
            context_parts.append(f"you appear {emotion}")
        
        if gesture_data and gesture_data.get('gesture'):
            gesture = gesture_data['gesture'].replace('_', ' ')
            context_parts.append(f"you're making a {gesture} gesture")
        
        context = ". ".join(context_parts) if context_parts else "I can see you clearly"
        
        # Greetings
        if any(greeting in user_input.lower() for greeting in ['hello', 'hi', 'hey']):
            return f"Hello! {context.capitalize()}. I'm your AI assistant with advanced vision and conversation abilities. How can I help you today?"
        
        # Gratitude
        elif 'thank you' in user_input.lower():
            return f"You're very welcome! {context.capitalize()}. I'm always happy to help with any questions or tasks!"
        
        # Capabilities
        elif any(phrase in user_input.lower() for phrase in ['what can you do', 'capabilities', 'help me']):
            return f"I can see and understand your environment - {context}. I can help with: üßÆ Math & counting, üî¨ Science & knowledge, üíª Tech support, üé® Creative tasks, üß† Problem solving, üí¨ Natural conversation. What interests you?"
        
        # Default response with context
        else:
            return f"I understand what you're saying. {context.capitalize()}. I'm here to help with any questions, problems, or just have a conversation. What would you like to explore?"
    
    def _handle_visual_analysis_advanced(self, query, visual_context):
        """Advanced visual analysis like Gemini"""
        if 'what do you see' in query.lower():
            scene = visual_context['scene'].replace('_', ' ')
            objects = visual_context.get('objects', [])
            faces = len(visual_context.get('face_analysis', {}))
            
            analysis = f"I can see you're in a {scene}"
            if faces > 0:
                analysis += f" with {faces} person{'s' if faces > 1 else ''}"
            if objects:
                analysis += f". I notice {', '.join(objects[:3])}"
            analysis += ". The lighting is good for detailed analysis. What would you like me to focus on?"
            return analysis
        
        elif 'how do i look' in query.lower():
            if visual_context.get('face_analysis'):
                person_data = list(visual_context['face_analysis'].values())[0]
                emotion = person_data.get('emotion', {}).get('primary', 'neutral')
                confidence = person_data.get('emotion', {}).get('confidence', 0)
                return f"You look {emotion} with {confidence:.0%} confidence! You appear engaged and your expression looks great!"
            else:
                return "I can see you clearly! Look directly at the camera for detailed analysis of your expression."
        
        else:
            return "I'm continuously analyzing what I see. The visual processing is working well and I can provide detailed insights about anything in view!"
    
    def _handle_conversation_with_vision(self, query, visual_desc):
        """Handle conversation with visual context"""
        if any(greeting in query.lower() for greeting in ['hello', 'hi', 'hey']):
            return f"Hello! I can see {visual_desc} and I'm ready to help with anything - math, science, programming, creative tasks, or just chat. What's on your mind?"
        elif 'thank you' in query.lower():
            return f"You're very welcome! I can see {visual_desc} and I'm always happy to help with any question or challenge!"
        elif 'how are you' in query.lower():
            return f"I'm excellent! I can see {visual_desc} and all my systems are working perfectly. I'm ready for any question or task!"
        elif 'capabilities' in query.lower() or 'what can you do' in query.lower():
            return f"I'm like Gemini with vision! I can: üßÆ Solve math, üî¨ Explain science, üíª Help with programming, üåç Answer knowledge questions, üé® Create stories/poems, üîß Solve problems, üëÅÔ∏è Analyze what I see ({visual_desc}). What interests you?"
        else:
            return f"I can see {visual_desc} and I understand what you're saying. As your AI assistant with vision, I can help with any topic. What would you like to explore?"
    
    def _build_visual_description(self, visual_context):
        """Build natural language description of visual context"""
        descriptions = []
        
        if visual_context['objects']:
            if len(visual_context['objects']) == 1:
                descriptions.append(f"a {visual_context['objects'][0]}")
            elif len(visual_context['objects']) == 2:
                descriptions.append(f"a {visual_context['objects'][0]} and a {visual_context['objects'][1]}")
            else:
                descriptions.append(f"several objects including {', '.join(visual_context['objects'][:2])}")
        
        if visual_context['face_analysis']:
            person_data = list(visual_context['face_analysis'].values())[0]
            emotion = person_data.get('emotion', {}).get('primary', 'neutral')
            if emotion != 'neutral':
                descriptions.append(f"you appear {emotion}")
        
        if visual_context['gesture'] and visual_context['gesture'].get('gesture'):
            gesture = visual_context['gesture']['gesture']
            descriptions.append(f"you're making a {gesture.replace('_', ' ')} gesture")
        
        return ', '.join(descriptions) if descriptions else "your environment"
    
    def _infer_activity(self):
        """Infer what the user might be doing based on visual context"""
        if 'computer_workspace' in self.current_scene:
            return "working on a computer"
        elif 'study_area' in self.current_scene:
            return "studying or reading"
        elif 'busy_workspace' in self.current_scene:
            return "working in a busy environment"
        elif 'screen' in self.detected_objects:
            return "using a computer or device"
        elif 'book' in self.detected_objects:
            return "reading or studying"
        else:
            return "relaxing or having a conversation"
    
    def _get_appearance_compliment(self, emotion):
        """Get appropriate compliment based on emotion"""
        compliments = {
            'happy': "You have a wonderful, bright expression!",
            'neutral': "You look calm and composed.",
            'surprised': "You look alert and engaged!",
            'sad': "I hope everything is okay. You're always welcome to chat.",
            'angry': "You seem intense. Is there something I can help with?"
        }
        return compliments.get(emotion, "You look great!")
    
    def _ai_analysis_loop(self):
        """Continuous AI analysis and learning"""
        while self.is_active:
            try:
                # Update engagement and attention scores
                if self.face_analysis:
                    person_data = list(self.face_analysis.values())[0]
                    self.attention_level = person_data.get('attention', 0)
                    self.engagement_score = person_data.get('engagement', 0)
                
                # Learn from interaction patterns
                self._update_user_profile()
                
                time.sleep(2)  # Analyze every 2 seconds
                
            except Exception as e:
                time.sleep(2)
    
    def _proactive_ai_loop(self):
        """Proactive AI suggestions and interactions"""
        last_proactive_time = time.time()
        
        while self.is_active:
            try:
                if self.personality['proactiveness'] < 0.5:
                    time.sleep(30)
                    continue
                
                current_time = time.time()
                
                # Proactive suggestions every 5 minutes (reduced frequency)
                if current_time - last_proactive_time > 300:  # 5 minutes
                    suggestion = self._generate_proactive_suggestion()
                    if suggestion:
                        self._speak(suggestion)
                        last_proactive_time = current_time
                
                time.sleep(60)  # Check every minute
                
            except Exception as e:
                time.sleep(60)
    
    def _generate_proactive_suggestion(self):
        """Generate proactive suggestions based on context"""
        suggestions = []
        
        # Based on attention level
        if self.attention_level < 0.3:
            suggestions.append("I notice your attention seems low. Would you like to take a break or try some focusing exercises?")
        
        # Based on detected objects
        if 'screen' in self.detected_objects and self.engagement_score < 0.4:
            suggestions.append("I see you're working on a screen. Remember to take regular breaks to rest your eyes!")
        
        if 'book' in self.detected_objects:
            suggestions.append("I notice you have reading material. Would you like me to help you analyze or discuss what you're studying?")
        
        # Based on time patterns
        hour = datetime.now().hour
        if 14 <= hour <= 16:  # Afternoon
            suggestions.append("It's mid-afternoon - a great time for a quick energy boost. How are you feeling?")
        
        # Based on emotion history
        if len(self.conversation_history) > 5:
            recent_emotions = []
            for entry in list(self.conversation_history)[-5:]:
                if 'face_analysis' in entry['visual_context']:
                    face_data = entry['visual_context']['face_analysis']
                    if face_data:
                        emotion = list(face_data.values())[0].get('emotion', {}).get('primary')
                        if emotion:
                            recent_emotions.append(emotion)
            
            if recent_emotions.count('sad') > 2:
                suggestions.append("I've noticed you seem a bit down lately. Is there anything I can help you with or would you like to talk about something positive?")
        
        return random.choice(suggestions) if suggestions else None
    
    def _update_user_profile(self):
        """Update user profile based on interactions"""
        try:
            # Simple learning - track interaction preferences
            if len(self.conversation_history) > 0:
                recent_entry = self.conversation_history[-1]
                
                # Track preferred interaction times
                hour = datetime.now().hour
                if 'interaction_times' not in self.user_profile['learning_data']:
                    self.user_profile['learning_data']['interaction_times'] = {}
                
                if hour not in self.user_profile['learning_data']['interaction_times']:
                    self.user_profile['learning_data']['interaction_times'][hour] = 0
                
                self.user_profile['learning_data']['interaction_times'][hour] += 1
                
                # Track emotional patterns
                if 'emotional_patterns' not in self.user_profile['learning_data']:
                    self.user_profile['learning_data']['emotional_patterns'] = {}
                
                if 'face_analysis' in recent_entry['visual_context']:
                    face_data = recent_entry['visual_context']['face_analysis']
                    if face_data:
                        emotion = list(face_data.values())[0].get('emotion', {}).get('primary')
                        if emotion:
                            if emotion not in self.user_profile['learning_data']['emotional_patterns']:
                                self.user_profile['learning_data']['emotional_patterns'][emotion] = 0
                            self.user_profile['learning_data']['emotional_patterns'][emotion] += 1
        
        except Exception as e:
            pass  # Silent learning failure
    
    def _capture_and_analyze(self, frame):
        """Capture frame and provide detailed analysis"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"ai_analysis_{timestamp}.png"
        cv2.imwrite(filename, frame)
        
        # Generate detailed analysis
        analysis = self._generate_detailed_analysis()
        
        self._speak(f"I've captured and analyzed the current frame. {analysis}")
        print(f"üì∏ Saved analysis: {filename}")
        print(f"üß† Analysis: {analysis}")
    
    def _generate_detailed_analysis(self):
        """Generate detailed analysis of current state"""
        analysis_parts = []
        
        # Scene analysis
        analysis_parts.append(f"You're in a {self.current_scene.replace('_', ' ')}")
        
        # Object analysis
        if self.detected_objects:
            analysis_parts.append(f"I can identify {len(self.detected_objects)} objects: {', '.join(self.detected_objects)}")
        
        # Face analysis
        if self.face_analysis:
            person_data = list(self.face_analysis.values())[0]
            emotion_data = person_data.get('emotion', {})
            emotion = emotion_data.get('primary', 'neutral')
            confidence = emotion_data.get('confidence', 0)
            attention = person_data.get('attention', 0)
            
            analysis_parts.append(f"Your emotional state is {emotion} with {confidence:.0%} confidence and {attention:.0%} attention level")
        
        # Gesture analysis
        if self.gesture_state and self.gesture_state.get('gesture'):
            gesture = self.gesture_state['gesture']
            analysis_parts.append(f"You're making a {gesture.replace('_', ' ')} gesture")
        
        return ". ".join(analysis_parts) + "."
    
    def _cycle_ai_mode(self):
        """Cycle through AI personality modes"""
        modes = ['intelligent_assistant', 'creative_companion', 'analytical_observer', 'friendly_helper']
        current_index = modes.index(self.personality['mode'])
        self.personality['mode'] = modes[(current_index + 1) % len(modes)]
        
        # Adjust personality parameters
        mode_configs = {
            'intelligent_assistant': {'creativity': 0.6, 'helpfulness': 0.9, 'curiosity': 0.7},
            'creative_companion': {'creativity': 0.9, 'helpfulness': 0.7, 'curiosity': 0.8},
            'analytical_observer': {'creativity': 0.4, 'helpfulness': 0.8, 'curiosity': 0.9},
            'friendly_helper': {'creativity': 0.7, 'helpfulness': 1.0, 'curiosity': 0.6}
        }
        
        config = mode_configs[self.personality['mode']]
        self.personality.update(config)
        
        mode_descriptions = {
            'intelligent_assistant': "I'm now in intelligent assistant mode - focused on providing helpful and accurate information.",
            'creative_companion': "I'm now in creative companion mode - ready to explore ideas and think outside the box!",
            'analytical_observer': "I'm now in analytical observer mode - I'll provide detailed analysis and insights.",
            'friendly_helper': "I'm now in friendly helper mode - warm, supportive, and ready to assist!"
        }
        
        self._speak(mode_descriptions[self.personality['mode']])
    
    def _speak(self, text):
        """Advanced text-to-speech with personality"""
        if not text:
            return
        
        try:
            # Adjust speech parameters based on personality
            rate = 165
            if self.personality['mode'] == 'analytical_observer':
                rate = 150  # Slower for analysis
            elif self.personality['mode'] == 'creative_companion':
                rate = 175  # Faster for creativity
            
            self.tts_engine.setProperty('rate', rate)
            
            # Stop any running speech first
            self.tts_engine.stop()
            self.tts_engine.say(text)
            self.tts_engine.runAndWait()
        except Exception as e:
            print(f"AI: {text}")
    
    def _continuous_engagement_monitor(self):
        """Monitor engagement continuously for proactive responses"""
        while self.is_active:
            try:
                if self.face_analysis:
                    person_data = list(self.face_analysis.values())[0]
                    attention = person_data.get('attention', 0)
                    emotion = person_data.get('emotion', {}).get('primary', 'neutral')
                    
                    # Track engagement patterns
                    if attention < 0.3 and self.proactive_responses:
                        self._trigger_engagement_response("low_attention")
                    elif emotion in ['sad', 'frustrated'] and self.context_awareness:
                        self._trigger_engagement_response("emotional_support")
                    elif attention > 0.8:
                        self._trigger_engagement_response("high_engagement")
                
                time.sleep(2)
            except Exception as e:
                time.sleep(2)
    
    def _context_awareness_loop(self):
        """Maintain context awareness across interactions"""
        while self.is_active:
            try:
                # Update contextual understanding
                current_context = {
                    'timestamp': datetime.now().isoformat(),
                    'scene': self.current_scene,
                    'objects': self.detected_objects,
                    'user_state': self._analyze_user_state(),
                    'interaction_quality': self.interaction_quality
                }
                
                # Add to visual memory
                self.visual_memory.append(current_context)
                
                # Analyze context patterns
                self._analyze_context_patterns()
                
                time.sleep(5)
            except Exception as e:
                time.sleep(5)
    
    def _memory_consolidation_loop(self):
        """Consolidate short-term memory to long-term storage"""
        while self.is_active:
            try:
                # Consolidate every 10 minutes
                time.sleep(600)
                
                if len(self.conversation_history) > 10:
                    self._consolidate_memories()
                    self._save_long_term_memory()
                
            except Exception as e:
                time.sleep(600)
    
    def _real_time_adaptation_loop(self):
        """Adapt behavior in real-time based on user feedback"""
        while self.is_active:
            try:
                # Analyze recent interactions for adaptation
                if len(self.conversation_history) > 5:
                    recent_interactions = list(self.conversation_history)[-5:]
                    self._adapt_personality(recent_interactions)
                
                time.sleep(30)
            except Exception as e:
                time.sleep(30)
    
    def _trigger_engagement_response(self, trigger_type):
        """Trigger proactive engagement responses"""
        responses = {
            'low_attention': "I notice you might be getting distracted. Would you like to take a break or refocus?",
            'emotional_support': "I can see you might be feeling down. I'm here if you want to talk about it.",
            'high_engagement': "You seem very focused! This is a great time for productive work."
        }
        
        if trigger_type in responses and time.time() - getattr(self, 'last_proactive_time', 0) > 180:
            print(f"AI Suggestion: {responses[trigger_type]}")
            self.last_proactive_time = time.time()
    
    def _analyze_user_state(self):
        """Analyze comprehensive user state"""
        state = {
            'attention_level': self.attention_level,
            'engagement_score': self.engagement_score,
            'emotional_state': 'neutral',
            'interaction_quality': self.interaction_quality,
            'language_preference': self.current_language
        }
        
        if self.face_analysis:
            person_data = list(self.face_analysis.values())[0]
            state['emotional_state'] = person_data.get('emotion', {}).get('primary', 'neutral')
            state['attention_level'] = person_data.get('attention', 0)
        
        return state
    
    def _consolidate_memories(self):
        """Consolidate short-term memories into long-term storage"""
        try:
            # Extract patterns from recent conversations
            recent_conversations = list(self.conversation_history)[-50:]
            
            # Analyze emotional patterns
            emotions = []
            for conv in recent_conversations:
                if 'visual_context' in conv and 'face_analysis' in conv['visual_context']:
                    face_data = conv['visual_context']['face_analysis']
                    if face_data:
                        emotion = list(face_data.values())[0].get('emotion', {}).get('primary')
                        if emotion:
                            emotions.append(emotion)
            
            # Update long-term memory
            if emotions:
                self.long_term_memory['emotional_baseline'] = {
                    'dominant_emotions': list(set(emotions)),
                    'emotional_stability': len(set(emotions)) / len(emotions) if emotions else 1
                }
            
            # Store interaction patterns
            self.long_term_memory['interaction_history'].append({
                'session_date': datetime.now().isoformat(),
                'conversation_count': len(recent_conversations),
                'dominant_emotion': max(set(emotions), key=emotions.count) if emotions else 'neutral',
                'engagement_quality': self.interaction_quality
            })
            
        except Exception as e:
            print(f"Memory consolidation error: {e}")
    
    def _save_long_term_memory(self):
        """Save long-term memory to persistent storage"""
        try:
            import json
            with open('jarvis_long_term_memory.json', 'w') as f:
                json.dump(self.long_term_memory, f, indent=2)
        except Exception as e:
            print(f"Memory save error: {e}")
    
    def _adapt_personality(self, recent_interactions):
        """Adapt personality based on user feedback and interaction patterns"""
        try:
            # Analyze user response patterns
            positive_responses = 0
            total_responses = len(recent_interactions)
            
            for interaction in recent_interactions:
                user_input = interaction.get('user_input', '').lower()
                if any(word in user_input for word in ['good', 'great', 'thanks', 'helpful', 'perfect']):
                    positive_responses += 1
            
            # Adjust personality parameters
            if total_responses > 0:
                satisfaction_rate = positive_responses / total_responses
                
                if satisfaction_rate > 0.7:
                    self.personality['helpfulness'] = min(1.0, self.personality['helpfulness'] + 0.1)
                elif satisfaction_rate < 0.3:
                    self.personality['creativity'] = min(1.0, self.personality['creativity'] + 0.1)
                    self.personality['empathy'] = min(1.0, self.personality['empathy'] + 0.1)
            
        except Exception as e:
            print(f"Personality adaptation error: {e}")
    
    def _get_phone_frame(self):
        """Get frame from phone camera"""
        try:
            ret, frame = self.camera.read()
            if ret:
                return ret, frame
            else:
                # Try to reconnect
                self.camera.release()
                self.camera = cv2.VideoCapture('http://localhost:8080/video')
                return self.camera.read()
        except Exception as e:
            return False, None
    
    def stop_gemini_vision(self):
        """Stop the advanced vision system with memory consolidation"""
        if not self.is_active:
            return "Advanced Vision AI not active"
        
        self.is_active = False
        
        # Final memory consolidation
        try:
            self._consolidate_memories()
            self._save_long_term_memory()
        except Exception as e:
            print(f"Final memory save error: {e}")
        
        try:
            if self.camera:
                self.camera.release()
            cv2.destroyAllWindows()
            
            # Clean up ADB forwarding
            if self.use_phone_camera:
                try:
                    subprocess.run('C:\\platform-tools\\adb.exe forward --remove tcp:8080', shell=True, capture_output=True)
                except:
                    pass
                
        except Exception as e:
            print(f"Cleanup error: {e}")
        
        print("‚úÖ Gemini Live session ended successfully!")
        return "Gemini Live stopped"
    
    def get_advanced_status(self):
        """Get comprehensive system status"""
        return {
            'active': self.is_active,
            'mediapipe_available': MEDIAPIPE_AVAILABLE,
            'gemini_available': GEMINI_AVAILABLE,
            'current_scene': self.current_scene,
            'detected_objects': self.detected_objects,
            'face_analysis': self.face_analysis,
            'gesture_state': self.gesture_state,
            'attention_level': self.attention_level,
            'engagement_score': self.engagement_score,
            'personality': self.personality,
            'conversation_count': len(self.conversation_history),
            'user_profile': self.user_profile
        }

# Global instance
gemini_vision = GeminiAdvancedVision()

# Public functions
def start_gemini_advanced():
    return gemini_vision.start_gemini_vision()

def stop_gemini_advanced():
    return gemini_vision.stop_gemini_vision()

def get_gemini_status():
    return gemini_vision.get_advanced_status()

def is_gemini_active():
    return gemini_vision.is_active
# Gemini API Configuration
# Get your free API key from: https://makersuite.google.com/app/apikey

GEMINI_API_KEY = ""

# Instructions:
# 1. Go to https://makersuite.google.com/app/apikey
# 2. Create a new API key
# 3. Replace YOUR_API_KEY_HERE with your actual key
# 4. Save this file
GROQ_API_KEY = ""
import os
import re
import time


def extract_yt_term(command):
    # Define a regular expression pattern to capture the song name
    pattern = r'play\s+(.*?)\s+on\s+youtube'
    # Use re.search to find the match in the command
    match = re.search(pattern, command, re.IGNORECASE)
    # If a match is found, return the extracted song name; otherwise, return None
    return match.group(1) if match else None


def remove_words(input_string, words_to_remove):
    # Split the input string into words
    words = input_string.split()

    # Remove unwanted words
    filtered_words = [word for word in words if word.lower() not in words_to_remove]

    # Join the remaining words back into a string
    result_string = ' '.join(filtered_words)

    return result_string



# key events like receive call, stop call, go back
def keyEvent(key_code):
    command =  f'adb shell input keyevent {key_code}'
    os.system(command)
    time.sleep(1)

# Tap event used to tap anywhere on screen
def tapEvents(x, y):
    command =  f'adb shell input tap {x} {y}'
    os.system(command)
    time.sleep(1)

# Input Event is used to insert text in mobile
def adbInput(message):
    command =  f'adb shell input text "{message}"'
    os.system(command)
    time.sleep(1)

# to go complete back
def goback(key_code):
    for i in range(6):
        keyEvent(key_code)

# To replace space in string with %s for complete message send
def replace_spaces_with_percent_s(input_string):
    return input_string.replace(' ', '%s')
import time
import os
import base64
import threading
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.options import Options
from webdriver_manager.chrome import ChromeDriverManager

def create_image_gemini(prompt):
    """Create image using Gemini in background"""
    def generate_image():
        try:
            # Configure Chrome headless
            chrome_options = Options()
            chrome_options.add_argument("--headless=new")
            chrome_options.add_argument("--disable-gpu")
            chrome_options.add_argument("--no-sandbox")
            chrome_options.add_argument("--disable-dev-shm-usage")
            chrome_options.add_argument("--window-size=1920,1080")
            
            driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=chrome_options)
            driver.get("https://gemini.google.com/")
            
            print("[Jarvis] Generating image in background...")
            
            # Wait and find text input with multiple attempts
            time.sleep(8)
            
            # Try multiple selectors
            text_box = None
            selectors = [
                (By.CSS_SELECTOR, 'textarea[placeholder*="Enter a prompt"]'),
                (By.CSS_SELECTOR, 'div[contenteditable="true"]'),
                (By.TAG_NAME, "textarea"),
                (By.XPATH, "//textarea"),
                (By.XPATH, "//div[@contenteditable='true']")
            ]
            
            for selector_type, selector in selectors:
                try:
                    text_box = driver.find_element(selector_type, selector)
                    break
                except:
                    continue
            
            if not text_box:
                raise Exception("Could not find input field")
            
            # Click and enter text
            text_box.click()
            time.sleep(1)
            text_box.clear()
            text_box.send_keys(f"Create an image of: {prompt}")
            
            # Try to submit
            try:
                text_box.submit()
            except:
                from selenium.webdriver.common.keys import Keys
                text_box.send_keys(Keys.RETURN)
            
            # Wait for generation
            time.sleep(20)
            
            # Find and save image
            try:
                # Look for generated images
                images = driver.find_elements(By.TAG_NAME, "img")
                saved = False
                
                for img in images[-5:]:  # Check last 5 images
                    try:
                        img_src = img.get_attribute("src")
                        
                        if img_src and (img_src.startswith("data:image") or ("http" in img_src and "logo" not in img_src.lower())):
                            os.makedirs("images", exist_ok=True)
                            
                            if img_src.startswith("data:image"):
                                # Base64 image
                                image_data = base64.b64decode(img_src.split(",")[1])
                                filename = f"images/generated_{int(time.time())}.png"
                                
                                with open(filename, "wb") as f:
                                    f.write(image_data)
                            else:
                                # URL image
                                import requests
                                response = requests.get(img_src)
                                if response.status_code == 200 and len(response.content) > 1000:
                                    filename = f"images/generated_{int(time.time())}.jpg"
                                    with open(filename, "wb") as f:
                                        f.write(response.content)
                                else:
                                    continue
                            
                            print(f"[Jarvis] Image saved as {filename}")
                            saved = True
                            
                            # Voice feedback
                            try:
                                from engine.voice_gender_control import voice_control
                                voice_control.speak_with_gender("Image created successfully and saved to images folder")
                            except:
                                pass
                            break
                    except:
                        continue
                
                if not saved:
                    print("[Jarvis] Could not save generated image - may need login or different approach")
                    
            except Exception as e:
                print(f"[Jarvis] Image generation failed: {str(e)}")
                
            driver.quit()
            
        except Exception as e:
            print(f"[Jarvis] Image creator error: {str(e)}")
            try:
                from engine.voice_gender_control import voice_control
                voice_control.speak_with_gender("Image generation failed. Please try again later.")
            except:
                pass
            if 'driver' in locals():
                try:
                    driver.quit()
                except:
                    pass
    
    # Run in background thread
    threading.Thread(target=generate_image, daemon=True).start()
    return "Starting image generation in background..."
# Universal Dynamic Multilingual Support for All DualAI Features
import pyttsx3
import datetime
import os
import warnings
warnings.filterwarnings("ignore", category=UserWarning)
os.environ['PYGAME_HIDE_SUPPORT_PROMPT'] = "hide"

class MultilingualJarvis:
    def __init__(self):
        # Load saved language or default to English
        try:
            if os.path.exists('current_language.txt'):
                with open('current_language.txt', 'r') as f:
                    self.current_language = f.read().strip()
            else:
                self.current_language = 'english'
        except:
            self.current_language = 'english'
        
        # Language configurations
        self.supported_languages = {
            'english': {'code': 'en', 'tts_code': 'en', 'recognition': 'en-IN'},
            'hindi': {'code': 'hi', 'tts_code': 'hi', 'recognition': 'hi-IN'},
            'kannada': {'code': 'kn', 'tts_code': 'kn', 'recognition': 'kn-IN'},
            'bengali': {'code': 'bn', 'tts_code': 'bn', 'recognition': 'bn-IN'},
            'gujarati': {'code': 'gu', 'tts_code': 'gu', 'recognition': 'gu-IN'},
            'malayalam': {'code': 'ml', 'tts_code': 'ml', 'recognition': 'ml-IN'},
            'marathi': {'code': 'mr', 'tts_code': 'mr', 'recognition': 'mr-IN'},
            'tamil': {'code': 'ta', 'tts_code': 'ta', 'recognition': 'ta-IN'},
            'telugu': {'code': 'te', 'tts_code': 'te', 'recognition': 'te-IN'},
            'urdu': {'code': 'ur', 'tts_code': 'ur', 'recognition': 'ur-IN'},
            'punjabi': {'code': 'pa', 'tts_code': 'pa', 'recognition': 'pa-IN'},
            'assamese': {'code': 'as', 'tts_code': 'as', 'recognition': 'as-IN'},
            'odia': {'code': 'or', 'tts_code': 'or', 'recognition': 'or-IN'},
            'spanish': {'code': 'es', 'tts_code': 'es', 'recognition': 'es-ES'},
            'french': {'code': 'fr', 'tts_code': 'fr', 'recognition': 'fr-FR'},
            'german': {'code': 'de', 'tts_code': 'de', 'recognition': 'de-DE'},
            'italian': {'code': 'it', 'tts_code': 'it', 'recognition': 'it-IT'},
            'portuguese': {'code': 'pt', 'tts_code': 'pt', 'recognition': 'pt-PT'},
            'russian': {'code': 'ru', 'tts_code': 'ru', 'recognition': 'ru-RU'},
            'dutch': {'code': 'nl', 'tts_code': 'nl', 'recognition': 'nl-NL'},
            'swedish': {'code': 'sv', 'tts_code': 'sv', 'recognition': 'sv-SE'},
            'norwegian': {'code': 'no', 'tts_code': 'no', 'recognition': 'no-NO'},
            'danish': {'code': 'da', 'tts_code': 'da', 'recognition': 'da-DK'},
            'polish': {'code': 'pl', 'tts_code': 'pl', 'recognition': 'pl-PL'},
            'czech': {'code': 'cs', 'tts_code': 'cs', 'recognition': 'cs-CZ'},
            'hungarian': {'code': 'hu', 'tts_code': 'hu', 'recognition': 'hu-HU'},
            'romanian': {'code': 'ro', 'tts_code': 'ro', 'recognition': 'ro-RO'},
            'greek': {'code': 'el', 'tts_code': 'el', 'recognition': 'el-GR'},
            'norwegian': {'code': 'no', 'tts_code': 'no', 'recognition': 'no-NO'},
            'danish': {'code': 'da', 'tts_code': 'da', 'recognition': 'da-DK'}
        }
        
        # Dynamic translation cache
        self.translation_cache = {}
        
        # Common responses
        self.responses = {
            'english': {
                'not_understood': "I didn't understand that",
                'processing': "I'm processing your request",
                'error': 'Something went wrong'
            },
            'kannada': {
                'not_understood': '‡≤®‡≤®‡≤ó‡≥Ü ‡≤Ö‡≤∞‡≥ç‡≤•‡≤µ‡≤æ‡≤ó‡≤≤‡≤ø‡≤≤‡≥ç‡≤≤',
                'processing': '‡≤®‡≤æ‡≤®‡≥Å ‡≤®‡≤ø‡≤Æ‡≥ç‡≤Æ ‡≤Ö‡≤®‡≥Å‡≤∞‡≥ã‡≤ß‡≤µ‡≤®‡≥ç‡≤®‡≥Å ‡≤™‡≥ç‡≤∞‡≤ï‡≥ç‡≤∞‡≤ø‡≤Ø‡≥Ü ‡≤Æ‡≤æ‡≤°‡≥Å‡≤§‡≥ç‡≤§‡≤ø‡≤¶‡≥ç‡≤¶‡≥á‡≤®‡≥Ü',
                'error': '‡≤è‡≤®‡≥ã ‡≤§‡≤™‡≥ç‡≤™‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü'
            },
            'hindi': {
                'not_understood': '‡§Æ‡•à‡§Ç ‡§∏‡§Æ‡§ù ‡§®‡§π‡•Ä‡§Ç ‡§™‡§æ‡§Ø‡§æ',
                'processing': '‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•á ‡§Ö‡§®‡•Å‡§∞‡•ã‡§ß ‡§™‡§∞ ‡§ï‡§æ‡§Æ ‡§ï‡§∞ ‡§∞‡§π‡§æ ‡§π‡•Ç‡§Å',
                'error': '‡§ï‡•Å‡§õ ‡§ó‡§≤‡§§ ‡§π‡•ã ‡§ó‡§Ø‡§æ'
            }
        }
    
    def get_response(self, key):
        """Get response in current language"""
        return self.responses.get(self.current_language, {}).get(key, self.responses['english'][key])
    
    def process_multilingual_command(self, query):
        """Process any command in any language"""
        # Auto-detect language and set it
        detected_lang = self.detect_language(query)
        if detected_lang != 'english':
            self.current_language = detected_lang
        
        return self.process_command_in_language(query, self.current_language)
    
    def process_command_in_language(self, command, language):
        """Process command in specified language"""
        try:
            # Import DualAI to access all functions
            from engine.dual_ai import DualAI
            dual_ai = DualAI()
            
            # Try to match with any function dynamically
            for function_name, function_action in dual_ai.functions.items():
                if self._matches_function(command.lower(), function_name):
                    # Safety check: Skip dangerous commands
                    if function_name in ['shutdown', 'restart', 'hibernate']:
                        print(f"Skipping dangerous command: {function_name}")
                        return f"Dangerous command {function_name} blocked for safety"
                    
                    try:
                        result = function_action()
                        
                        # Always return actual result if it exists and is meaningful
                        if result and str(result).strip() and str(result) != 'None':
                            return str(result)
                        
                        # For functions without meaningful return, give success message
                        response = f"{function_name.replace('_', ' ').title()} executed"
                        return self._get_native_response(response)
                    except Exception as e:
                        return self.get_response('error')
            
            return self.get_response('not_understood')
            
        except Exception as e:
            print(f"Command processing error: {e}")
            return self.get_response('error')
    
    def _matches_function(self, command, function_name):
        """Dynamic universal function matching for all languages"""
        # Get semantic meaning of command
        english_intent = self._get_semantic_intent(command.lower())
        
        # Dynamic semantic matching
        return self._semantic_match(english_intent, function_name)
    
    def _get_semantic_intent(self, command):
        """Extract semantic intent from any language command"""
        # Check cache first
        if command in self.translation_cache:
            return self.translation_cache[command]
        
        # Dynamic intent extraction using AI-like pattern matching
        intent = self._extract_intent_dynamically(command)
        
        # Cache the result
        self.translation_cache[command] = intent
        return intent
    
    def _extract_intent_dynamically(self, command):
        """Extract intent without predefined mappings"""
        try:
            # Use Google Translate for dynamic translation
            from googletrans import Translator
            translator = Translator()
            
            # Translate to English
            result = translator.translate(command, dest='en')
            return result.text.lower()
        except Exception as e:
            # Fallback: Use phonetic and character analysis
            return self._phonetic_intent_extraction(command)
    
    def _phonetic_intent_extraction(self, command):
        """Pure fallback - return original command for fuzzy matching"""
        return command
    
    def _semantic_match(self, intent, function_name):
        """Precise semantic matching to prevent incorrect matches"""
        # Direct exact matching
        if function_name == intent or function_name.replace('_', ' ') == intent:
            return True
        
        # Check if function name is in intent
        if function_name in intent:
            return True
        
        # Special handling for volume commands
        if 'volume' in intent or 'sound' in intent or 'audio' in intent:
            if ('up' in intent or 'increase' in intent or 'raise' in intent) and function_name == 'volume_up':
                return True
            elif ('down' in intent or 'decrease' in intent or 'lower' in intent) and function_name == 'volume_down':
                return True
            elif ('mute' in intent or 'silent' in intent) and function_name == 'mute':
                return True
        
        # Prevent dangerous command false matches
        dangerous_commands = ['shutdown', 'restart', 'hibernate']
        if function_name in dangerous_commands:
            # Only match if intent explicitly contains the dangerous word
            return function_name in intent.lower()
        
        # Safe fuzzy matching for non-dangerous commands
        intent_words = intent.split()
        function_words = function_name.replace('_', ' ').split()
        
        # Require exact word matches for safety
        for intent_word in intent_words:
            for func_word in function_words:
                if intent_word == func_word:
                    return True
        
        return False
    
    def _get_native_response(self, english_response):
        """Get response in native language using dynamic translation"""
        if self.current_language == 'english':
            return english_response
        
        try:
            from googletrans import Translator
            translator = Translator()
            
            # Get target language code
            target_lang = self.supported_languages.get(self.current_language, {}).get('code', 'en')
            
            # Translate response to native language
            result = translator.translate(english_response, dest=target_lang)
            return result.text
        except Exception as e:
            print(f"Translation error: {e}")
            return english_response
    
    def detect_language(self, text):
        """Auto-detect language from text"""
        if any(0x0C80 <= ord(char) <= 0x0CFF for char in text):
            return 'kannada'
        elif any(0x0900 <= ord(char) <= 0x097F for char in text):
            return 'hindi'
        elif any(0x0980 <= ord(char) <= 0x09FF for char in text):
            return 'bengali'
        elif any(0x0A80 <= ord(char) <= 0x0AFF for char in text):
            return 'gujarati'
        elif any(0x0D00 <= ord(char) <= 0x0D7F for char in text):
            return 'malayalam'
        elif any(0x0900 <= ord(char) <= 0x097F for char in text):
            return 'marathi'
        elif any(0x0B80 <= ord(char) <= 0x0BFF for char in text):
            return 'tamil'
        elif any(0x0C00 <= ord(char) <= 0x0C7F for char in text):
            return 'telugu'
        elif any(0x0600 <= ord(char) <= 0x06FF for char in text):
            return 'urdu'
        elif any(0x0370 <= ord(char) <= 0x03FF for char in text):
            return 'greek'
        elif any(0x0400 <= ord(char) <= 0x04FF for char in text):
            return 'russian'
        return 'english'
    
    def get_speech_recognition_language(self):
        """Get language code for speech recognition"""
        return self.supported_languages.get(self.current_language, {}).get('recognition', 'en-IN')
    
    def get_tts_language(self):
        """Get language code for text-to-speech"""
        return self.supported_languages.get(self.current_language, {}).get('tts_code', 'en')
    
    def set_language(self, language):
        """Set the current language"""
        if language in self.supported_languages:
            self.current_language = language
            # Save to file
            try:
                with open('current_language.txt', 'w') as f:
                    f.write(language)
                return True
            except:
                return False
        return False
    
    def speak_multilingual(self, text, language=None):
        """Return text for main system to handle TTS"""
        # Don't speak here - let main system handle TTS
        return text

# Create global instance for backward compatibility
multilingual = MultilingualJarvis()
"""
New Features Extension - Single file to add features without modifying dual_ai.py
"""

import subprocess
import os
import datetime
import threading
import time
import socket

# Global instance for external access
_new_features_instance = None

def get_new_feature_response(query):
    """External function to access new features"""
    global _new_features_instance
    if _new_features_instance is None:
        _new_features_instance = NewFeatures()
    return _new_features_instance.execute(query)

def task_reminder(query=""):
    """Direct access to task reminder function"""
    global _new_features_instance
    if _new_features_instance is None:
        _new_features_instance = NewFeatures()
    return _new_features_instance.task_reminder(query)

class NewFeatures:
    def __init__(self):
        # Start continuous monitoring
        self._start_continuous_monitoring()
        
        self.features = {
            # Utility Tools
            'weather_forecast': self.weather_forecast,
            'qr_code_generator': self.qr_code_generator,
            'password_generator': self.password_generator,
            'color_picker': self.color_picker,
            # 'text_to_speech_file': self.text_to_speech_file,
            'image_converter': self.image_converter,
            'empty_trash': self.empty_trash,
            
            # Productivity Tools
            'pomodoro_timer': self.pomodoro_timer,
            'pomodoro_test': self.pomodoro_test,
            'break_reminder': self.break_reminder,
            'word_count': self.word_count,
            'text_cleaner': self.text_cleaner,
            'url_shortener': self.url_shortener,
            
            # File Management
            'duplicate_finder': self.duplicate_finder,
            'file_organizer': self.file_organizer,
            'batch_rename': self.batch_rename,
            'folder_size': self.folder_size,
            'recent_files': self.recent_files,
            'compress_files': self.compress_files,
            'extract_archive': self.extract_archive,
            
            # PDF Operations
            'merge_pdf': self.merge_pdf,
            'split_pdf': self.split_pdf,
            'pdf_to_text': self.pdf_to_text,
            'pdf_to_images': self.pdf_to_images,
            'pdf_encrypt': self.pdf_encrypt,
            'pdf_decrypt': self.pdf_decrypt,
            'pdf_compress': self.pdf_compress,
            'pdf_rotate': self.pdf_rotate,
            'pdf_watermark': self.pdf_watermark,
            
            # Document Conversion
            'images_to_pdf': self.images_to_pdf,
            'word_to_pdf': self.word_to_pdf,
            'excel_to_pdf': self.excel_to_pdf,
            'powerpoint_to_pdf': self.powerpoint_to_pdf,
            'html_to_pdf': self.html_to_pdf,
            'text_to_pdf': self.text_to_pdf,
            
            # Advanced Productivity
            'email_templates': self.email_templates,
            'meeting_scheduler': self.meeting_scheduler,
            'task_reminder': self.task_reminder,
            'list_reminders': self.list_reminders,
            
            # Media Tools
            'image_editor': self.image_editor,
            'audio_converter': self.audio_converter,
            'video_downloader': self.video_downloader,
            
            # Recording Tools
            'voice_recorder': self.voice_recorder,
            'screen_recorder': self.screen_recorder,
            
            # Health & Wellness
            'water_reminder': self.water_reminder,
            'exercise_timer': self.exercise_timer,
            'calorie_calculator': self.calorie_calculator,
            'sleep_tracker': self.sleep_tracker,
            'stress_meter': self.stress_meter,
            'mood_tracker': self.mood_tracker,
            'heart_rate_monitor': self.heart_rate_monitor,
            'medication_reminder': self.medication_reminder,
            'bmi_calculator': self.bmi_calculator,
            'system_monitor': self.system_monitor,
            'network_monitor': self.network_monitor,
            
            # Learning & Education
            'language_translator': self.language_translator,
            'dictionary_lookup': self.dictionary_lookup,
            'wikipedia_search': self.wikipedia_search,
            'calculator_advanced': self.calculator_advanced,
            'unit_converter': self.unit_converter,
            'flashcard_system': self.flashcard_system,
            'quiz_generator': self.quiz_generator,
            
            # Creative Tools
            'meme_generator': self.meme_generator,
            'logo_generator': self.logo_generator,
            'color_palette_generator': self.color_palette_generator,
            'font_viewer': self.font_viewer,
            'ascii_art_generator': self.ascii_art_generator,
            'barcode_generator': self.barcode_generator,
            'mind_map_creator': self.mind_map_creator,
            
            # Security & Development Tools
            'password_manager': self.password_manager,
            'startup_manager': self.startup_manager,
            'git_helper': self.git_helper,
            'port_scanner': self.port_scanner,
            'email_sender': self.email_sender,
            'financial_tools': self.financial_tools,
            'speed_test': self.speed_test,
            'battery_health': self.battery_health,
            'thermal_monitor': self.thermal_monitor,
           
            'disk_health_scanner': self.disk_health_scanner,
            'usb_device_manager': self.usb_device_manager,
            'quick_note_taker': self.quick_note_taker,
            'large_file_scanner': self.large_file_scanner,
            'file_search_engine': self.file_search_engine,
            'recent_files_tracker': self.recent_files_tracker,
            'recently_installed_apps': self.recently_installed_apps,
            'python_packages': self.python_packages,
            
            # Universal App Management
            'open_app': self.open_app,
            'close_app': self.close_app,
            
            # Universal Website Management
            'open_website': self.open_website,
            'close_website': self.close_website,
        }
        
        self.natural_mappings = {
            # Utility Tools
            'weather': 'weather_forecast', 'weather forecast': 'weather_forecast',
            'qr code': 'qr_code_generator', 'generate qr': 'qr_code_generator',
            'password': 'password_generator', 'generate password': 'password_generator',
            'color picker': 'color_picker', 'pick color': 'color_picker',
            # 'text to speech': 'text_to_speech_file', 'convert to audio': 'text_to_speech_file',
            'convert image': 'image_converter', 'image format': 'image_converter',
          
            
            # Productivity Tools
            'pomodoro': 'pomodoro_timer', 'work timer': 'pomodoro_timer',
            'pomodoro test': 'pomodoro_test', 'test timer': 'pomodoro_test',
            'break reminder': 'break_reminder', 'remind break': 'break_reminder',
            'word count': 'word_count', 'count words': 'word_count',
            'clean text': 'text_cleaner', 'format text': 'text_cleaner',
            'shorten url': 'url_shortener', 'short link': 'url_shortener',
            
            # File Management
            'find duplicates': 'duplicate_finder', 'duplicate files': 'duplicate_finder',
            'organize files': 'file_organizer', 'organize downloads': 'file_organizer', 'organize documents': 'file_organizer', 'organize desktop': 'file_organizer', 'organize ': 'file_organizer',
            'rename files': 'batch_rename', 'batch rename': 'batch_rename',
            'folder size': 'folder_size', 'calculate size': 'folder_size',
            'recent files': 'recent_files', 'show recent': 'recent_files',
            'compress files': 'compress_files', 'create zip': 'compress_files',
            'extract archive': 'extract_archive', 'extract zip': 'extract_archive',
            
            # PDF Operations
            'merge pdf': 'merge_pdf', 'combine pdf': 'merge_pdf',
            'split pdf': 'split_pdf', 'divide pdf': 'split_pdf',
            'pdf to text': 'pdf_to_text', 'extract text': 'pdf_to_text',
            'pdf to images': 'pdf_to_images', 'convert pdf': 'pdf_to_images',
            'encrypt pdf': 'pdf_encrypt', 'protect pdf': 'pdf_encrypt', 'pdf encrypt': 'pdf_encrypt',
            'decrypt pdf': 'pdf_decrypt', 'unlock pdf': 'pdf_decrypt', 'pdf decrypt': 'pdf_decrypt',
            'compress pdf': 'pdf_compress', 'reduce pdf': 'pdf_compress',
            'rotate pdf': 'pdf_rotate', 'turn pdf': 'pdf_rotate',
            'watermark pdf': 'pdf_watermark', 'add watermark': 'pdf_watermark',
            
            # Document Conversion
            'images to pdf': 'images_to_pdf', 'create pdf': 'images_to_pdf',
            'word to pdf': 'word_to_pdf', 'docx to pdf': 'word_to_pdf',
            'excel to pdf': 'excel_to_pdf', 'xlsx to pdf': 'excel_to_pdf',
            'powerpoint to pdf': 'powerpoint_to_pdf', 'pptx to pdf': 'powerpoint_to_pdf',
            'html to pdf': 'html_to_pdf', 'webpage to pdf': 'html_to_pdf',
            'text to pdf': 'text_to_pdf', 'txt to pdf': 'text_to_pdf',
            
            # Advanced Productivity
            'email templates': 'email_templates', 'email template': 'email_templates',
            'meeting scheduler': 'meeting_scheduler', 'schedule meeting': 'meeting_scheduler',
            'task reminder': 'task_reminder', 'set reminder': 'task_reminder', 'add reminder': 'task_reminder', 'remind me': 'task_reminder',
            'list reminders': 'list_reminders', 'show reminders': 'list_reminders',
            
            # Media Tools
            'image editor': 'image_editor', 'edit image': 'image_editor',
            'audio converter': 'audio_converter', 'convert audio': 'audio_converter',
            'video downloader': 'video_downloader', 'download video': 'video_downloader',
            
            # Recording Tools
            'voice recorder': 'voice_recorder', 'record voice': 'voice_recorder',
            'screen recorder': 'screen_recorder', 'record screen': 'screen_recorder',
            
            # Health & Wellness
            'water reminder': 'water_reminder', 'hydration tracker': 'water_reminder',
            'exercise timer': 'exercise_timer', 'workout timer': 'exercise_timer',
            'calorie calculator': 'calorie_calculator', 'food tracker': 'calorie_calculator',
            'sleep tracker': 'sleep_tracker', 'bedtime reminder': 'sleep_tracker',
            'stress meter': 'stress_meter', 'wellness check': 'stress_meter',
            'mood tracker': 'mood_tracker', 'mood check': 'mood_tracker',
            'heart rate': 'heart_rate_monitor', 'pulse check': 'heart_rate_monitor',
            'medication reminder': 'medication_reminder', 'pill reminder': 'medication_reminder',
            'bmi calculator': 'bmi_calculator', 'body mass index': 'bmi_calculator',
            'system monitor': 'system_monitor', 'system status': 'system_monitor',
            'network monitor': 'network_monitor', 'network status': 'network_monitor',
            
            # Learning & Education
            'translate': 'language_translator', 'translation': 'language_translator',
            'dictionary': 'dictionary_lookup', 'define': 'dictionary_lookup',
            'wikipedia': 'wikipedia_search', 'wiki': 'wikipedia_search',
            'solve': 'calculator_advanced', 'calculate': 'calculator_advanced',
            'convert': 'unit_converter', 'unit conversion': 'unit_converter',
            'flashcard': 'flashcard_system', 'study cards': 'flashcard_system',
            'quiz': 'quiz_generator', 'test me': 'quiz_generator',
            
            # Creative Tools
            'meme': 'meme_generator', 'create meme': 'meme_generator',
            'logo': 'logo_generator', 'create logo': 'logo_generator',
            'color palette': 'color_palette_generator', 'colors': 'color_palette_generator',
            'font': 'font_viewer', 'fonts': 'font_viewer',
            'ascii art': 'ascii_art_generator', 'ascii': 'ascii_art_generator',
            'barcode': 'barcode_generator', 'qr code': 'qr_code_generator',
            'mind map': 'mind_map_creator', 'mindmap': 'mind_map_creator',
            
            # Security & Development Tools
            'password manager': 'password_manager', 'show password': 'password_manager',
            'startup manager': 'startup_manager', 'startup apps': 'startup_manager',
            'git helper': 'git_helper', 'git commit': 'git_helper', 'git push': 'git_helper',
            'port scanner': 'port_scanner', 'scan ports': 'port_scanner',
            'email sender': 'email_sender', 'send email': 'email_sender', 'schedule email': 'email_sender', 'email later': 'email_sender', 'delayed email': 'email_sender',
            'financial tools': 'financial_tools', 'expense': 'financial_tools', 'currency': 'financial_tools', 'stock': 'financial_tools', 'crypto': 'financial_tools', 'spotify': 'financial_tools', 'movie': 'financial_tools', 'news': 'financial_tools', 'joke': 'financial_tools',
            'speed test': 'speed_test', 'internet speed': 'speed_test', 'check speed': 'speed_test',
            'battery health': 'battery_health', 'battery status': 'battery_health', 'battery check': 'battery_health',
            'thermal monitor': 'thermal_monitor', 'temperature check': 'thermal_monitor', 'cpu temperature': 'thermal_monitor',
           
            'disk health': 'disk_health_scanner', 'check disk': 'disk_health_scanner', 'smart data': 'disk_health_scanner',
            'usb devices': 'usb_device_manager', 'usb manager': 'usb_device_manager', 'connected devices': 'usb_device_manager',
            'quick note': 'quick_note_taker', 'note taker': 'quick_note_taker', 'take note': 'quick_note_taker', 'voice note': 'quick_note_taker',
            'large files': 'large_file_scanner', 'big files': 'large_file_scanner', 'file scanner': 'large_file_scanner', 'space usage': 'large_file_scanner',
            'file search': 'file_search_engine', 'search files': 'file_search_engine', 'find files': 'file_search_engine', 'locate files': 'file_search_engine',
            'recent files': 'recent_files_tracker', 'recent items': 'recent_files_tracker', 'file tracker': 'recent_files_tracker', 'latest files': 'recent_files_tracker',
            'recently installed apps': 'recently_installed_apps', 'installed apps': 'recently_installed_apps', 'new apps': 'recently_installed_apps', 'app history': 'recently_installed_apps',
            'python packages': 'python_packages', 'installed packages': 'python_packages', 'pip list': 'python_packages', 'show packages': 'python_packages',
            
           
           
            'open web': 'open_website', 'close web': 'close_website',
            'Empty recycle bin': 'empty_trash', 'clean recycle bin': 'empty_trash',
        }
    
    def _start_continuous_monitoring(self):
        """Start continuous monitoring threads for battery and thermal"""
        try:
            # Start battery monitoring thread
            battery_thread = threading.Thread(target=self._continuous_battery_monitor, daemon=True)
            battery_thread.start()
            
            # Start thermal monitoring thread  
            thermal_thread = threading.Thread(target=self._continuous_thermal_monitor, daemon=True)
            thermal_thread.start()
            
            # Start reminder monitoring thread
            reminder_thread = threading.Thread(target=self._check_pending_reminders, daemon=True)
            reminder_thread.start()
            
        except Exception as e:
            print(f"Error starting continuous monitoring: {e}")
    
    def _continuous_battery_monitor(self):
        """Continuous battery health monitoring"""
        while True:
            try:
                import psutil
                battery = psutil.sensors_battery()
                if battery:
                    # Check for overcharging (>95% and plugged in for too long)
                    if battery.percent > 95 and battery.power_plugged:
                        self._show_notification("üîã Battery Alert", "Battery over 95% - Consider unplugging to preserve battery health")
                    
                    # Check for low battery
                    elif battery.percent < 20 and not battery.power_plugged:
                        self._show_notification("üîã Low Battery", f"Battery at {battery.percent}% - Please charge soon")
                
                time.sleep(300)  # Check every 5 minutes
            except Exception:
                time.sleep(600)  # Wait 10 minutes on error
    
    def _continuous_thermal_monitor(self):
        """Continuous thermal monitoring"""
        while True:
            try:
                import psutil
                
                # Check CPU temperature
                try:
                    temps = psutil.sensors_temperatures()
                    if temps:
                        for name, entries in temps.items():
                            for entry in entries:
                                if entry.current > 85:  # Critical temperature
                                    self._show_notification("üå°Ô∏è Critical Temperature", f"{entry.label or name}: {entry.current}¬∞C - System may throttle")
                                elif entry.current > 75:  # Warning temperature
                                    self._show_notification("üå°Ô∏è High Temperature", f"{entry.label or name}: {entry.current}¬∞C - Monitor system load")
                except:
                    # Fallback: Monitor CPU usage as temperature indicator
                    cpu_percent = psutil.cpu_percent(interval=1)
                    if cpu_percent > 90:
                        self._show_notification("üå°Ô∏è High CPU Load", f"CPU at {cpu_percent}% - May cause overheating")
                
                time.sleep(120)  # Check every 2 minutes
            except Exception:
                time.sleep(300)  # Wait 5 minutes on error
    
    def _check_pending_reminders(self):
        """Check for pending reminders on startup and continuously"""
        import json, os
        from datetime import datetime
        
        while True:
            try:
                reminders_file = "reminders.json"
                if os.path.exists(reminders_file):
                    with open(reminders_file, 'r') as f:
                        reminders = json.load(f)
                    
                    now = datetime.now()
                    active_reminders = []
                    
                    for reminder in reminders:
                        reminder_time = datetime.fromisoformat(reminder['reminder_time'])
                        
                        if reminder_time <= now:
                            # Show overdue reminder
                            self._show_notification("Overdue Reminder!", f"Time to: {reminder['task']}")
                        else:
                            # Keep active reminder
                            active_reminders.append(reminder)
                            
                            # Schedule if due within next minute
                            seconds_left = (reminder_time - now).total_seconds()
                            if seconds_left <= 60:
                                def delayed_reminder(task=reminder['task'], delay=seconds_left):
                                    time.sleep(delay)
                                    self._show_notification("Task Reminder!", f"Time to: {task}")
                                
                                threading.Thread(target=delayed_reminder, daemon=True).start()
                    
                    # Update file with only active reminders
                    if len(active_reminders) != len(reminders):
                        with open(reminders_file, 'w') as f:
                            json.dump(active_reminders, f, indent=2)
                
                time.sleep(30)  # Check every 30 seconds
            except Exception:
                time.sleep(60)  # Wait 1 minute on error
    
    def execute(self, query):
        try:
            # Handle dynamic PDF operations with file paths
            import re
            
            # PDF encrypt with file path
            if 'encrypt pdf' in query.lower() or 'pdf encrypt' in query.lower():
                pattern = r'(?:encrypt pdf|pdf encrypt)\s+(.+)'
                file_match = re.search(pattern, query.lower())
                if file_match:
                    pdf_file = file_match.group(1).strip()
                    result = self.pdf_encrypt(pdf_file)
                    print(result)
                    return result
                result = self.pdf_encrypt()
                print(result)
                return result
            
            # PDF decrypt with file path
            if 'decrypt pdf' in query.lower() or 'pdf decrypt' in query.lower():
                pattern = r'(?:decrypt pdf|pdf decrypt)\s+(.+)'
                file_match = re.search(pattern, query.lower())
                if file_match:
                    pdf_file = file_match.group(1).strip()
                    result = self.pdf_decrypt(pdf_file)
                    print(result)
                    return result
                result = self.pdf_decrypt()
                print(result)
                return result
            
            # Split PDF with file path
            if 'split pdf' in query.lower():
                file_match = re.search(r'split pdf\s+([^\s]+)(?:\s+pages?\s+([\d,-]+))?', query.lower())
                if file_match:
                    pdf_file = file_match.group(1).strip()
                    page_range = file_match.group(2).strip() if file_match.group(2) else None
                    result = self.split_pdf(pdf_file, page_range)
                    print(result)
                    return result
                result = self.split_pdf()
                print(result)
                return result
            
            # Other PDF operations with file paths
            pdf_ops = {
                'merge pdf': (r'merge pdf\s+(.+)', self.merge_pdf),
                'pdf to text': (r'pdf to text\s+(.+)', self.pdf_to_text),
                'pdf to images': (r'pdf to images\s+(.+)', self.pdf_to_images),
                'compress pdf': (r'compress pdf\s+(.+)', self.pdf_compress),
                'rotate pdf': (r'rotate pdf\s+(.+)', self.pdf_rotate),
                'watermark pdf': (r'watermark pdf\s+(.+)', self.pdf_watermark)
            }
            
            for cmd, (pattern, func) in pdf_ops.items():
                if cmd in query.lower():
                    file_match = re.search(pattern, query.lower())
                    if file_match:
                        if cmd == 'merge pdf':
                            files = file_match.group(1).strip().split()
                            result = func(files)
                            print(result)
                            return result
                        else:
                            pdf_file = file_match.group(1).strip()
                            result = func(pdf_file)
                            print(result)
                            return result
                    result = func()
                    print(result)
                    return result
            
            # Check for food tracking (only 'add food' keyword)
            if 'add food' in query.lower():
                return self.calorie_calculator(query)
            
            # Check for password manager first (highest priority for password commands)
            if any(phrase in query.lower() for phrase in ['add', 'store', 'show', 'get']) and 'password' in query.lower():
                return self.password_manager(query)
            if 'password manager' in query.lower():
                return self.password_manager(query)
            
            # Check for creative tools first (highest priority)
            if any(word in query.lower() for word in ['meme', 'create meme']):
                return self.meme_generator(query)
            if any(word in query.lower() for word in ['logo', 'create logo']):
                return self.logo_generator(query)
            if any(word in query.lower() for word in ['color palette', 'colors']) and 'calorie' not in query.lower():
                return self.color_palette_generator(query)
            if any(word in query.lower() for word in ['ascii art', 'ascii']):
                return self.ascii_art_generator(query)
            if 'barcode' in query.lower():
                return self.barcode_generator(query)
            if any(word in query.lower() for word in ['mind map', 'mindmap']):
                return self.mind_map_creator(query)
            
            # Check for learning features (high priority)
            if any(word in query.lower() for word in ['translate', 'translation']):
                return self.language_translator(query)
            if any(word in query.lower() for word in ['define', 'dictionary']):
                return self.dictionary_lookup(query)
            if any(word in query.lower() for word in ['wikipedia', 'wiki']):
                return self.wikipedia_search(query)
            if any(word in query.lower() for word in ['calculate']) and not any(word in query.lower() for word in ['calorie', 'food']):
                return self.calculator_advanced(query)
            if 'convert' in query.lower() and any(word in query.lower() for word in ['meters', 'feet', 'kg', 'pounds', 'celsius', 'fahrenheit']):
                return self.unit_converter(query)
            if any(word in query.lower() for word in ['flashcard', 'study']):
                return self.flashcard_system(query)
            if 'quiz' in query.lower():
                return self.quiz_generator(query)
            
            # Check for email commands (high priority)
            if any(word in query.lower() for word in ['email', 'send email', 'schedule email', 'email later']):
                return self.email_sender(query)
            
            # Check for email writing
            if 'write email' in query.lower() or 'compose email' in query.lower():
                return self.email_templates(query)
            
            # Check for close website commands first
            if any(word in query.lower() for word in ['close ', 'quit ', 'exit ', 'kill ']) and any(word in query.lower() for word in ['web', 'website', 'site', 'browser']):
                return self.close_website(query)
            
            # Check for website commands (highest priority)
            if any(word in query.lower() for word in ['website', 'site', 'web', 'browse']) and any(word in query.lower() for word in ['open ', 'launch ', 'start ', 'run ']) and any(word in query.lower() for word in ['website', 'site', '.com', '.org', '.net']):
                return self.open_website(query)
            
            # Check for universal app commands (high priority)
            if any(word in query.lower() for word in ['open ', 'launch ', 'run ']) and not any(word in query.lower() for word in ['file', 'folder', 'browser', 'website',' writing']):
                return self.open_app(query)
            
            if any(word in query.lower() for word in ['close ', 'quit ', 'exit ', 'kill ']) and not any(word in query.lower() for word in ['file', 'folder', 'browser', 'website']):
                return self.close_app(query)
            
            # Check for exact matches first
            query_lower = query.lower().strip()
            if query_lower in self.features:
                func_name = query_lower
            else:
                # Try natural language understanding first
                func_name = self.natural_mappings.get(query_lower)
                
                if not func_name:
                    # Check for partial matches in natural mappings
                    for key, value in self.natural_mappings.items():
                        if key in query_lower:
                            func_name = value
                            break
                
                if not func_name:
                    func_name = None

            if func_name in self.features:
                # Functions that need query parameter
                query_functions = ['weather_forecast', 'qr_code_generator', 'email_templates', 'meeting_scheduler', 'task_reminder', 'list_reminders', 'image_editor', 'audio_converter', 'video_downloader', 'voice_recorder', 'screen_recorder', 'water_reminder', 'exercise_timer', 'calorie_calculator', 'sleep_tracker', 'stress_meter', 'mood_tracker', 'heart_rate_monitor', 'medication_reminder', 'bmi_calculator', 'system_monitor', 'network_monitor', 'language_translator', 'dictionary_lookup', 'wikipedia_search', 'calculator_advanced', 'unit_converter', 'flashcard_system', 'quiz_generator', 'meme_generator', 'logo_generator', 'color_palette_generator', 'font_viewer', 'ascii_art_generator', 'barcode_generator', 'mind_map_creator', 'password_manager', 'startup_manager', 'git_helper', 'port_scanner', 'email_sender', 'financial_tools', 'speed_test', 'battery_health', 'thermal_monitor', 'quick_note_taker', 'large_file_scanner', 'file_search_engine', 'recent_files_tracker', 'file_organizer', 'open_app', 'close_app', 'open_website', 'close_website']
                
                if func_name in query_functions:
                    result = self.features[func_name](query)
                else:
                    result = self.features[func_name]()
                
                # Standardized response: print for terminal, return for UI
                output = result if result else f"{func_name} completed"
                print(output)
                return output
            else:
                return None
                
        except Exception as e:
            return f"Error: {str(e)}"
    
    def understand_natural_speech(self, query):
        """Natural language processing for new features functions"""
        query = query.lower().strip()
        
        mappings = {
            # Utility Tools
            'weather_forecast': ['weather', 'weather forecast', 'how is weather'],
            'qr_code_generator': ['qr code', 'generate qr', 'create qr', 'qr generator'],
            'password_generator': ['password', 'generate password', 'create password'],
            'color_picker': ['color picker', 'pick color', 'get color'],
            # 'text_to_speech_file': ['text to speech', 'convert to audio', 'make audio'],
            'image_converter': ['convert image', 'image format', 'change image'],
            'empty_trash': ['empty trash', 'clear trash', 'clean recycle bin'],
            
            # Productivity Tools
            'pomodoro_timer': ['pomodoro', 'work timer', 'focus timer'],
            'pomodoro_test': ['pomodoro test', 'test timer'],
            'break_reminder': ['break reminder', 'remind break', 'set break'],
            'word_count': ['word count', 'count words'],
            'text_cleaner': ['clean text', 'format text'],
            'url_shortener': ['shorten url', 'short link', 'url shortener'],
            
            # File Management
            'duplicate_finder': ['find duplicates', 'duplicate files'],
            'file_organizer': ['organize files', 'organize downloads'],
            'batch_rename': ['rename files', 'batch rename'],
            'folder_size': ['folder size', 'calculate size'],
            'recent_files': ['recent files', 'show recent'],
            'compress_files': ['compress files', 'create zip', 'make archive'],
            'extract_archive': ['extract archive', 'extract zip', 'unzip'],

            
            
            # PDF Operations
            'merge_pdf': ['merge pdf', 'combine pdf', 'join pdf'],
            'split_pdf': ['split pdf', 'divide pdf', 'separate pdf'],
            'pdf_to_text': ['pdf to text', 'extract text'],
            'pdf_to_images': ['pdf to images', 'convert pdf'],
            'pdf_encrypt': ['encrypt pdf', 'protect pdf', 'secure pdf'],
            'pdf_decrypt': ['decrypt pdf', 'unlock pdf'],
            'pdf_compress': ['compress pdf', 'reduce pdf size'],
            'pdf_rotate': ['rotate pdf', 'turn pdf'],
            'pdf_watermark': ['watermark pdf', 'add watermark'],
            
            # Document Conversion
            'images_to_pdf': ['images to pdf', 'create pdf'],
            'word_to_pdf': ['word to pdf', 'doc to pdf', 'docx to pdf'],
            'excel_to_pdf': ['excel to pdf', 'xls to pdf', 'xlsx to pdf'],
            'powerpoint_to_pdf': ['powerpoint to pdf', 'ppt to pdf', 'pptx to pdf'],
            'html_to_pdf': ['html to pdf', 'web to pdf'],
            'text_to_pdf': ['text to pdf', 'txt to pdf'],
            
            # Advanced Productivity
            'email_templates': ['email templates', 'email template', 'create email', 'email draft'],
            'meeting_scheduler': ['meeting scheduler', 'schedule meeting', 'book meeting', 'calendar meeting'],
            'task_reminder': ['task reminder', 'set reminder', 'remind me', 'task alert', 'add reminder'],
            'list_reminders': ['list reminders', 'show reminders', 'what are reminders', 'my reminders'],
            
            # Media Tools
            'image_editor': ['image editor', 'edit image', 'photo editor', 'image filter'],
            'audio_converter': ['audio converter', 'convert audio', 'audio format', 'mp3 converter'],
            'video_downloader': ['video downloader', 'download video', 'youtube download', 'video download'],
            
            # Recording Tools
            'voice_recorder': ['voice recorder', 'record voice', 'audio recorder', 'voice memo', 'record audio'],
            'screen_recorder': ['screen recorder', 'record screen', 'screen capture', 'record desktop', 'capture screen'],
            
            # Health & Wellness
            'water_reminder': ['water reminder', 'hydration tracker', 'drink water', 'water intake', 'hydration alert'],
            'exercise_timer': ['exercise timer', 'workout timer', 'hiit timer', 'fitness timer', 'interval timer'],
            'calorie_calculator': ['calorie calculator', 'food tracker', 'calorie counter', 'nutrition tracker', 'diet tracker', 'ate', 'add food', 'food'],
            'sleep_tracker': ['sleep tracker', 'bedtime reminder', 'sleep schedule', 'sleep timer', 'bedtime alert', 'bedtime', 'set bedtime', 'wake time', 'set wake'],
            'stress_meter': ['stress meter', 'wellness check', 'stress level', 'mental health', 'stress assessment'],
            'mood_tracker': ['mood tracker', 'mood check', 'how feeling', 'emotional state', 'mood log'],
            'heart_rate_monitor': ['heart rate', 'pulse check', 'heart monitor', 'bpm check', 'pulse rate'],
            'medication_reminder': ['medication reminder', 'pill reminder', 'medicine alert', 'drug reminder', 'take pills'],
            'bmi_calculator': ['bmi calculator', 'body mass index', 'weight check', 'health index', 'body weight'],
            
            # Learning & Education
            'language_translator': ['translate', 'translation', 'translate to', 'convert language'],
            'dictionary_lookup': ['define', 'dictionary', 'definition', 'meaning of', 'what is'],
            'wikipedia_search': ['wikipedia', 'wiki', 'search wiki', 'wiki search'],
            'calculator_advanced': ['calculate', 'calculator', 'math', 'solve', 'compute'],
            'unit_converter': ['convert', 'conversion', 'unit convert', 'change unit'],
            'flashcard_system': ['flashcard', 'study cards', 'flash cards', 'study', 'review cards'],
            'quiz_generator': ['quiz', 'test me', 'generate quiz', 'create quiz', 'quiz on'],
            
            # Creative Tools
            'meme_generator': ['meme', 'create meme', 'generate meme', 'meme generator', 'funny meme'],
            'logo_generator': ['logo', 'create logo', 'design logo', 'logo generator', 'company logo'],
            'color_palette_generator': ['color palette', 'colors', 'color scheme', 'palette', 'color generator'],
            'font_viewer': ['font', 'fonts', 'font viewer', 'preview fonts', 'system fonts'],
            'ascii_art_generator': ['ascii art', 'ascii', 'text art', 'ascii generator', 'character art'],
            'barcode_generator': ['barcode', 'generate barcode', 'create barcode', 'barcode generator'],
            'mind_map_creator': ['mind map', 'mindmap', 'create mind map', 'mind mapping', 'brainstorm'],
            
            # Security & Development Tools
            'password_manager': ['password manager', 'show password', 'get password', 'gmail password', 'password for'],
            'startup_manager': ['startup manager', 'startup apps', 'add startup', 'remove startup', 'manage startup'],
            'git_helper': ['git helper', 'git commit', 'git push', 'git status', 'git add', 'git pull'],
            'port_scanner': ['port scanner', 'scan ports', 'security scan', 'network scan', 'check ports'],
            'email_sender': ['email sender', 'send email', 'send message', 'email to', 'compose and send', 'schedule email', 'email later', 'delayed email', 'send email in', 'email scheduler', 'auto reply', 'auto response', 'enable auto reply', 'disable auto reply'],
            
            # Financial Tools
            'financial_tools': ['expense', 'spending', 'currency', 'convert currency', 'stock price', 'crypto price', 'spotify', 'movie', 'imdb', 'news', 'joke', 'financial tools'],
            
            # System Monitoring
            'battery_health': ['battery health', 'battery status', 'battery check', 'battery info', 'battery cycles'],
            'thermal_monitor': ['thermal monitor', 'temperature check', 'cpu temperature', 'system temperature', 'overheating'],
            
            # Quick Note Taker
            'quick_note_taker': ['quick note', 'note taker', 'take note', 'voice note', 'note', 'remember', 'log', 'record'],
            
            # File Management Tools
            'large_file_scanner': ['large files', 'big files', 'file scanner', 'space usage', 'disk space', 'storage usage'],
            'file_search_engine': ['file search', 'search files', 'find files', 'locate files', 'file finder', 'search engine'],
            'recent_files_tracker': ['recent files', 'recent items', 'file tracker', 'latest files', 'recent documents', 'file history'],
            'recently_installed_apps': ['recently installed apps', 'installed apps', 'new apps', 'app history', 'recent apps', 'latest apps'],
            'python_packages': ['python packages', 'installed packages', 'pip list', 'show packages', 'package list', 'pip packages']
        }
        
        # Check for exact phrase matches first
        for func_name, phrases in mappings.items():
            for phrase in phrases:
                if phrase in query:
                    return func_name
        
        # Special handling for weather with location
        if any(word in query.lower() for word in ['weather']):
            return 'weather_forecast'
        
        # Special handling for bedtime/sleep commands
        if any(word in query for word in ['bedtime', 'wake']):
            return 'sleep_tracker'
        
        # Only trigger calorie calculator for specific food keywords
        if 'add food' in query.lower():
            return 'calorie_calculator'
        
        return None
    
    def weather_forecast(self, query=""):
        try:
            import requests
            import re
            
            # Extract location from query
            location = "current location"
            if query:
                # Remove common weather words to get location
                location_match = re.search(r'weather\s+(?:in\s+|for\s+|at\s+)?(.+)', query.lower())
                if location_match:
                    location = location_match.group(1).strip()
            
            # Use free weather API (wttr.in)
            if location == "current location":
                # Try to get location from IP
                try:
                    ip_response = requests.get('https://ipapi.co/json/', timeout=5)
                    if ip_response.status_code == 200:
                        ip_data = ip_response.json()
                        location = f"{ip_data.get('city', 'Unknown')}, {ip_data.get('country_name', 'Unknown')}"
                except:
                    location = "auto"
            
            # Get weather data from wttr.in (free, no API key needed)
            weather_url = f"https://wttr.in/{location}?format=j1"
            response = requests.get(weather_url, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                
                # Current weather
                current = data['current_condition'][0]
                location_info = data['nearest_area'][0]
                
                temp_c = current['temp_C']
                temp_f = current['temp_F']
                humidity = current['humidity']
                description = current['weatherDesc'][0]['value']
                wind_speed = current['windspeedKmph']
                wind_dir = current['winddir16Point']
                feels_like = current['FeelsLikeC']
                visibility = current['visibility']
                pressure = current['pressure']
                
                # Location details
                area_name = location_info['areaName'][0]['value']
                country = location_info['country'][0]['value']
                
                # Today's forecast
                today_forecast = data['weather'][0]
                max_temp = today_forecast['maxtempC']
                min_temp = today_forecast['mintempC']
                
                # Format weather report
                weather_report = f"Weather for {area_name}, {country}:\n"
                weather_report += f"Current: {temp_c}¬∞C ({temp_f}¬∞F) - {description}\n"
                weather_report += f"Feels like: {feels_like}¬∞C\n"
                weather_report += f"Today: {min_temp}¬∞C to {max_temp}¬∞C\n"
                weather_report += f"Humidity: {humidity}%\n"
                weather_report += f"Wind: {wind_speed} km/h {wind_dir}\n"
                weather_report += f"Pressure: {pressure} mb\n"
                weather_report += f"Visibility: {visibility} km"
                
                return weather_report
            else:
                return f"Weather data not available for '{location}'"
                
        except ImportError:
            return "Weather feature requires: pip install requests"
        except requests.exceptions.RequestException:
            return "Weather service unavailable (check internet connection)"
        except Exception as e:
            return f"Weather forecast failed: {e}"
    
    def password_generator(self, length=12):
        import random, string
        chars = string.ascii_letters + string.digits + "!@#$%^&*"
        password = ''.join(random.choice(chars) for _ in range(length))
        return f"Generated password: {password}"
    
    def color_picker(self):
        try:
            import pyautogui
            x, y = pyautogui.position()
            screenshot = pyautogui.screenshot()
            color = screenshot.getpixel((x, y))
            hex_color = "#{:02x}{:02x}{:02x}".format(color[0], color[1], color[2])
            return f"Color at cursor: RGB{color} | HEX: {hex_color}"
        except Exception as e:
            return f"Color picker failed: {e}"
    
    # def text_to_speech_file(self, text="Hello from Jarvis"):
    #     try:
    #         import pyttsx3
    #         engine = pyttsx3.init()
            
    #         voices = engine.getProperty('voices')
    #         if voices:
    #             engine.setProperty('voice', voices[0].id)
    #         engine.setProperty('rate', 150)
    #         engine.setProperty('volume', 0.9)
            
    #         filename = f"speech_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.wav"
    #         engine.save_to_file(text, filename)
    #         engine.runAndWait()
            
    #         return f"üîä Audio file created: '{filename}' | Text: '{text[:50]}...'" if len(text) > 50 else f"üîä Audio file created: '{filename}' | Text: '{text}'"
    #     except Exception as e:
    #         return f"Text-to-speech failed: {e}"
    
    def image_converter(self, input_file="image.jpg", output_format="png"):
        try:
            from PIL import Image
            if not os.path.exists(input_file):
                return f"Image file '{input_file}' not found"
            
            output_format = output_format.replace('.', '').lower()
            
            img = Image.open(input_file)
            output_file = f"{os.path.splitext(input_file)[0]}.{output_format}"
            
            if output_format in ['jpg', 'jpeg']:
                img = img.convert('RGB')
            
            img.save(output_file)
            return f"‚úÖ Converted '{input_file}' to '{output_file}'"
        except Exception as e:
            return f"Image conversion failed: {e}"
    
    def empty_trash(self):
        try:
            subprocess.run('powershell -c "Clear-RecycleBin -Force"', shell=True)
            return "Recycle bin emptied successfully"
        except Exception as e:
            return f"Empty trash failed: {e}"
    
    def pomodoro_timer(self):
        self._show_notification("üçÖ Pomodoro Started", "Working for 25 minutes...")
        
        def timer():
            time.sleep(1500)
            self._show_notification("üçÖ Pomodoro Complete!", "Take a 5-minute break. Great work!")
        
        threading.Thread(target=timer, daemon=True).start()
        return "üçÖ 25-minute Pomodoro timer started - Check your notification!"
    
    def break_reminder(self, minutes=30):
        if minutes <= 0 or minutes > 480:
            minutes = 30
        
        self._show_notification("‚è∞ Break Reminder Set", f"Will remind you in {minutes} minutes")
        
        def reminder():
            time.sleep(minutes * 60)
            self._show_notification("‚è∞ Break Time!", f"You've been working for {minutes} minutes. Time for a break!")
        
        threading.Thread(target=reminder, daemon=True).start()
        return f"‚è∞ Break reminder set for {minutes} minutes - Check your notification!"

    def pomodoro_test(self):
        self._show_notification("üçÖ TEST: Pomodoro Started", "Will complete in 10 seconds...")
        
        def test_timer():
            time.sleep(10)
            self._show_notification("üçÖ TEST: Pomodoro Complete!", "This was a 10-second test.")
        
        threading.Thread(target=test_timer, daemon=True).start()
        return "üçÖ TEST: 10-second Pomodoro timer started - Check notifications!"
    
    def _show_notification(self, title, message):
        try:
            import tkinter as tk
            from tkinter import messagebox
            
            root = tk.Tk()
            root.withdraw()
            root.attributes('-topmost', True)
            
            messagebox.showinfo(title, message)
            root.destroy()
        except Exception as e:
            print(f"NOTIFICATION: {title} - {message}")
    
    def word_count(self):
        try:
            import pyperclip
            text = pyperclip.paste()
            words = len(text.split())
            chars = len(text)
            return f"Word count: {words} words, {chars} characters"
        except Exception as e:
            return f"Word count failed: {e}"
    
    def text_cleaner(self):
        try:
            import pyperclip, re
            text = pyperclip.paste()
            cleaned = re.sub(r'\s+', ' ', text).strip()
            pyperclip.copy(cleaned)
            return "Text cleaned and copied to clipboard"
        except Exception as e:
            return f"Text cleaner failed: {e}"
    
    def url_shortener(self, url="https://example.com"):
        try:
            import urllib.parse, urllib.request
            
            parsed = urllib.parse.urlparse(url)
            if not parsed.scheme:
                url = 'https://' + url
            
            api_url = f"http://tinyurl.com/api-create.php?url={urllib.parse.quote(url)}"
            response = urllib.request.urlopen(api_url)
            short_url = response.read().decode('utf-8')
            
            try:
                import pyperclip
                pyperclip.copy(short_url)
                clipboard_msg = " (copied to clipboard)"
            except:
                clipboard_msg = ""
            
            return f"üîó Short URL: {short_url}{clipboard_msg}"
        except Exception as e:
            return f"URL shortener failed: {e}"
    
    def duplicate_finder(self, folder=None):
        try:
            if folder is None:
                folder = "."
            import hashlib
            files = {}
            duplicates = []
            for root, dirs, filenames in os.walk(folder):
                for filename in filenames:
                    filepath = os.path.join(root, filename)
                    try:
                        with open(filepath, 'rb') as f:
                            file_hash = hashlib.md5(f.read()).hexdigest()
                        if file_hash in files:
                            duplicates.append((filepath, files[file_hash]))
                        else:
                            files[file_hash] = filepath
                    except:
                        continue
            return f"Found {len(duplicates)} duplicate file pairs in {folder}"
        except Exception as e:
            return f"Duplicate finder failed: {e}"
    
    def file_organizer(self, query=""):
        try:
            # Determine target folder based on query
            folder = None
            if 'documents' in query.lower():
                folder = os.path.join(os.path.expanduser("~"), "Documents")
            elif 'downloads' in query.lower():
                folder = os.path.join(os.path.expanduser("~"), "Downloads")
            elif 'desktop' in query.lower():
                folder = os.path.join(os.path.expanduser("~"), "Desktop")
            else:
                # Default to Downloads if no specific folder mentioned
                folder = os.path.join(os.path.expanduser("~"), "Downloads")
            
            # Enhanced file type categorization
            extensions = {
                'Images': ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.webp', '.svg', '.ico'],
                'Documents': ['.pdf', '.doc', '.docx', '.txt', '.rtf', '.odt', '.xls', '.xlsx', '.ppt', '.pptx'],
                'Videos': ['.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm', '.m4v'],
                'Music': ['.mp3', '.wav', '.flac', '.aac', '.ogg', '.wma', '.m4a'],
                'Archives': ['.zip', '.rar', '.7z', '.tar', '.gz', '.bz2'],
                'Programs': ['.exe', '.msi', '.dmg', '.deb', '.rpm', '.app'],
                'Code': ['.py', '.js', '.html', '.css', '.java', '.cpp', '.c', '.php', '.rb']
            }
            
            if not os.path.exists(folder):
                return f"Folder not found: {folder}"
            
            organized = 0
            total_files = 0
            
            for filename in os.listdir(folder):
                filepath = os.path.join(folder, filename)
                if os.path.isfile(filepath):
                    total_files += 1
                    ext = os.path.splitext(filename)[1].lower()
                    
                    for folder_name, exts in extensions.items():
                        if ext in exts:
                            # Create organized folder
                            organized_folder = os.path.join(folder, folder_name)
                            os.makedirs(organized_folder, exist_ok=True)
                            
                            # Move file to organized folder
                            new_path = os.path.join(organized_folder, filename)
                            if not os.path.exists(new_path):
                                os.rename(filepath, new_path)
                                organized += 1
                            break
            
            result = f"üìÅ File Organization Complete!\n"
            result += f"Folder: {folder}\n"
            result += f"Total files: {total_files}\n"
            result += f"Organized: {organized} files\n"
            result += f"Remaining: {total_files - organized} files (unknown types)"
            
            if organized > 0:
                self._show_notification("Files Organized", f"Organized {organized} files in {os.path.basename(folder)}")
            
            return result
            
        except Exception as e:
            return f"File organizer failed: {e}"
    
    def batch_rename(self, folder=None, prefix="file_"):
        try:
            if folder is None:
                folder = "."
            count = 0
            for i, filename in enumerate(os.listdir(folder)):
                if os.path.isfile(os.path.join(folder, filename)):
                    ext = os.path.splitext(filename)[1]
                    new_name = f"{prefix}{i+1:03d}{ext}"
                    old_path = os.path.join(folder, filename)
                    new_path = os.path.join(folder, new_name)
                    if not os.path.exists(new_path):
                        os.rename(old_path, new_path)
                        count += 1
            return f"Renamed {count} files with prefix '{prefix}' in {folder}"
        except Exception as e:
            return f"Batch rename failed: {e}"
    
    def folder_size(self, folder=None):
        try:
            if folder is None:
                folder = "."
            total_size = 0
            for dirpath, dirnames, filenames in os.walk(folder):
                for filename in filenames:
                    filepath = os.path.join(dirpath, filename)
                    try:
                        total_size += os.path.getsize(filepath)
                    except:
                        continue
            size_mb = total_size / (1024 * 1024)
            return f"Folder size: {size_mb:.2f} MB ({total_size:,} bytes) in {folder}"
        except Exception as e:
            return f"Folder size calculation failed: {e}"
    
    def recent_files(self, count=10, folder=None):
        try:
            if folder is None:
                folder = "."
            recent = []
            for root, dirs, files in os.walk(folder):
                for file in files:
                    filepath = os.path.join(root, file)
                    try:
                        mtime = os.path.getmtime(filepath)
                        recent.append((filepath, mtime))
                    except:
                        continue
            recent.sort(key=lambda x: x[1], reverse=True)
            result = f"Recent {count} files in {folder}:\n"
            for filepath, mtime in recent[:count]:
                result += f"- {os.path.basename(filepath)}\n"
            return result
        except Exception as e:
            return f"Recent files failed: {e}"
    
    def qr_code_generator(self, query=""):
        try:
            import qrcode
            from PIL import Image
            import re
            
            # Extract text from query
            text = "Hello World"  # default
            if query:
                # Try to extract text after "qr" or "generate qr"
                text_match = re.search(r'(?:qr|generate qr|qr code)\s+(.+)', query.lower())
                if text_match:
                    text = text_match.group(1).strip()
                elif len(query.strip()) > 0:
                    # If no specific pattern, use the whole query as text
                    text = query.strip()
            
            qr = qrcode.QRCode(
                version=1,
                error_correction=qrcode.constants.ERROR_CORRECT_H,
                box_size=10,
                border=4,
            )
            qr.add_data(text)
            qr.make(fit=True)
            
            img = qr.make_image(fill_color="#0078FF", back_color="white").convert('RGB')
            
            filename = f"jarvis_qr_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
            img.save(filename)
            return f"‚úÖ QR Code generated for '{text}': {filename}"
            
        except ImportError:
            return "QR code library not installed. Run: pip install qrcode[pil] pillow"
        except Exception as e:
            return f"QR code generation failed: {str(e)}"
    
    def compress_files(self, folder=None, output_name=None):
        try:
            import zipfile
            if folder is None:
                folder = "."
            if output_name is None:
                output_name = f"archive_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.zip"
            
            with zipfile.ZipFile(output_name, 'w', zipfile.ZIP_DEFLATED) as zipf:
                for root, dirs, files in os.walk(folder):
                    for file in files:
                        file_path = os.path.join(root, file)
                        arcname = os.path.relpath(file_path, folder)
                        zipf.write(file_path, arcname)
            
            return f"üì¶ Compressed {folder} to {output_name}"
        except Exception as e:
            return f"Compression failed: {e}"
    
    def extract_archive(self, archive_path=None, extract_to=None):
        try:
            if archive_path is None:
                return "Please specify archive path"
            if extract_to is None:
                extract_to = os.path.splitext(archive_path)[0]
            
            os.makedirs(extract_to, exist_ok=True)
            
            if archive_path.lower().endswith('.zip'):
                import zipfile
                with zipfile.ZipFile(archive_path, 'r') as zipf:
                    zipf.extractall(extract_to)
                return f"üìÇ Extracted ZIP to {extract_to}"
            elif archive_path.lower().endswith('.rar'):
                try:
                    import rarfile
                    with rarfile.RarFile(archive_path, 'r') as rarf:
                        rarf.extractall(extract_to)
                    return f"üìÇ Extracted RAR to {extract_to}"
                except ImportError:
                    return "RAR support not installed. Run: pip install rarfile"
            else:
                return "Unsupported archive format. Supports ZIP and RAR only."
        except Exception as e:
            return f"Extraction failed: {e}"
    
    def merge_pdf(self, pdf_files=None):
        try:
            from PyPDF2 import PdfMerger
            if not pdf_files:
                return "Please specify PDF files to merge"
            
            merger = PdfMerger()
            for pdf in pdf_files:
                if os.path.exists(pdf):
                    merger.append(pdf)
            
            output_name = f"merged_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
            merger.write(output_name)
            merger.close()
            return f"üìÑ Merged {len(pdf_files)} PDFs into {output_name}"
        except ImportError:
            return "PDF library not installed. Run: pip install PyPDF2"
        except Exception as e:
            return f"PDF merge failed: {e}"
    
    def split_pdf(self, pdf_file=None, page_range=None):
        try:
            from PyPDF2 import PdfReader, PdfWriter
            if not pdf_file or not os.path.exists(pdf_file):
                return "Please specify valid PDF file"
            
            reader = PdfReader(pdf_file)
            base_name = os.path.splitext(pdf_file)[0]
            
            if page_range:
                # Parse page range (e.g., "1-3", "2,4,6", "5")
                pages_to_split = []
                if '-' in page_range:
                    start, end = map(int, page_range.split('-'))
                    pages_to_split = list(range(start-1, min(end, len(reader.pages))))
                elif ',' in page_range:
                    pages_to_split = [int(p.strip())-1 for p in page_range.split(',') if int(p.strip())-1 < len(reader.pages)]
                else:
                    page_num = int(page_range) - 1
                    if 0 <= page_num < len(reader.pages):
                        pages_to_split = [page_num]
                
                for i in pages_to_split:
                    writer = PdfWriter()
                    writer.add_page(reader.pages[i])
                    output_name = f"{base_name}_page_{i+1}.pdf"
                    with open(output_name, 'wb') as output_file:
                        writer.write(output_file)
                
                return f"üìÑ Split {len(pages_to_split)} pages from PDF"
            else:
                # Split all pages
                for i, page in enumerate(reader.pages):
                    writer = PdfWriter()
                    writer.add_page(page)
                    output_name = f"{base_name}_page_{i+1}.pdf"
                    with open(output_name, 'wb') as output_file:
                        writer.write(output_file)
                
                return f"üìÑ Split PDF into {len(reader.pages)} pages"
        except ImportError:
            return "PDF library not installed. Run: pip install PyPDF2"
        except Exception as e:
            return f"PDF split failed: {e}"
    
    def pdf_to_text(self, pdf_file=None):
        try:
            from PyPDF2 import PdfReader
            if not pdf_file or not os.path.exists(pdf_file):
                return "Please specify valid PDF file"
            
            reader = PdfReader(pdf_file)
            text = ""
            for page in reader.pages:
                text += page.extract_text() + "\n"
            
            output_name = f"{os.path.splitext(pdf_file)[0]}.txt"
            with open(output_name, 'w', encoding='utf-8') as f:
                f.write(text)
            
            return f"üìù Extracted text to {output_name}"
        except ImportError:
            return "PDF library not installed. Run: pip install PyPDF2"
        except Exception as e:
            return f"PDF to text failed: {e}"
    
    def pdf_to_images(self, pdf_file=None):
        try:
            try:
                import fitz  # PyMuPDF
            except ImportError:
                return "PDF library not installed. Run: pip install PyMuPDF"
            
            if not pdf_file or not os.path.exists(pdf_file):
                return "Please specify valid PDF file"
            
            doc = fitz.open(pdf_file)
            base_name = os.path.splitext(pdf_file)[0]
            
            for page_num in range(len(doc)):
                page = doc.load_page(page_num)
                pix = page.get_pixmap()
                output_name = f"{base_name}_page_{page_num+1}.png"
                pix.save(output_name)
            
            doc.close()
            return f"üñºÔ∏è Converted PDF to {len(doc)} images"
        except Exception as e:
            return f"PDF to images failed: {e}"
    
    def images_to_pdf(self, image_folder=None):
        try:
            from PIL import Image
            if not image_folder:
                image_folder = "."
            
            images = []
            for file in os.listdir(image_folder):
                if file.lower().endswith(('.png', '.jpg', '.jpeg', '.bmp', '.gif')):
                    img_path = os.path.join(image_folder, file)
                    img = Image.open(img_path).convert('RGB')
                    images.append(img)
            
            if images:
                output_name = f"images_to_pdf_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
                images[0].save(output_name, save_all=True, append_images=images[1:])
                return f"üìÑ Created PDF from {len(images)} images: {output_name}"
            else:
                return "No images found in folder"
        except ImportError:
            return "PIL library not installed. Run: pip install Pillow"
        except Exception as e:
            return f"Images to PDF failed: {e}"
    
    def word_to_pdf(self, doc_file=None):
        try:
            import win32com.client
            if not doc_file or not os.path.exists(doc_file):
                return "Please specify valid Word document"
            
            word = win32com.client.Dispatch("Word.Application")
            word.Visible = False
            doc = word.Documents.Open(os.path.abspath(doc_file))
            output_name = f"{os.path.splitext(doc_file)[0]}.pdf"
            doc.SaveAs(os.path.abspath(output_name), FileFormat=17)
            doc.Close()
            word.Quit()
            
            return f"üìÑ Converted Word to PDF: {output_name}"
        except ImportError:
            return "Word automation not available. Install: pip install pywin32"
        except Exception as e:
            return f"Word to PDF failed: {e}"
    
    def excel_to_pdf(self, excel_file=None):
        try:
            import win32com.client
            if not excel_file or not os.path.exists(excel_file):
                return "Please specify valid Excel file"
            
            excel = win32com.client.Dispatch("Excel.Application")
            excel.Visible = False
            wb = excel.Workbooks.Open(os.path.abspath(excel_file))
            output_name = f"{os.path.splitext(excel_file)[0]}.pdf"
            wb.ExportAsFixedFormat(0, os.path.abspath(output_name))
            wb.Close()
            excel.Quit()
            
            return f"üìÑ Converted Excel to PDF: {output_name}"
        except ImportError:
            return "Excel automation not available. Install: pip install pywin32"
        except Exception as e:
            return f"Excel to PDF failed: {e}"
    
    def powerpoint_to_pdf(self, ppt_file=None):
        try:
            import win32com.client
            if not ppt_file or not os.path.exists(ppt_file):
                return "Please specify valid PowerPoint file"
            
            ppt = win32com.client.Dispatch("PowerPoint.Application")
            ppt.Visible = 1
            presentation = ppt.Presentations.Open(os.path.abspath(ppt_file))
            output_name = f"{os.path.splitext(ppt_file)[0]}.pdf"
            presentation.SaveAs(os.path.abspath(output_name), 32)
            presentation.Close()
            ppt.Quit()
            
            return f"üìÑ Converted PowerPoint to PDF: {output_name}"
        except ImportError:
            return "PowerPoint automation not available. Install: pip install pywin32"
        except Exception as e:
            return f"PowerPoint to PDF failed: {e}"
    
    def html_to_pdf(self, html_file=None):
        try:
            import pdfkit
            if not html_file or not os.path.exists(html_file):
                return "Please specify valid HTML file"
            
            output_name = f"{os.path.splitext(html_file)[0]}.pdf"
            pdfkit.from_file(html_file, output_name)
            
            return f"üìÑ Converted HTML to PDF: {output_name}"
        except ImportError:
            return "HTML to PDF library not installed. Run: pip install pdfkit"
        except Exception as e:
            return f"HTML to PDF failed: {e}"
    
    def text_to_pdf(self, text_file=None):
        try:
            from reportlab.pdfgen import canvas
            from reportlab.lib.pagesizes import letter
            
            if not text_file or not os.path.exists(text_file):
                return "Please specify valid text file"
            
            with open(text_file, 'r', encoding='utf-8') as f:
                text = f.read()
            
            output_name = f"{os.path.splitext(text_file)[0]}.pdf"
            c = canvas.Canvas(output_name, pagesize=letter)
            
            lines = text.split('\n')
            y = 750
            for line in lines:
                if y < 50:
                    c.showPage()
                    y = 750
                c.drawString(50, y, line[:80])
                y -= 15
            
            c.save()
            return f"üìÑ Converted text to PDF: {output_name}"
        except ImportError:
            return "PDF library not installed. Run: pip install reportlab"
        except Exception as e:
            return f"Text to PDF failed: {e}"
    
    def pdf_encrypt(self, pdf_file=None, password="jarvis123"):
        try:
            from PyPDF2 import PdfReader, PdfWriter
            if not pdf_file or not os.path.exists(pdf_file):
                return "Please specify valid PDF file"
            
            reader = PdfReader(pdf_file)
            writer = PdfWriter()
            
            for page in reader.pages:
                writer.add_page(page)
            
            writer.encrypt(password)
            output_name = f"{os.path.splitext(pdf_file)[0]}_encrypted.pdf"
            
            with open(output_name, 'wb') as output_file:
                writer.write(output_file)
            
            return f"üîí Encrypted PDF: {output_name} (password: {password})"
        except ImportError:
            return "PDF library not installed. Run: pip install PyPDF2"
        except Exception as e:
            return f"PDF encryption failed: {e}"
    
    def pdf_decrypt(self, pdf_file=None, password="jarvis123"):
        try:
            from PyPDF2 import PdfReader, PdfWriter
            if not pdf_file or not os.path.exists(pdf_file):
                return "Please specify valid PDF file"
            
            reader = PdfReader(pdf_file)
            if reader.is_encrypted:
                reader.decrypt(password)
            
            writer = PdfWriter()
            for page in reader.pages:
                writer.add_page(page)
            
            output_name = f"{os.path.splitext(pdf_file)[0]}_decrypted.pdf"
            with open(output_name, 'wb') as output_file:
                writer.write(output_file)
            
            return f"üîì Decrypted PDF: {output_name}"
        except ImportError:
            return "PDF library not installed. Run: pip install PyPDF2"
        except Exception as e:
            return f"PDF decryption failed: {e}"
    
    def pdf_compress(self, pdf_file=None):
        try:
            from PyPDF2 import PdfReader, PdfWriter
            if not pdf_file or not os.path.exists(pdf_file):
                return "Please specify valid PDF file"
            
            reader = PdfReader(pdf_file)
            writer = PdfWriter()
            
            for page in reader.pages:
                page.compress_content_streams()
                writer.add_page(page)
            
            output_name = f"{os.path.splitext(pdf_file)[0]}_compressed.pdf"
            with open(output_name, 'wb') as output_file:
                writer.write(output_file)
            
            original_size = os.path.getsize(pdf_file)
            compressed_size = os.path.getsize(output_name)
            reduction = ((original_size - compressed_size) / original_size) * 100
            
            return f"üóúÔ∏è Compressed PDF: {output_name} ({reduction:.1f}% reduction)"
        except ImportError:
            return "PDF library not installed. Run: pip install PyPDF2"
        except Exception as e:
            return f"PDF compression failed: {e}"
    
    def pdf_rotate(self, pdf_file=None, angle=90):
        try:
            from PyPDF2 import PdfReader, PdfWriter
            if not pdf_file or not os.path.exists(pdf_file):
                return "Please specify valid PDF file"
            
            reader = PdfReader(pdf_file)
            writer = PdfWriter()
            
            for page in reader.pages:
                page.rotate(angle)
                writer.add_page(page)
            
            output_name = f"{os.path.splitext(pdf_file)[0]}_rotated.pdf"
            with open(output_name, 'wb') as output_file:
                writer.write(output_file)
            
            return f"üîÑ Rotated PDF {angle}¬∞: {output_name}"
        except ImportError:
            return "PDF library not installed. Run: pip install PyPDF2"
        except Exception as e:
            return f"PDF rotation failed: {e}"
    
    def pdf_watermark(self, pdf_file=None, watermark_text="JARVIS"):
        try:
            from reportlab.pdfgen import canvas
            from reportlab.lib.pagesizes import letter
            from PyPDF2 import PdfReader, PdfWriter
            import io
            
            if not pdf_file or not os.path.exists(pdf_file):
                return "Please specify valid PDF file"
            
            # Create watermark
            packet = io.BytesIO()
            can = canvas.Canvas(packet, pagesize=letter)
            can.setFont("Helvetica", 50)
            can.setFillAlpha(0.3)
            can.rotate(45)
            can.drawString(200, 200, watermark_text)
            can.save()
            
            packet.seek(0)
            watermark_pdf = PdfReader(packet)
            
            # Apply watermark
            reader = PdfReader(pdf_file)
            writer = PdfWriter()
            
            for page in reader.pages:
                page.merge_page(watermark_pdf.pages[0])
                writer.add_page(page)
            
            output_name = f"{os.path.splitext(pdf_file)[0]}_watermarked.pdf"
            with open(output_name, 'wb') as output_file:
                writer.write(output_file)
            
            return f"üíß Added watermark to PDF: {output_name}"
        except ImportError:
            return "PDF libraries not installed. Run: pip install PyPDF2 reportlab"
        except Exception as e:
            return f"PDF watermark failed: {e}"
    
    def email_templates(self, query=""):
        try:
            # Check if user wants AI-generated email
            if 'write email' in query.lower() or 'compose email' in query.lower():
                return self._generate_ai_email(query)
            
            # Use predefined templates
            templates = {
                'meeting': "Subject: Meeting Request\n\nHi [Name],\n\nI'd like to schedule a meeting to discuss [Topic]. Are you available [Date/Time]?\n\nBest regards,\n[Your Name]",
                'followup': "Subject: Follow-up on [Topic]\n\nHi [Name],\n\nI wanted to follow up on our previous discussion about [Topic]. Please let me know if you need any additional information.\n\nBest regards,\n[Your Name]",
                'thankyou': "Subject: Thank You\n\nHi [Name],\n\nThank you for [Reason]. I really appreciate your time and assistance.\n\nBest regards,\n[Your Name]",
                'apology': "Subject: Apology\n\nHi [Name],\n\nI apologize for [Issue]. I will ensure this doesn't happen again in the future.\n\nBest regards,\n[Your Name]",
                'outofoffice': "Subject: Out of Office\n\nI am currently out of the office from [Start Date] to [End Date]. I will respond to your email when I return.\n\nFor urgent matters, please contact [Contact Person] at [Email/Phone]."
            }
            
            # Extract template type from query
            template_type = "meeting"  # default
            query_lower = query.lower()
            
            if 'apology' in query_lower or 'sorry' in query_lower:
                template_type = 'apology'
            elif 'followup' in query_lower or 'follow up' in query_lower:
                template_type = 'followup'
            elif 'thank' in query_lower:
                template_type = 'thankyou'
            elif 'out of office' in query_lower or 'vacation' in query_lower:
                template_type = 'outofoffice'
            elif 'meeting' in query_lower:
                template_type = 'meeting'
            
            template = templates.get(template_type, templates['meeting'])
            
            try:
                import pyperclip
                pyperclip.copy(template)
                return f"üìß Email template '{template_type}' copied to clipboard\n\n{template}"
            except ImportError:
                return f"üìß Email template '{template_type}':\n\n{template}"
        except Exception as e:
            return f"Email template failed: {e}"
    
    def _generate_ai_email(self, query):
        try:
            import re
            
            # Extract recipient name
            recipient = "there"
            name_patterns = [
                r'write email (?:to |with )?([a-zA-Z]+)',
                r'email (?:to |with )?([a-zA-Z]+)',
                r'compose email (?:to |with )?([a-zA-Z]+)'
            ]
            
            for pattern in name_patterns:
                match = re.search(pattern, query.lower())
                if match:
                    recipient = match.group(1).capitalize()
                    break
            
            # Use AI to generate email content
            try:
                from engine.dual_ai import dual_ai
                
                prompt = f"Write a professional email. User request: '{query}'. Recipient name: '{recipient}'. Include subject line and proper email format. Keep it concise and professional."
                
                if dual_ai.ai_provider == 'groq':
                    response = dual_ai.groq_client.chat.completions.create(
                        messages=[{"role": "user", "content": prompt}],
                        model="llama-3.1-8b-instant"
                    )
                    email_content = response.choices[0].message.content.strip()
                else:
                    response = dual_ai.gemini_model.generate_content(prompt)
                    email_content = response.text.strip()
                
                # Copy to clipboard
                try:
                    import pyperclip
                    pyperclip.copy(email_content)
                    return f"üìß AI-generated email copied to clipboard\n\n{email_content}"
                except ImportError:
                    return f"üìß AI-generated email:\n\n{email_content}"
                    
            except Exception as ai_error:
                # Fallback to simple template
                fallback_email = f"Subject: Message for {recipient}\n\nHi {recipient},\n\nI hope this email finds you well. I wanted to reach out regarding our recent discussion.\n\nPlease let me know if you have any questions or if there's anything I can help you with.\n\nBest regards,\n[Your Name]"
                
                try:
                    import pyperclip
                    pyperclip.copy(fallback_email)
                    return f"üìß Email generated (AI unavailable) copied to clipboard\n\n{fallback_email}"
                except ImportError:
                    return f"üìß Email generated (AI unavailable):\n\n{fallback_email}"
                    
        except Exception as e:
            return f"AI email generation failed: {e}"
    
    def meeting_scheduler(self, query=""):
        try:
            import webbrowser, re
            from datetime import datetime, timedelta
            
            # Extract duration from query
            duration = "1 hour"  # default
            duration_match = re.search(r'(\d+)\s*(hour|hours|minute|minutes)', query.lower())
            if duration_match:
                duration = f"{duration_match.group(1)} {duration_match.group(2)}"
            
            # Extract participants from query
            participants = "team"  # default
            if 'with' in query.lower():
                parts = query.lower().split('with')
                if len(parts) > 1:
                    participants = parts[1].strip()
            
            # Generate meeting details
            now = datetime.now()
            suggested_time = now + timedelta(days=1)
            meeting_link = "https://meet.google.com/new"
            
            meeting_details = f"""Meeting Scheduler
            
Suggested Time: {suggested_time.strftime('%Y-%m-%d %H:%M')}
Duration: {duration}
Participants: {participants}
Meeting Link: {meeting_link}
            
Calendar Integration:
- Google Calendar: https://calendar.google.com
- Outlook: https://outlook.live.com/calendar
            
Meeting opened in browser for scheduling."""
            
            # Open Google Meet in browser
            webbrowser.open(meeting_link)
            
            return meeting_details
        except Exception as e:
            return f"Meeting scheduler failed: {e}"
    
    def task_reminder(self, query=""):
        try:
            import re, json, os
            from datetime import datetime, timedelta
            
            # Create reminders file in current directory
            reminders_file = "reminders.json"
            
            # Extract task from query
            task = "Take a break"  # default
            if 'remind me to' in query.lower():
                task_match = re.search(r'remind me to (.+?)(?:\s+in|$)', query.lower())
                if task_match:
                    task = task_match.group(1).strip()
            elif 'reminder' in query.lower() and len(query.split()) > 2:
                words = query.split()
                if 'reminder' in [w.lower() for w in words]:
                    idx = [w.lower() for w in words].index('reminder')
                    if idx + 1 < len(words):
                        task = ' '.join(words[idx+1:]).strip()
            
            # Extract time from query
            seconds = 1800  # default 30 minutes
            time_match = re.search(r'(\d+)\s*(second|seconds|minute|minutes|hour|hours)', query.lower())
            if time_match:
                num = int(time_match.group(1))
                unit = time_match.group(2)
                if 'hour' in unit:
                    seconds = num * 3600
                elif 'second' in unit:
                    seconds = num
                else:  # minutes
                    seconds = num * 60
            
            if seconds <= 0 or seconds > 201600:  # max 56 hours
                seconds = 1800
            
            # Calculate reminder time
            reminder_time = datetime.now() + timedelta(seconds=seconds)
            
            # Save reminder to JSON
            reminder_data = {
                "task": task,
                "reminder_time": reminder_time.isoformat(),
                "created_at": datetime.now().isoformat(),
                "seconds": seconds
            }
            
            # Load existing reminders
            reminders = []
            if os.path.exists(reminders_file):
                try:
                    with open(reminders_file, 'r') as f:
                        reminders = json.load(f)
                except:
                    reminders = []
            
            reminders.append(reminder_data)
            
            # Save updated reminders
            with open(reminders_file, 'w') as f:
                json.dump(reminders, f, indent=2)
            
            self._show_notification("Task Reminder Set", f"Will remind you to '{task}' in {seconds} seconds")
            
            def reminder():
                time.sleep(seconds)
                self._show_notification("Task Reminder!", f"Time to: {task}")
                
                # Remove completed reminder
                try:
                    if os.path.exists(reminders_file):
                        with open(reminders_file, 'r') as f:
                            current_reminders = json.load(f)
                        updated_reminders = [r for r in current_reminders if r != reminder_data]
                        with open(reminders_file, 'w') as f:
                            json.dump(updated_reminders, f, indent=2)
                except:
                    pass
            
            threading.Thread(target=reminder, daemon=True).start()
            
            return f"Task reminder set: '{task}' at {reminder_time.strftime('%H:%M:%S')} ({seconds} seconds)"
        except Exception as e:
            return f"Task reminder failed: {e}"
    
    def list_reminders(self, query=""):
        try:
            import json, os
            from datetime import datetime
            
            reminders_file = "reminders.json"
            
            if not os.path.exists(reminders_file):
                return "No reminders found. Create your first reminder!"
            
            with open(reminders_file, 'r') as f:
                reminders = json.load(f)
            
            if not reminders:
                return "No active reminders found."
            
            result = "Active Reminders:\n" + "="*30 + "\n"
            
            for i, reminder in enumerate(reminders, 1):
                task = reminder.get('task', 'Unknown task')
                reminder_time = datetime.fromisoformat(reminder.get('reminder_time', ''))
                created_at = datetime.fromisoformat(reminder.get('created_at', ''))
                
                now = datetime.now()
                if reminder_time > now:
                    time_left = reminder_time - now
                    minutes_left = int(time_left.total_seconds() / 60)
                    if minutes_left > 60:
                        hours = minutes_left // 60
                        mins = minutes_left % 60
                        time_str = f"{hours}h {mins}m remaining"
                    else:
                        time_str = f"{minutes_left}m remaining"
                    status = "ACTIVE"
                else:
                    time_str = "OVERDUE"
                    status = "OVERDUE"
                
                result += f"{i}. [{status}] {task}\n"
                result += f"   {time_str}\n"
                result += f"   Due: {reminder_time.strftime('%H:%M')}\n\n"
            
            result += f"Total: {len(reminders)} reminders"
            return result
        except Exception as e:
            return f"Failed to list reminders: {e}"
    
    def image_editor(self, query=""):
        try:
            try:
                from PIL import Image, ImageFilter, ImageEnhance
            except ImportError:
                return "Image library not installed. Run: pip install Pillow"
            
            import re
            
            # Extract file path from query
            file_match = re.search(r'(?:edit|image)\s+(.+?)(?:\s+(?:blur|sharp|bright|contrast|gray|resize)|$)', query.lower())
            if file_match:
                file_path = file_match.group(1).strip()
            else:
                return "Please specify image file: 'image editor filename.jpg blur'"
            
            if not os.path.exists(file_path):
                return f"Image file not found: {file_path}"
            
            img = Image.open(file_path)
            base_name = os.path.splitext(file_path)[0]
            
            # Apply filters based on query
            if 'blur' in query.lower():
                img = img.filter(ImageFilter.BLUR)
                output = f"{base_name}_blur.jpg"
            elif 'sharpen' in query.lower():
                img = img.filter(ImageFilter.SHARPEN)
                output = f"{base_name}_sharp.jpg"
            elif 'bright' in query.lower():
                enhancer = ImageEnhance.Brightness(img)
                img = enhancer.enhance(1.5)
                output = f"{base_name}_bright.jpg"
            elif 'contrast' in query.lower():
                enhancer = ImageEnhance.Contrast(img)
                img = enhancer.enhance(1.5)
                output = f"{base_name}_contrast.jpg"
            elif 'grayscale' in query.lower() or 'gray' in query.lower():
                img = img.convert('L')
                output = f"{base_name}_gray.jpg"
            elif 'resize' in query.lower():
                img = img.resize((800, 600))
                output = f"{base_name}_resized.jpg"
            else:
                # Default: apply multiple filters
                img = img.filter(ImageFilter.ENHANCE)
                output = f"{base_name}_enhanced.jpg"
            
            img.save(output)
            return f"üñºÔ∏è Image edited: {output}"
        except Exception as e:
            return f"Image editor failed: {e}"
    
    def audio_converter(self, query=""):
        try:
            try:
                from pydub import AudioSegment
            except ImportError:
                return "Audio library not installed. Run: pip install pydub"
            
            import re
            
            # Extract file path from query
            file_match = re.search(r'(?:convert|audio)\s+(.+?)(?:\s+(?:to|mp3|wav|flac|aac|ogg)|$)', query.lower())
            if file_match:
                file_path = file_match.group(1).strip()
            else:
                return "Please specify audio file: 'audio converter song.mp3 to wav'"
            
            if not os.path.exists(file_path):
                return f"Audio file not found: {file_path}"
            
            # Detect input format
            input_ext = os.path.splitext(file_path)[1].lower()
            base_name = os.path.splitext(file_path)[0]
            
            # Determine output format from query
            if 'mp3' in query.lower():
                output_format = 'mp3'
            elif 'wav' in query.lower():
                output_format = 'wav'
            elif 'flac' in query.lower():
                output_format = 'flac'
            elif 'aac' in query.lower():
                output_format = 'aac'
            elif 'ogg' in query.lower():
                output_format = 'ogg'
            else:
                output_format = 'mp3'  # default
            
            # Load and convert audio
            audio = AudioSegment.from_file(file_path)
            output_path = f"{base_name}.{output_format}"
            
            # Export with format-specific settings
            if output_format == 'mp3':
                audio.export(output_path, format="mp3", bitrate="192k")
            elif output_format == 'wav':
                audio.export(output_path, format="wav")
            elif output_format == 'flac':
                audio.export(output_path, format="flac")
            else:
                audio.export(output_path, format=output_format)
            
            return f"üéµ Audio converted to {output_format.upper()}: {output_path}"
        except Exception as e:
            return f"Audio converter failed: {e}"
    
    def video_downloader(self, query=""):
        try:
            try:
                import yt_dlp
            except ImportError:
                return "Video downloader not installed. Run: pip install yt-dlp"
            
            import re
            
            # Extract URL from query
            url_pattern = r'https?://[^\s]+'
            url_match = re.search(url_pattern, query)
            
            if not url_match:
                return "Please provide video URL: 'video downloader https://youtube.com/watch?v=...'"
            
            url = url_match.group()
            
            # Configure download options
            ydl_opts = {
                'format': 'best[height<=720]',  # Max 720p for faster download
                'outtmpl': '%(title)s.%(ext)s',
                'noplaylist': True,
            }
            
            # Determine quality from query
            if 'audio' in query.lower() or 'mp3' in query.lower():
                ydl_opts['format'] = 'bestaudio/best'
                ydl_opts['postprocessors'] = [{
                    'key': 'FFmpegExtractAudio',
                    'preferredcodec': 'mp3',
                    'preferredquality': '192',
                }]
            elif '1080' in query.lower():
                ydl_opts['format'] = 'best[height<=1080]'
            elif '480' in query.lower():
                ydl_opts['format'] = 'best[height<=480]'
            
            # Download video
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info = ydl.extract_info(url, download=False)
                title = info.get('title', 'Unknown')
                
                ydl.download([url])
                
            return f"üìπ Downloaded: {title[:50]}..."
        except Exception as e:
            return f"Video download failed: {e}"
    
    def voice_recorder(self, query=""):
        try:
            import pyaudio
            import wave
            import threading
            import time
            from datetime import datetime
            
            # Extract duration from query (default 30 seconds)
            duration = 30
            import re
            duration_match = re.search(r'(\d+)\s*(second|seconds|minute|minutes)', query.lower())
            if duration_match:
                num = int(duration_match.group(1))
                unit = duration_match.group(2)
                if 'minute' in unit:
                    duration = num * 60
                else:
                    duration = num
            
            # Generate filename
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"voice_memo_{timestamp}.wav"
            
            # Immediate response with voice feedback
            response_msg = f"Starting voice recording for {duration} seconds"
            
            def record_audio():
                try:
                    print(f"üé§ Recording audio for {duration} seconds...")
                    
                    # Audio settings
                    CHUNK = 1024
                    FORMAT = pyaudio.paInt16
                    CHANNELS = 1
                    RATE = 44100
                    
                    # Initialize PyAudio
                    p = pyaudio.PyAudio()
                    
                    # Start recording
                    stream = p.open(format=FORMAT,
                                  channels=CHANNELS,
                                  rate=RATE,
                                  input=True,
                                  frames_per_buffer=CHUNK)
                    
                    frames = []
                    
                    # Record audio
                    for i in range(0, int(RATE / CHUNK * duration)):
                        data = stream.read(CHUNK)
                        frames.append(data)
                    
                    # Stop recording
                    stream.stop_stream()
                    stream.close()
                    p.terminate()
                    
                    # Save audio file
                    wf = wave.open(filename, 'wb')
                    wf.setnchannels(CHANNELS)
                    wf.setsampwidth(p.get_sample_size(FORMAT))
                    wf.setframerate(RATE)
                    wf.writeframes(b''.join(frames))
                    wf.close()
                    
                    print(f"üé§ Voice recording saved: {filename}")
                    
                    # Optional: Convert to text using speech recognition
                    if 'text' in query.lower() or 'transcribe' in query.lower():
                        try:
                            print("üìù Converting speech to text...")
                            import speech_recognition as sr
                            r = sr.Recognizer()
                            with sr.AudioFile(filename) as source:
                                audio = r.record(source)
                            text = r.recognize_google(audio)
                            
                            # Save transcription
                            text_filename = f"transcription_{timestamp}.txt"
                            with open(text_filename, 'w', encoding='utf-8') as f:
                                f.write(text)
                            
                            print(f"üìù Transcription saved: {text_filename}")
                            print(f"Text: {text[:100]}..." if len(text) > 100 else f"Text: {text}")
                        except Exception as e:
                            print(f"üìù Transcription failed: {e}")
                        
                except Exception as e:
                    print(f"üé§ Recording failed: {e}")
            
            # Start recording in background thread
            threading.Thread(target=record_audio, daemon=True).start()
            
            return response_msg
            
        except ImportError:
            return "Audio library not installed. Run: pip install pyaudio wave"
        except Exception as e:
            return f"Voice recording failed: {e}"
    
    def screen_recorder(self, query=""):
        try:
            import cv2
            import numpy as np
            import pyautogui
            import threading
            import time
            from datetime import datetime
            
            # Extract duration from query (default 30 seconds)
            duration = 30
            import re
            duration_match = re.search(r'(\d+)\s*(second|seconds|minute|minutes)', query.lower())
            if duration_match:
                num = int(duration_match.group(1))
                unit = duration_match.group(2)
                if 'minute' in unit:
                    duration = num * 60
                else:
                    duration = num
            
            # Generate filename
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"screen_recording_{timestamp}.mp4"
            
            # Immediate response with voice feedback
            response_msg = f"Starting screen recording for {duration} seconds"
            
            def record_screen():
                try:
                    print(f"üìπ Recording screen for {duration} seconds...")
                    
                    # Get screen dimensions
                    screen_size = pyautogui.size()
                    
                    # Define codec and create VideoWriter
                    fourcc = cv2.VideoWriter_fourcc(*"mp4v")
                    fps = 20.0
                    out = cv2.VideoWriter(filename, fourcc, fps, screen_size)
                    
                    # Record screen
                    start_time = datetime.now()
                    frames_recorded = 0
                    
                    while (datetime.now() - start_time).seconds < duration:
                        # Capture screenshot
                        img = pyautogui.screenshot()
                        
                        # Convert PIL image to OpenCV format
                        frame = np.array(img)
                        frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)
                        
                        # Write frame to video
                        out.write(frame)
                        frames_recorded += 1
                        
                        # Control frame rate
                        time.sleep(1/fps)
                    
                    # Release everything
                    out.release()
                    cv2.destroyAllWindows()
                    
                    print(f"üìπ Screen recording saved: {filename} ({frames_recorded} frames)")
                    
                except Exception as e:
                    print(f"üìπ Recording failed: {e}")
            
            # Start recording in background thread
            threading.Thread(target=record_screen, daemon=True).start()
            
            return response_msg
            
        except ImportError:
            return "Screen recording libraries not installed. Run: pip install opencv-python pyautogui"
        except Exception as e:
            return f"Screen recording failed: {e}"
    
    def _load_health_data(self):
        """Load health data from JSON file"""
        default_data = {
            'water_intake': {'daily_goal': 8, 'today': 0, 'last_reminder': None, 'history': []},
            'exercise': {'sessions': [], 'weekly_goal': 5, 'current_week': 0},
            'calories': {'daily_goal': 2000, 'today': 0, 'foods': [], 'history': []},
            'sleep': {'bedtime': '22:00', 'wake_time': '06:00', 'reminders': True, 'history': []},
            'stress': {'levels': [], 'last_check': None, 'weekly_average': 0},
            'mood': {'entries': [], 'weekly_average': 0, 'last_check': None},
            'heart_rate': {'readings': [], 'resting_hr': 70, 'last_check': None},
            'medications': {'pills': [], 'reminders': []},
            'bmi': {'height': 170, 'weight': 70, 'history': []}
        }
        
        try:
            import json
            if os.path.exists('health_data.json'):
                with open('health_data.json', 'r') as f:
                    loaded_data = json.load(f)
                    # Merge with defaults to ensure all keys exist
                    for key, value in default_data.items():
                        if key not in loaded_data:
                            loaded_data[key] = value
                    return loaded_data
        except:
            pass
        
        return default_data
    
    def _save_health_data(self, data):
        """Save health data to JSON file"""
        try:
            import json
            with open('health_data.json', 'w') as f:
                json.dump(data, f, indent=2)
        except Exception as e:
            print(f"Failed to save health data: {e}")
    
    def water_reminder(self, query=""):
        try:
            import json, re
            from datetime import datetime, timedelta
            
            data = self._load_health_data()
            water_data = data['water_intake']
            
            # Check if user wants to log water intake
            if any(word in query.lower() for word in ['drink', 'drank', 'add', 'had']):
                try:
                    # Use AI to extract water amount and type
                    from engine.dual_ai import dual_ai
                    
                    ai_prompt = f'''Extract water/drink information from: "{query}"
                    
Respond ONLY in this format:
Drink: [drink type]
Amount: [number in ml]
                    
Examples:
Drink: water
Amount: 500

Drink: coffee
Amount: 250

Drink: juice
Amount: 300
                    
Convert glasses/cups to ml (1 glass = 250ml, 1 cup = 240ml, 1 liter = 1000ml).'''
                    
                    if dual_ai.ai_provider == 'groq':
                        response = dual_ai.groq_client.chat.completions.create(
                            messages=[{"role": "user", "content": ai_prompt}],
                            model="llama-3.1-8b-instant"
                        )
                        ai_response = response.choices[0].message.content.strip()
                    else:
                        response = dual_ai.gemini_model.generate_content(ai_prompt)
                        ai_response = response.text.strip()
                    
                    # Parse AI response
                    drink_match = re.search(r'Drink:\s*(.+)', ai_response, re.IGNORECASE)
                    amount_match = re.search(r'Amount:\s*(\d+)', ai_response, re.IGNORECASE)
                    
                    if drink_match and amount_match:
                        drink_type = drink_match.group(1).strip().lower()
                        amount = int(amount_match.group(1))
                        
                        # AI hydration analysis
                        hydration_value = amount if drink_type in ['water', 'herbal tea'] else amount * 0.7
                        
                        water_data['today'] += hydration_value
                        water_data['history'].append({
                            'timestamp': datetime.now().isoformat(),
                            'amount': hydration_value,
                            'drink_type': drink_type,
                            'original_amount': amount
                        })
                        
                        glasses_today = water_data['today'] / 250
                        remaining = max(0, water_data['daily_goal'] - glasses_today)
                        
                        self._save_health_data(data)
                        
                        # AI health tip
                        if drink_type not in ['water', 'herbal tea']:
                            tip = f" (Note: {drink_type} provides less hydration than pure water)"
                        else:
                            tip = " (Excellent hydration choice!)"
                        
                        self._show_notification("Hydration Logged", f"{drink_type.title()}: {amount}ml. Hydration: {hydration_value:.0f}ml")
                        
                        return f"Added {amount}ml {drink_type} (hydration value: {hydration_value:.0f}ml). Today: {glasses_today:.1f}/{water_data['daily_goal']} glasses. Remaining: {remaining:.1f}{tip}"
                    
                except Exception:
                    # Fallback to basic parsing
                    amount_match = re.search(r'(\d+)\s*(ml|glass|glasses|cup|cups|liter|liters)', query.lower())
                    if amount_match:
                        amount = int(amount_match.group(1))
                        unit = amount_match.group(2)
                        if 'glass' in unit or 'cup' in unit:
                            amount *= 250
                        elif 'liter' in unit:
                            amount *= 1000
                    else:
                        amount = 250
                    
                    water_data['today'] += amount
                    water_data['history'].append({
                        'timestamp': datetime.now().isoformat(),
                        'amount': amount
                    })
                    
                    glasses_today = water_data['today'] / 250
                    remaining = max(0, water_data['daily_goal'] - glasses_today)
                    
                    self._save_health_data(data)
                    self._show_notification("Water Logged", f"Added {amount}ml. Today: {glasses_today:.1f}/{water_data['daily_goal']} glasses")
                    
                    return f"Water logged: {amount}ml. Today: {glasses_today:.1f}/{water_data['daily_goal']} glasses. Remaining: {remaining:.1f} glasses"
            
            # Set up hourly reminders
            elif 'start' in query.lower() or 'enable' in query.lower():
                def hourly_reminder():
                    while True:
                        time.sleep(3600)  # 1 hour
                        current_data = self._load_health_data()
                        glasses_today = current_data['water_intake']['today'] / 250
                        goal = current_data['water_intake']['daily_goal']
                        
                        if glasses_today < goal:
                            remaining = goal - glasses_today
                            self._show_notification("Hydration Reminder", f"Time to drink water! {remaining:.1f} glasses remaining today")
                
                threading.Thread(target=hourly_reminder, daemon=True).start()
                return "Hourly water reminders started. Stay hydrated!"
            
            # Show current status
            else:
                glasses_today = water_data['today'] / 250
                remaining = max(0, water_data['daily_goal'] - glasses_today)
                
                status = f"Water Intake Today: {glasses_today:.1f}/{water_data['daily_goal']} glasses\n"
                status += f"Remaining: {remaining:.1f} glasses ({remaining * 250:.0f}ml)\n"
                
                if water_data['history']:
                    last_drink = water_data['history'][-1]
                    last_time = datetime.fromisoformat(last_drink['timestamp'])
                    time_ago = datetime.now() - last_time
                    hours_ago = time_ago.total_seconds() / 3600
                    status += f"Last drink: {hours_ago:.1f} hours ago"
                
                return status
                
        except Exception as e:
            return f"Water reminder failed: {e}"
    
    def exercise_timer(self, query=""):
        try:
            import re
            from datetime import datetime, timedelta
            
            data = self._load_health_data()
            exercise_data = data['exercise']
            
            try:
                # Use AI to create personalized workout
                from engine.dual_ai import dual_ai
                
                ai_prompt = f'''Create a workout plan from: "{query}"
                
Respond ONLY in this format:
Workout: [workout type]
Rounds: [number]
Work: [seconds]
Rest: [seconds]
Intensity: [Low/Medium/High]
                
Examples:
Workout: HIIT
Rounds: 5
Work: 30
Rest: 10
Intensity: High

Workout: Cardio
Rounds: 3
Work: 60
Rest: 30
Intensity: Medium
                
Adjust based on user request or use defaults for HIIT.'''
                
                if dual_ai.ai_provider == 'groq':
                    response = dual_ai.groq_client.chat.completions.create(
                        messages=[{"role": "user", "content": ai_prompt}],
                        model="llama-3.1-8b-instant"
                    )
                    ai_response = response.choices[0].message.content.strip()
                else:
                    response = dual_ai.gemini_model.generate_content(ai_prompt)
                    ai_response = response.text.strip()
                
                # Parse AI response
                workout_match = re.search(r'Workout:\s*(.+)', ai_response, re.IGNORECASE)
                rounds_match = re.search(r'Rounds:\s*(\d+)', ai_response, re.IGNORECASE)
                work_match = re.search(r'Work:\s*(\d+)', ai_response, re.IGNORECASE)
                rest_match = re.search(r'Rest:\s*(\d+)', ai_response, re.IGNORECASE)
                intensity_match = re.search(r'Intensity:\s*(.+)', ai_response, re.IGNORECASE)
                
                if all([workout_match, rounds_match, work_match, rest_match]):
                    workout_type = workout_match.group(1).strip()
                    rounds = int(rounds_match.group(1))
                    work_time = int(work_match.group(1))
                    rest_time = int(rest_match.group(1))
                    intensity = intensity_match.group(1).strip() if intensity_match else "Medium"
                else:
                    raise Exception("AI parsing failed")
                    
            except Exception:
                # Fallback to basic parsing
                work_time = 30
                rest_time = 10
                rounds = 5
                workout_type = "HIIT"
                intensity = "Medium"
                
                work_match = re.search(r'work\s+(\d+)\s*(second|seconds|minute|minutes)', query.lower())
                if work_match:
                    work_time = int(work_match.group(1))
                    if 'minute' in work_match.group(2):
                        work_time *= 60
                
                rest_match = re.search(r'rest\s+(\d+)\s*(second|seconds|minute|minutes)', query.lower())
                if rest_match:
                    rest_time = int(rest_match.group(1))
                    if 'minute' in rest_match.group(2):
                        rest_time *= 60
                
                rounds_match = re.search(r'(\d+)\s*rounds?', query.lower())
                if rounds_match:
                    rounds = int(rounds_match.group(1))
            
            # AI-enhanced workout response
            response_msg = f"Starting {workout_type}: {rounds} rounds, {work_time}s work, {rest_time}s rest ({intensity} intensity)"
            
            def hiit_timer():
                try:
                    print(f"üèÉ Starting HIIT workout: {rounds} rounds")
                    
                    for round_num in range(1, rounds + 1):
                        # Work phase
                        self._show_notification(f"üèÉ Round {round_num}/{rounds}", f"WORK! {work_time} seconds")
                        print(f"üèÉ Round {round_num}/{rounds} - WORK! {work_time}s")
                        time.sleep(work_time)
                        
                        # Rest phase (except last round)
                        if round_num < rounds:
                            self._show_notification(f"üò¥ Rest Time", f"Rest for {rest_time} seconds")
                            print(f"üò¥ Rest for {rest_time}s")
                            time.sleep(rest_time)
                    
                    # Workout complete
                    total_time = rounds * work_time + (rounds - 1) * rest_time
                    
                    # Log workout
                    exercise_data['sessions'].append({
                        'timestamp': datetime.now().isoformat(),
                        'type': 'HIIT',
                        'duration': total_time,
                        'rounds': rounds,
                        'work_time': work_time,
                        'rest_time': rest_time
                    })
                    exercise_data['current_week'] += 1
                    
                    self._save_health_data(data)
                    
                    self._show_notification("üéâ Workout Complete!", f"Great job! {total_time//60}min {total_time%60}s workout finished")
                    print(f"üéâ Workout complete! Total time: {total_time//60}min {total_time%60}s")
                    
                except Exception as e:
                    print(f"üèÉ Exercise timer failed: {e}")
            
            threading.Thread(target=hiit_timer, daemon=True).start()
            return response_msg
            
        except Exception as e:
            return f"Exercise timer failed: {e}"
    
    def calorie_calculator(self, query=""):
        try:
            import re
            from datetime import datetime
            
            data = self._load_health_data()
            calorie_data = data['calories']
            
            # Add food using AI
            if any(word in query.lower() for word in ['add', 'ate', 'eat', 'drink', 'had']):
                try:
                    # Use AI to extract food and estimate calories
                    from engine.dual_ai import dual_ai
                    
                    ai_prompt = f'''Extract food information from: "{query}"
                    
Respond ONLY in this exact format (no extra text):
Food: [food name]
Quantity: [number]
Calories: [estimated calories per serving]
                    
Examples:
Food: banana
Quantity: 2
Calories: 105

Food: sushi roll
Quantity: 1
Calories: 200

Food: chocolate cookie
Quantity: 3
Calories: 120
                    
Estimate realistic calories per serving. Always include all three lines.'''
                    
                    if dual_ai.ai_provider == 'groq':
                        response = dual_ai.groq_client.chat.completions.create(
                            messages=[{"role": "user", "content": ai_prompt}],
                            model="llama-3.1-8b-instant"
                        )
                        ai_response = response.choices[0].message.content.strip()
                    else:
                        response = dual_ai.gemini_model.generate_content(ai_prompt)
                        ai_response = response.text.strip()
                    
                    # Parse AI response
                    food_match = re.search(r'Food:\s*(.+)', ai_response, re.IGNORECASE)
                    qty_match = re.search(r'Quantity:\s*(\d+)', ai_response, re.IGNORECASE)
                    cal_match = re.search(r'Calories:\s*(\d+)', ai_response, re.IGNORECASE)
                    
                    if food_match and cal_match:
                        food_name = food_match.group(1).strip().lower()
                        quantity = int(qty_match.group(1)) if qty_match else 1
                        calories_per_serving = int(cal_match.group(1))
                        
                        total_calories = calories_per_serving * quantity
                        calorie_data['today'] += total_calories
                        
                        calorie_data['foods'].append({
                            'timestamp': datetime.now().isoformat(),
                            'food': food_name,
                            'quantity': quantity,
                            'calories': total_calories
                        })
                        
                        remaining = max(0, calorie_data['daily_goal'] - calorie_data['today'])
                        
                        self._save_health_data(data)
                        self._show_notification("üçé Food Logged", f"{food_name.title()}: {total_calories} cal. Today: {calorie_data['today']}/{calorie_data['daily_goal']}")
                        
                        return f"üçé Added {quantity}x {food_name}: {total_calories} calories. Today: {calorie_data['today']}/{calorie_data['daily_goal']}. Remaining: {remaining}"
                    else:
                        return "üçé Could not identify food from your message. Try: 'ate 2 apples' or 'add pizza'"
                        
                except Exception as ai_error:
                    # Fallback to basic food database
                    food_db = {
                        'apple': 95, 'banana': 105, 'orange': 62, 'bread': 80, 'rice': 130,
                        'chicken': 165, 'beef': 250, 'fish': 140, 'egg': 70, 'milk': 150,
                        'pizza': 285, 'burger': 540, 'pasta': 220, 'salad': 50, 'yogurt': 100,
                        'coffee': 5, 'tea': 2, 'soda': 140, 'water': 0, 'juice': 110
                    }
                    
                    for food, calories_per_serving in food_db.items():
                        if food in query.lower():
                            qty_match = re.search(rf'(\d+)\s*{food}', query.lower())
                            quantity = int(qty_match.group(1)) if qty_match else 1
                            
                            total_calories = calories_per_serving * quantity
                            calorie_data['today'] += total_calories
                            
                            calorie_data['foods'].append({
                                'timestamp': datetime.now().isoformat(),
                                'food': food,
                                'quantity': quantity,
                                'calories': total_calories
                            })
                            
                            remaining = max(0, calorie_data['daily_goal'] - calorie_data['today'])
                            
                            self._save_health_data(data)
                            self._show_notification("üçé Food Logged", f"{food.title()}: {total_calories} cal. Today: {calorie_data['today']}/{calorie_data['daily_goal']}")
                            
                            return f"üçé Added {quantity}x {food}: {total_calories} calories. Today: {calorie_data['today']}/{calorie_data['daily_goal']}. Remaining: {remaining}"
                    
                    return "üçé Food not recognized. Try: 'ate sandwich' or 'add 2 cookies'"
            
            # Show status
            else:
                remaining = max(0, calorie_data['daily_goal'] - calorie_data['today'])
                over = max(0, calorie_data['today'] - calorie_data['daily_goal'])
                
                status = f"üçé Calories Today: {calorie_data['today']}/{calorie_data['daily_goal']}\n"
                
                if over > 0:
                    status += f"Over goal by: {over} calories\n"
                else:
                    status += f"Remaining: {remaining} calories\n"
                
                if calorie_data['foods']:
                    status += "\nToday's meals:\n"
                    for food in calorie_data['foods'][-5:]:  # Last 5 items
                        time_str = datetime.fromisoformat(food['timestamp']).strftime('%H:%M')
                        status += f"- {time_str}: {food['quantity']}x {food['food']} ({food['calories']} cal)\n"
                
                return status
                
        except Exception as e:
            return f"Calorie calculator failed: {e}"
    
    def sleep_tracker(self, query=""):
        try:
            import re
            from datetime import datetime, timedelta, time
            
            data = self._load_health_data()
            sleep_data = data['sleep']
            
            # AI-powered sleep optimization
            if 'bedtime' in query.lower() or 'set' in query.lower():
                try:
                    # Use AI to optimize sleep schedule
                    from engine.dual_ai import dual_ai
                    
                    ai_prompt = f'''Optimize sleep schedule from: "{query}"
                    
Respond ONLY in this format:
Bedtime: [HH:MM in 24h format]
Wake: [HH:MM in 24h format]
Optimal: [Yes/No]
Advice: [sleep optimization tip]
                    
Examples:
Bedtime: 22:30
Wake: 06:30
Optimal: Yes
Advice: Perfect 8-hour sleep cycle

Bedtime: 01:00
Wake: 07:00
Optimal: No
Advice: Try sleeping earlier for better recovery
                    
Recommend 7-9 hours of sleep for optimal health.'''
                    
                    if dual_ai.ai_provider == 'groq':
                        response = dual_ai.groq_client.chat.completions.create(
                            messages=[{"role": "user", "content": ai_prompt}],
                            model="llama-3.1-8b-instant"
                        )
                        ai_response = response.choices[0].message.content.strip()
                    else:
                        response = dual_ai.gemini_model.generate_content(ai_response)
                        ai_response = response.text.strip()
                    
                    # Parse AI response
                    bedtime_match = re.search(r'Bedtime:\s*(\d{1,2}:\d{2})', ai_response, re.IGNORECASE)
                    wake_match = re.search(r'Wake:\s*(\d{1,2}:\d{2})', ai_response, re.IGNORECASE)
                    optimal_match = re.search(r'Optimal:\s*(Yes|No)', ai_response, re.IGNORECASE)
                    advice_match = re.search(r'Advice:\s*(.+)', ai_response, re.IGNORECASE)
                    
                    if bedtime_match:
                        sleep_data['bedtime'] = bedtime_match.group(1)
                        if wake_match:
                            sleep_data['wake_time'] = wake_match.group(1)
                        
                        optimal = optimal_match.group(1) if optimal_match else "Unknown"
                        advice = advice_match.group(1) if advice_match else "Maintain consistent sleep schedule"
                        
                        sleep_data['ai_advice'] = advice
                        self._save_health_data(data)
                        
                        return f"üò¥ AI-optimized schedule set\nBedtime: {sleep_data['bedtime']}\nWake: {sleep_data['wake_time']}\nOptimal: {optimal}\nAI Advice: {advice}"
                        
                except Exception:
                    # Fallback to basic parsing
                    time_match = re.search(r'(\d{1,2}):?(\d{2})?\s*(pm|am)?', query.lower())
                    if time_match:
                        hour = int(time_match.group(1))
                        minute = int(time_match.group(2)) if time_match.group(2) else 0
                        period = time_match.group(3)
                        
                        if period == 'pm' and hour != 12:
                            hour += 12
                        elif period == 'am' and hour == 12:
                            hour = 0
                        
                        sleep_data['bedtime'] = f"{hour:02d}:{minute:02d}"
                        self._save_health_data(data)
                        
                        return f"üò¥ Bedtime set to {sleep_data['bedtime']}. Sleep reminders enabled."
            
            # Set wake time
            elif 'wake' in query.lower():
                time_match = re.search(r'(\d{1,2}):?(\d{2})?\s*(pm|am)?', query.lower())
                if time_match:
                    hour = int(time_match.group(1))
                    minute = int(time_match.group(2)) if time_match.group(2) else 0
                    period = time_match.group(3)
                    
                    if period == 'pm' and hour != 12:
                        hour += 12
                    elif period == 'am' and hour == 12:
                        hour = 0
                    
                    sleep_data['wake_time'] = f"{hour:02d}:{minute:02d}"
                    self._save_health_data(data)
                    
                    return f"‚è∞ Wake time set to {sleep_data['wake_time']}"
            
            # Start sleep reminders
            elif 'start' in query.lower() or 'enable' in query.lower():
                def sleep_reminder():
                    while True:
                        try:
                            current_data = self._load_health_data()
                            bedtime_str = current_data['sleep']['bedtime']
                            bedtime_hour, bedtime_min = map(int, bedtime_str.split(':'))
                            
                            now = datetime.now()
                            bedtime_today = now.replace(hour=bedtime_hour, minute=bedtime_min, second=0, microsecond=0)
                            
                            # If bedtime has passed today, set for tomorrow
                            if now > bedtime_today:
                                bedtime_today += timedelta(days=1)
                            
                            # Calculate time until bedtime
                            time_until = bedtime_today - now
                            
                            # Remind 30 minutes before bedtime
                            if time_until.total_seconds() <= 1800:  # 30 minutes
                                self._show_notification("üò¥ Bedtime Soon", f"Bedtime in {int(time_until.total_seconds()//60)} minutes. Start winding down!")
                                time.sleep(1800)  # Wait 30 minutes before next check
                            else:
                                time.sleep(900)  # Check every 15 minutes
                                
                        except Exception as e:
                            time.sleep(3600)  # Wait 1 hour on error
                
                threading.Thread(target=sleep_reminder, daemon=True).start()
                return f"üò¥ Sleep reminders started. Bedtime: {sleep_data['bedtime']}, Wake: {sleep_data['wake_time']}"
            
            # Show sleep schedule
            else:
                bedtime_hour, bedtime_min = map(int, sleep_data['bedtime'].split(':'))
                wake_hour, wake_min = map(int, sleep_data['wake_time'].split(':'))
                
                # Calculate sleep duration
                bedtime_minutes = bedtime_hour * 60 + bedtime_min
                wake_minutes = wake_hour * 60 + wake_min
                
                if wake_minutes < bedtime_minutes:
                    wake_minutes += 24 * 60  # Next day
                
                sleep_duration = (wake_minutes - bedtime_minutes) / 60
                
                status = f"üò¥ Sleep Schedule:\n"
                status += f"Bedtime: {sleep_data['bedtime']}\n"
                status += f"Wake time: {sleep_data['wake_time']}\n"
                status += f"Sleep duration: {sleep_duration:.1f} hours\n"
                
                if sleep_duration < 7:
                    status += "‚ö†Ô∏è Consider getting more sleep (7-9 hours recommended)"
                elif sleep_duration > 9:
                    status += "‚ö†Ô∏è You might be sleeping too much (7-9 hours recommended)"
                else:
                    status += "‚úÖ Good sleep duration!"
                
                return status
                
        except Exception as e:
            return f"Sleep tracker failed: {e}"
    
    def stress_meter(self, query=""):
        try:
            import re
            from datetime import datetime, timedelta
            
            data = self._load_health_data()
            stress_data = data['stress']
            
            # AI-powered stress analysis
            if any(word in query.lower() for word in ['level', 'feel', 'stressed', 'rate', 'anxious', 'overwhelmed']):
                try:
                    # Use AI to analyze stress from description
                    from engine.dual_ai import dual_ai
                    
                    ai_prompt = f'''Analyze stress level from: "{query}"
                    
Respond ONLY in this format:
Stress: [1-10]
Cause: [main stress cause]
Recommendation: [specific advice]
                    
Examples:
Stress: 7
Cause: work pressure
Recommendation: Take 5-minute breathing break

Stress: 3
Cause: mild fatigue
Recommendation: Stay hydrated and rest
                    
Rate 1-10 where 1=very calm, 10=extremely stressed.'''
                    
                    if dual_ai.ai_provider == 'groq':
                        response = dual_ai.groq_client.chat.completions.create(
                            messages=[{"role": "user", "content": ai_prompt}],
                            model="llama-3.1-8b-instant"
                        )
                        ai_response = response.choices[0].message.content.strip()
                    else:
                        response = dual_ai.gemini_model.generate_content(ai_prompt)
                        ai_response = response.text.strip()
                    
                    # Parse AI response
                    stress_match = re.search(r'Stress:\s*(\d+)', ai_response, re.IGNORECASE)
                    cause_match = re.search(r'Cause:\s*(.+)', ai_response, re.IGNORECASE)
                    rec_match = re.search(r'Recommendation:\s*(.+)', ai_response, re.IGNORECASE)
                    
                    if stress_match:
                        stress_level = int(stress_match.group(1))
                        cause = cause_match.group(1).strip() if cause_match else "general stress"
                        ai_recommendation = rec_match.group(1).strip() if rec_match else "Take deep breaths"
                    else:
                        raise Exception("AI parsing failed")
                        
                except Exception:
                    # Fallback to manual input
                    level_match = re.search(r'(\d+)', query)
                    if level_match:
                        stress_level = int(level_match.group(1))
                        cause = "user reported"
                        ai_recommendation = "Basic stress management"
                    else:
                        return "üßò Please describe your stress or rate it 1-10. Example: 'stress level 5' or 'feeling overwhelmed'"
                
                if 1 <= stress_level <= 10:
                    stress_data['levels'].append({
                        'timestamp': datetime.now().isoformat(),
                        'level': stress_level,
                        'cause': cause,
                        'ai_recommendation': ai_recommendation
                    })
                    
                    # AI-enhanced weekly analysis
                    week_ago = datetime.now() - timedelta(days=7)
                    recent_levels = [
                        entry['level'] for entry in stress_data['levels']
                        if datetime.fromisoformat(entry['timestamp']) > week_ago
                    ]
                    
                    if recent_levels:
                        stress_data['weekly_average'] = sum(recent_levels) / len(recent_levels)
                        
                        # AI trend analysis
                        if len(recent_levels) >= 3:
                            trend = "increasing" if recent_levels[-1] > recent_levels[-3] else "decreasing" if recent_levels[-1] < recent_levels[-3] else "stable"
                            trend_msg = f" (Trend: {trend})"
                        else:
                            trend_msg = ""
                    else:
                        trend_msg = ""
                    
                    stress_data['last_check'] = datetime.now().isoformat()
                    self._save_health_data(data)
                    
                    # AI-enhanced recommendations
                    if stress_level >= 8:
                        self._show_notification("üßò High Stress Alert", f"Cause: {cause}. {ai_recommendation}")
                    elif stress_level >= 6:
                        self._show_notification("üßò Stress Notice", f"Moderate stress from {cause}")
                    
                    return f"üßò Stress logged: {stress_level}/10\nCause: {cause}\nWeekly average: {stress_data['weekly_average']:.1f}{trend_msg}\nAI Advice: {ai_recommendation}"
                else:
                    return "üßò Please rate stress level 1-10 (1=very calm, 10=very stressed)"
            
            # Quick stress assessment
            elif 'check' in query.lower() or 'assess' in query.lower():
                questions = [
                    "Rate your current stress (1-10):",
                    "1 = Very calm and relaxed",
                    "5 = Moderate stress",
                    "10 = Extremely stressed"
                ]
                
                assessment = "üßò Quick Stress Assessment:\n" + "\n".join(questions)
                assessment += "\n\nBreathing Exercise: Inhale 4 counts ‚Üí Hold 4 ‚Üí Exhale 4 ‚Üí Repeat 5 times"
                
                return assessment
            
            # Show stress history
            else:
                if not stress_data['levels']:
                    return "üßò No stress data yet. Try: 'stress level 5' to log your current stress."
                
                # Recent stress levels
                recent = stress_data['levels'][-7:]  # Last 7 entries
                
                status = f"üßò Stress Overview:\n"
                status += f"Weekly average: {stress_data['weekly_average']:.1f}/10\n"
                
                if stress_data['last_check']:
                    last_time = datetime.fromisoformat(stress_data['last_check'])
                    hours_ago = (datetime.now() - last_time).total_seconds() / 3600
                    status += f"Last check: {hours_ago:.1f} hours ago\n"
                
                status += "\nRecent levels:\n"
                for entry in recent:
                    time_str = datetime.fromisoformat(entry['timestamp']).strftime('%m/%d %H:%M')
                    level = entry['level']
                    status += f"- {time_str}: {level}/10\n"
                
                # Stress management tips
                if stress_data['weekly_average'] >= 7:
                    status += "\n‚ö†Ô∏è High stress detected. Consider: meditation, exercise, or talking to someone."
                elif stress_data['weekly_average'] >= 5:
                    status += "\nüí° Moderate stress. Try: regular breaks, deep breathing, or light exercise."
                else:
                    status += "\n‚úÖ Good stress management! Keep it up."
                
                return status
                
        except Exception as e:
            return f"Stress meter failed: {e}"
    
    def mood_tracker(self, query=""):
        try:
            import re
            from datetime import datetime, timedelta
            
            data = self._load_health_data()
            mood_data = data['mood']
            
            # AI-powered mood analysis
            if any(word in query.lower() for word in ['feel', 'mood', 'happy', 'sad', 'angry', 'anxious', 'excited', 'tired']):
                try:
                    from engine.dual_ai import dual_ai
                    
                    ai_prompt = f'''Analyze mood from: "{query}"
                    
Respond ONLY in this format:
Mood: [1-10]
Emotion: [primary emotion]
Trigger: [what caused this mood]
Suggestion: [mood improvement tip]
                    
Examples:
Mood: 8
Emotion: happy
Trigger: good news
Suggestion: Share your joy with others

Mood: 4
Emotion: stressed
Trigger: work pressure
Suggestion: Take a short walk
                    
Rate 1-10 where 1=very negative, 10=very positive.'''
                    
                    if dual_ai.ai_provider == 'groq':
                        response = dual_ai.groq_client.chat.completions.create(
                            messages=[{"role": "user", "content": ai_prompt}],
                            model="llama-3.1-8b-instant"
                        )
                        ai_response = response.choices[0].message.content.strip()
                    else:
                        response = dual_ai.gemini_model.generate_content(ai_prompt)
                        ai_response = response.text.strip()
                    
                    # Parse AI response
                    mood_match = re.search(r'Mood:\s*(\d+)', ai_response, re.IGNORECASE)
                    emotion_match = re.search(r'Emotion:\s*(.+)', ai_response, re.IGNORECASE)
                    trigger_match = re.search(r'Trigger:\s*(.+)', ai_response, re.IGNORECASE)
                    suggestion_match = re.search(r'Suggestion:\s*(.+)', ai_response, re.IGNORECASE)
                    
                    if mood_match:
                        mood_score = int(mood_match.group(1))
                        emotion = emotion_match.group(1).strip() if emotion_match else "neutral"
                        trigger = trigger_match.group(1).strip() if trigger_match else "general"
                        suggestion = suggestion_match.group(1).strip() if suggestion_match else "Stay positive"
                    else:
                        raise Exception("AI parsing failed")
                        
                except Exception:
                    # Fallback mood detection
                    positive_words = ['happy', 'great', 'good', 'excited', 'amazing', 'wonderful']
                    negative_words = ['sad', 'bad', 'angry', 'tired', 'stressed', 'awful']
                    
                    mood_score = 5  # neutral
                    emotion = "neutral"
                    
                    for word in positive_words:
                        if word in query.lower():
                            mood_score = 8
                            emotion = word
                            break
                    
                    for word in negative_words:
                        if word in query.lower():
                            mood_score = 3
                            emotion = word
                            break
                    
                    trigger = "user reported"
                    suggestion = "Practice mindfulness"
                
                if 1 <= mood_score <= 10:
                    mood_data['entries'].append({
                        'timestamp': datetime.now().isoformat(),
                        'score': mood_score,
                        'emotion': emotion,
                        'trigger': trigger,
                        'suggestion': suggestion
                    })
                    
                    # Calculate weekly average
                    week_ago = datetime.now() - timedelta(days=7)
                    recent_moods = [
                        entry['score'] for entry in mood_data['entries']
                        if datetime.fromisoformat(entry['timestamp']) > week_ago
                    ]
                    
                    if recent_moods:
                        mood_data['weekly_average'] = sum(recent_moods) / len(recent_moods)
                    
                    mood_data['last_check'] = datetime.now().isoformat()
                    self._save_health_data(data)
                    
                    # Mood-based notifications
                    if mood_score <= 3:
                        self._show_notification("Mood Alert", f"Low mood detected. {suggestion}")
                    elif mood_score >= 8:
                        self._show_notification("Great Mood!", f"You're feeling {emotion}! Keep it up!")
                    
                    return f"Mood logged: {mood_score}/10 ({emotion})\nTrigger: {trigger}\nWeekly average: {mood_data['weekly_average']:.1f}\nSuggestion: {suggestion}"
                else:
                    return "Please rate mood 1-10 or describe how you feel"
            
            # Show mood history
            else:
                if not mood_data['entries']:
                    return "No mood data yet. Try: 'feeling happy' or 'mood 7'"
                
                recent = mood_data['entries'][-7:]
                
                status = f"Mood Overview:\n"
                status += f"Weekly average: {mood_data['weekly_average']:.1f}/10\n"
                
                if mood_data['last_check']:
                    last_time = datetime.fromisoformat(mood_data['last_check'])
                    hours_ago = (datetime.now() - last_time).total_seconds() / 3600
                    status += f"Last check: {hours_ago:.1f} hours ago\n"
                
                status += "\nRecent moods:\n"
                for entry in recent:
                    time_str = datetime.fromisoformat(entry['timestamp']).strftime('%m/%d %H:%M')
                    score = entry['score']
                    emotion = entry['emotion']
                    status += f"- {time_str}: {score}/10 ({emotion})\n"
                
                return status
                
        except Exception as e:
            return f"Mood tracker failed: {e}"
    
    def heart_rate_monitor(self, query=""):
        try:
            import re
            from datetime import datetime, timedelta
            
            data = self._load_health_data()
            hr_data = data['heart_rate']
            
            # Log heart rate
            if any(word in query.lower() for word in ['bpm', 'rate', 'pulse', 'beat']):
                hr_match = re.search(r'(\d+)\s*(?:bpm|beats?)', query.lower())
                if hr_match:
                    heart_rate = int(hr_match.group(1))
                    
                    if 40 <= heart_rate <= 200:
                        hr_data['readings'].append({
                            'timestamp': datetime.now().isoformat(),
                            'bpm': heart_rate,
                            'type': 'manual'
                        })
                        
                        # Calculate resting HR average
                        recent_readings = hr_data['readings'][-10:]  # Last 10 readings
                        if len(recent_readings) >= 3:
                            avg_hr = sum(r['bpm'] for r in recent_readings) / len(recent_readings)
                            hr_data['resting_hr'] = int(avg_hr)
                        
                        hr_data['last_check'] = datetime.now().isoformat()
                        self._save_health_data(data)
                        
                        # Heart rate analysis
                        if heart_rate > 100:
                            status = "High (may indicate stress or activity)"
                            self._show_notification("High Heart Rate", f"{heart_rate} BPM detected")
                        elif heart_rate < 60:
                            status = "Low (athletic or resting)"
                        else:
                            status = "Normal range"
                        
                        return f"Heart rate logged: {heart_rate} BPM\nStatus: {status}\nResting HR: {hr_data['resting_hr']} BPM"
                    else:
                        return "Please enter valid heart rate (40-200 BPM)"
                else:
                    return "Please specify heart rate: 'heart rate 75 bpm'"
            
            # Show heart rate history
            else:
                if not hr_data['readings']:
                    return "No heart rate data yet. Try: 'heart rate 72 bpm'"
                
                recent = hr_data['readings'][-7:]
                
                status = f"Heart Rate Monitor:\n"
                status += f"Resting HR: {hr_data['resting_hr']} BPM\n"
                
                if hr_data['last_check']:
                    last_time = datetime.fromisoformat(hr_data['last_check'])
                    hours_ago = (datetime.now() - last_time).total_seconds() / 3600
                    status += f"Last reading: {hours_ago:.1f} hours ago\n"
                
                status += "\nRecent readings:\n"
                for reading in recent:
                    time_str = datetime.fromisoformat(reading['timestamp']).strftime('%m/%d %H:%M')
                    bpm = reading['bpm']
                    status += f"- {time_str}: {bpm} BPM\n"
                
                return status
                
        except Exception as e:
            return f"Heart rate monitor failed: {e}"
    
    def medication_reminder(self, query=""):
        try:
            import re, json
            from datetime import datetime, timedelta
            
            data = self._load_health_data()
            med_data = data['medications']
            
            # Add medication
            if 'add' in query.lower() or 'take' in query.lower():
                # Extract medication name and schedule
                med_match = re.search(r'(?:add|take)\s+(.+?)(?:\s+(?:every|at|daily)|$)', query.lower())
                if med_match:
                    med_name = med_match.group(1).strip()
                    
                    # Extract schedule
                    schedule = "daily"
                    time_match = re.search(r'(?:at|every)\s+(\d{1,2}):?(\d{2})?\s*(am|pm)?', query.lower())
                    if time_match:
                        hour = int(time_match.group(1))
                        minute = int(time_match.group(2)) if time_match.group(2) else 0
                        period = time_match.group(3)
                        
                        if period == 'pm' and hour != 12:
                            hour += 12
                        elif period == 'am' and hour == 12:
                            hour = 0
                        
                        schedule = f"{hour:02d}:{minute:02d}"
                    
                    medication = {
                        'name': med_name,
                        'schedule': schedule,
                        'added': datetime.now().isoformat(),
                        'last_taken': None
                    }
                    
                    med_data['pills'].append(medication)
                    self._save_health_data(data)
                    
                    # Set up reminder
                    def med_reminder():
                        while True:
                            try:
                                if schedule != "daily":
                                    # Parse time
                                    hour, minute = map(int, schedule.split(':'))
                                    now = datetime.now()
                                    reminder_time = now.replace(hour=hour, minute=minute, second=0, microsecond=0)
                                    
                                    if now > reminder_time:
                                        reminder_time += timedelta(days=1)
                                    
                                    time_until = (reminder_time - now).total_seconds()
                                    time.sleep(time_until)
                                    
                                    self._show_notification("üíä Medication Reminder", f"Time to take {med_name}")
                                    time.sleep(86400)  # Wait 24 hours for next reminder
                                else:
                                    time.sleep(86400)  # Daily reminder at same time
                            except Exception:
                                time.sleep(3600)  # Wait 1 hour on error
                    
                    threading.Thread(target=med_reminder, daemon=True).start()
                    
                    return f"Medication added: {med_name}\nSchedule: {schedule}\nReminders enabled"
                else:
                    return "Please specify medication: 'add aspirin at 8am'"
            
            # Mark as taken
            elif 'taken' in query.lower() or 'took' in query.lower():
                med_match = re.search(r'(?:taken|took)\s+(.+)', query.lower())
                if med_match:
                    med_name = med_match.group(1).strip()
                    
                    for med in med_data['pills']:
                        if med_name.lower() in med['name'].lower():
                            med['last_taken'] = datetime.now().isoformat()
                            self._save_health_data(data)
                            return f"Marked {med['name']} as taken"
                    
                    return f"Medication '{med_name}' not found in your list"
                else:
                    return "Please specify which medication you took"
            
            # List medications
            else:
                if not med_data['pills']:
                    return "No medications added yet. Try: 'add vitamin D at 9am'"
                
                status = "Medication Schedule:\n" + "="*30 + "\n"
                
                for i, med in enumerate(med_data['pills'], 1):
                    status += f"{i}. {med['name']}\n"
                    status += f"   Schedule: {med['schedule']}\n"
                    
                    if med['last_taken']:
                        last_taken = datetime.fromisoformat(med['last_taken'])
                        hours_ago = (datetime.now() - last_taken).total_seconds() / 3600
                        status += f"   Last taken: {hours_ago:.1f} hours ago\n"
                    else:
                        status += f"   Last taken: Never\n"
                    
                    status += "\n"
                
                return status
                
        except Exception as e:
            return f"Medication reminder failed: {e}"
    
    def bmi_calculator(self, query=""):
        try:
            import re
            from datetime import datetime
            
            data = self._load_health_data()
            bmi_data = data['bmi']
            
            # Update weight/height
            if 'weight' in query.lower() or 'height' in query.lower():
                weight_match = re.search(r'weight\s+(\d+(?:\.\d+)?)\s*(?:kg|kilos?)?', query.lower())
                height_match = re.search(r'height\s+(\d+(?:\.\d+)?)\s*(?:cm|centimeters?)?', query.lower())
                
                if weight_match:
                    bmi_data['weight'] = float(weight_match.group(1))
                
                if height_match:
                    bmi_data['height'] = float(height_match.group(1))
                
                self._save_health_data(data)
            
            # Calculate BMI
            weight = bmi_data['weight']
            height = bmi_data['height'] / 100  # Convert cm to meters
            
            bmi = weight / (height * height)
            
            # BMI categories
            if bmi < 18.5:
                category = "Underweight"
                advice = "Consider consulting a nutritionist for healthy weight gain"
            elif bmi < 25:
                category = "Normal weight"
                advice = "Great! Maintain your current lifestyle"
            elif bmi < 30:
                category = "Overweight"
                advice = "Consider regular exercise and balanced diet"
            else:
                category = "Obese"
                advice = "Consult a healthcare provider for weight management"
            
            # Log BMI history
            bmi_data['history'].append({
                'timestamp': datetime.now().isoformat(),
                'bmi': round(bmi, 1),
                'weight': weight,
                'height': bmi_data['height'],
                'category': category
            })
            
            self._save_health_data(data)
            
            result = f"BMI Calculator:\n"
            result += f"Height: {bmi_data['height']} cm\n"
            result += f"Weight: {weight} kg\n"
            result += f"BMI: {bmi:.1f}\n"
            result += f"Category: {category}\n"
            result += f"Advice: {advice}"
            
            return result
            
        except Exception as e:
            return f"BMI calculator failed: {e}"
    
    def system_monitor(self, query=""):
        try:
            import psutil
            from datetime import datetime
            
            # CPU and Memory usage
            cpu_percent = psutil.cpu_percent(interval=1)
            memory = psutil.virtual_memory()
            disk = psutil.disk_usage('/')
            
            # System temperatures (if available)
            try:
                temps = psutil.sensors_temperatures()
                temp_info = ""
                if temps:
                    for name, entries in temps.items():
                        for entry in entries:
                            temp_info += f"{entry.label or name}: {entry.current}¬∞C "
            except:
                temp_info = "Temperature sensors not available"
            
            # Network activity
            net_io = psutil.net_io_counters()
            
            # Battery info (for laptops)
            try:
                battery = psutil.sensors_battery()
                battery_info = f"Battery: {battery.percent}% ({'Charging' if battery.power_plugged else 'Discharging'})" if battery else "No battery"
            except:
                battery_info = "Battery info unavailable"
            
            status = f"System Monitor:\n"
            status += f"CPU Usage: {cpu_percent}%\n"
            status += f"Memory: {memory.percent}% ({memory.used//1024//1024}MB/{memory.total//1024//1024}MB)\n"
            status += f"Disk: {disk.percent}% ({disk.used//1024//1024//1024}GB/{disk.total//1024//1024//1024}GB)\n"
            status += f"Network: {net_io.bytes_sent//1024//1024}MB sent, {net_io.bytes_recv//1024//1024}MB received\n"
            status += f"{battery_info}\n"
            status += f"Temperature: {temp_info}"
            
            # Alerts for high usage
            if cpu_percent > 80:
                self._show_notification("High CPU Usage", f"CPU at {cpu_percent}%")
            if memory.percent > 85:
                self._show_notification("High Memory Usage", f"RAM at {memory.percent}%")
            
            return status
            
        except ImportError:
            return "System monitoring requires: pip install psutil"
        except Exception as e:
            return f"System monitor failed: {e}"
    
    def network_monitor(self, query=""):
        try:
            import socket
            import subprocess
            import re
            
            # Get local IP
            hostname = socket.gethostname()
            local_ip = socket.gethostbyname(hostname)
            
            # Check internet connectivity
            try:
                socket.create_connection(("8.8.8.8", 53), timeout=3)
                internet_status = "Connected"
            except:
                internet_status = "Disconnected"
            
            # Get WiFi info (Windows)
            try:
                wifi_result = subprocess.run(['netsh', 'wlan', 'show', 'profiles'], 
                                           capture_output=True, text=True, timeout=10)
                wifi_profiles = len(re.findall(r'All User Profile\s*:\s*(.+)', wifi_result.stdout))
                
                # Current WiFi connection
                current_wifi = subprocess.run(['netsh', 'wlan', 'show', 'interfaces'], 
                                            capture_output=True, text=True, timeout=10)
                ssid_match = re.search(r'SSID\s*:\s*(.+)', current_wifi.stdout)
                current_ssid = ssid_match.group(1).strip() if ssid_match else "Not connected"
                
                signal_match = re.search(r'Signal\s*:\s*(\d+)%', current_wifi.stdout)
                signal_strength = signal_match.group(1) + "%" if signal_match else "Unknown"
                
            except:
                wifi_profiles = "Unknown"
                current_ssid = "Unknown"
                signal_strength = "Unknown"
            
            # Network speed test (simple ping)
            try:
                ping_result = subprocess.run(['ping', '-n', '4', '8.8.8.8'], 
                                           capture_output=True, text=True, timeout=15)
                avg_match = re.search(r'Average = (\d+)ms', ping_result.stdout)
                ping_time = avg_match.group(1) + "ms" if avg_match else "Failed"
            except:
                ping_time = "Failed"
            
            status = f"Network Monitor:\n"
            status += f"Local IP: {local_ip}\n"
            status += f"Internet: {internet_status}\n"
            status += f"Current WiFi: {current_ssid}\n"
            status += f"Signal Strength: {signal_strength}\n"
            status += f"Ping to Google: {ping_time}\n"
            status += f"Saved WiFi Networks: {wifi_profiles}"
            
            # Alert for connection issues
            if internet_status == "Disconnected":
                self._show_notification("Network Alert", "Internet connection lost")
            
            return status
            
        except Exception as e:
            return f"Network monitor failed: {e}"
    
    def language_translator(self, query=""):
        try:
            import re
            
            # Extract text and target language
            if 'translate' in query.lower():
                # Parse: "translate hello to spanish" or "translate 'bonjour' from french to english"
                translate_match = re.search(r'translate\s+["\']?(.+?)["\']?\s+(?:to|into)\s+(\w+)', query.lower())
                if translate_match:
                    text = translate_match.group(1).strip()
                    target_lang = translate_match.group(2).strip()
                else:
                    return "Usage: 'translate hello to spanish' or 'translate bonjour to english'"
            else:
                return "Please specify translation: 'translate [text] to [language]'"
            
            # Use AI for translation
            try:
                from engine.dual_ai import dual_ai
                
                ai_prompt = f'''Translate this text to {target_lang}: "{text}"
                
Respond ONLY in this format:
Original: [original text]
Language: [target language]
Translation: [translated text]
Pronunciation: [how to pronounce if applicable]
                
Example:
Original: hello
Language: spanish
Translation: hola
Pronunciation: OH-lah'''
                
                if dual_ai.ai_provider == 'groq':
                    response = dual_ai.groq_client.chat.completions.create(
                        messages=[{"role": "user", "content": ai_prompt}],
                        model="llama-3.1-8b-instant"
                    )
                    ai_response = response.choices[0].message.content.strip()
                else:
                    response = dual_ai.gemini_model.generate_content(ai_prompt)
                    ai_response = response.text.strip()
                
                # Parse AI response
                translation_match = re.search(r'Translation:\s*(.+)', ai_response, re.IGNORECASE)
                pronunciation_match = re.search(r'Pronunciation:\s*(.+)', ai_response, re.IGNORECASE)
                
                if translation_match:
                    translation = translation_match.group(1).strip()
                    pronunciation = pronunciation_match.group(1).strip() if pronunciation_match else ""
                    
                    result = f"Translation:\n"
                    result += f"'{text}' -> '{translation}' ({target_lang})"
                    if pronunciation:
                        result += f"\nPronunciation: {pronunciation}"
                    
                    return result
                else:
                    return f"Could not translate '{text}' to {target_lang}"
                    
            except Exception:
                # Fallback to basic translation service
                try:
                    import requests
                    
                    # Use Google Translate API (free tier)
                    url = f"https://translate.googleapis.com/translate_a/single?client=gtx&sl=auto&tl={target_lang}&dt=t&q={text}"
                    response = requests.get(url, timeout=5)
                    
                    if response.status_code == 200:
                        result_data = response.json()
                        translation = result_data[0][0][0]
                        return f"Translation: '{text}' -> '{translation}' ({target_lang})"
                    else:
                        return "Translation service unavailable"
                        
                except Exception:
                    return f"Translation failed for '{text}' to {target_lang}"
                    
        except Exception as e:
            return f"Language translator failed: {e}"
    
    def dictionary_lookup(self, query=""):
        try:
            import re
            
            # Extract word to define
            if 'define' in query.lower():
                word_match = re.search(r'define\s+(\w+)', query.lower())
                if word_match:
                    word = word_match.group(1).strip()
                else:
                    return "Usage: 'define [word]' - Example: 'define computer'"
            elif 'dictionary' in query.lower():
                word_match = re.search(r'dictionary\s+(\w+)', query.lower())
                if word_match:
                    word = word_match.group(1).strip()
                else:
                    return "Usage: 'dictionary [word]' - Example: 'dictionary science'"
            else:
                # Extract any word from query
                words = re.findall(r'\b[a-zA-Z]{3,}\b', query)
                if words:
                    word = words[-1]  # Take last significant word
                else:
                    return "Please specify a word to define"
            
            # Use AI for comprehensive definition
            try:
                from engine.dual_ai import dual_ai
                
                ai_prompt = f'''Provide a comprehensive definition for the word: "{word}"
                
Respond ONLY in this format:
Word: [word]
Pronunciation: [phonetic pronunciation]
Part of Speech: [noun/verb/adjective/etc.]
Definition: [clear definition]
Example: [example sentence]
Synonyms: [similar words]
Etymology: [word origin if known]
                
Example:
Word: computer
Pronunciation: kuhm-PYOO-ter
Part of Speech: noun
Definition: An electronic device that processes data and performs calculations
Example: I use my computer for work and entertainment
Synonyms: PC, machine, device
Etymology: From Latin "computare" meaning to calculate'''
                
                if dual_ai.ai_provider == 'groq':
                    response = dual_ai.groq_client.chat.completions.create(
                        messages=[{"role": "user", "content": ai_prompt}],
                        model="llama-3.1-8b-instant"
                    )
                    ai_response = response.choices[0].message.content.strip()
                else:
                    response = dual_ai.gemini_model.generate_content(ai_prompt)
                    ai_response = response.text.strip()
                
                # Format the response nicely
                lines = ai_response.split('\n')
                formatted_def = f"Dictionary Lookup: {word.upper()}\n" + "="*40 + "\n"
                
                for line in lines:
                    if ':' in line:
                        formatted_def += line + "\n"
                
                return formatted_def
                
            except Exception:
                # Fallback to simple definition
                return f"Definition of '{word}': A word requiring dictionary lookup. Please check online dictionary for detailed definition."
                
        except Exception as e:
            return f"Dictionary lookup failed: {e}"
    
    def wikipedia_search(self, query=""):
        try:
            import re
            import requests
            
            # Extract search term - fix the parsing issue
            search_term = ""
            if 'wikipedia search for' in query.lower():
                search_match = re.search(r'wikipedia search for\s+(.+)', query.lower())
                if search_match:
                    search_term = search_match.group(1).strip()
            elif 'wikipedia' in query.lower() or 'wiki' in query.lower():
                search_match = re.search(r'(?:wikipedia|wiki)\s+(?:search\s+(?:for\s+)?)?(.+)', query.lower())
                if search_match:
                    search_term = search_match.group(1).strip()
            else:
                search_term = query.strip()
            
            if not search_term:
                return "Please specify a topic to search"
            
            # Search Wikipedia API
            try:
                # Get page summary
                wiki_url = f"https://en.wikipedia.org/api/rest_v1/page/summary/{search_term.replace(' ', '_')}"
                response = requests.get(wiki_url, timeout=10)
                
                if response.status_code == 200:
                    data = response.json()
                    
                    title = data.get('title', search_term)
                    extract = data.get('extract', 'No summary available')
                    page_url = data.get('content_urls', {}).get('desktop', {}).get('page', '')
                    
                    # Limit extract length
                    if len(extract) > 500:
                        extract = extract[:500] + "..."
                    
                    result = f"Wikipedia: {title}\n" + "="*50 + "\n"
                    result += f"{extract}\n\n"
                    result += f"Full article: {page_url}"
                    
                    return result
                else:
                    # Try search if direct lookup fails
                    search_url = f"https://en.wikipedia.org/w/api.php?action=query&list=search&srsearch={search_term}&format=json&srlimit=3"
                    search_response = requests.get(search_url, timeout=10)
                    
                    if search_response.status_code == 200:
                        search_data = search_response.json()
                        if search_data['query']['search']:
                            results = search_data['query']['search']
                            if len(results) == 1:
                                page_title = results[0]['title']
                                # Try to get the actual page content
                                wiki_url = f"https://en.wikipedia.org/api/rest_v1/page/summary/{page_title.replace(' ', '_')}"
                                page_response = requests.get(wiki_url, timeout=10)
                                if page_response.status_code == 200:
                                    page_data = page_response.json()
                                    extract = page_data.get('extract', 'No summary available')
                                    page_url = page_data.get('content_urls', {}).get('desktop', {}).get('page', '')
                                    
                                    if len(extract) > 500:
                                        extract = extract[:500] + "..."
                                    
                                    result = f"Wikipedia: {page_title}\n" + "="*50 + "\n"
                                    result += f"{extract}\n\n"
                                    result += f"Full article: {page_url}"
                                    return result
                                else:
                                    return f"Found: {page_title}. Try: 'wikipedia {page_title}'"
                            else:
                                # Multiple results found
                                result = f"Multiple Wikipedia articles found for '{search_term}':\n"
                                for i, item in enumerate(results[:3], 1):
                                    result += f"{i}. {item['title']}\n"
                                result += f"\nTry: 'wikipedia {results[0]['title']}' for the first result"
                                return result
                    
                    return f"No Wikipedia article found for '{search_term}'. Try searching with more specific terms."
                    
            except Exception:
                return f"Wikipedia search failed for '{search_term}'"
                
        except Exception as e:
            return f"Wikipedia search failed: {e}"
    
    def calculator_advanced(self, query=""):
        try:
            import re
            import math
            
            # Extract mathematical expression
            if 'calculate' in query.lower():
                calc_match = re.search(r'calculate\s+(.+)', query.lower())
                if calc_match:
                    expression = calc_match.group(1).strip()
                else:
                    return "Usage: 'calculate [expression]' - Example: 'calculate sin(45) + log(10)'"
            else:
                expression = query.strip()
            
            if not expression:
                return "Please provide a mathematical expression"
            
            # Use AI for complex calculations
            try:
                from engine.dual_ai import dual_ai
                
                ai_prompt = f'''Solve this mathematical expression: "{expression}"
                
Respond ONLY in this format:
Expression: [original expression]
Result: [numerical result]
Steps: [calculation steps if complex]
Explanation: [brief explanation]
                
Support: basic arithmetic (+,-,*,/), powers (^,**), roots (sqrt), trigonometry (sin,cos,tan), logarithms (log,ln), constants (pi,e)
                
Example:
Expression: sin(45) + log(10)
Result: 0.707 + 1.000 = 1.707
Steps: sin(45¬∞) = 0.707, log‚ÇÅ‚ÇÄ(10) = 1.000
Explanation: Sine of 45 degrees plus logarithm base 10 of 10'''
                
                if dual_ai.ai_provider == 'groq':
                    response = dual_ai.groq_client.chat.completions.create(
                        messages=[{"role": "user", "content": ai_prompt}],
                        model="llama-3.1-8b-instant"
                    )
                    ai_response = response.choices[0].message.content.strip()
                else:
                    response = dual_ai.gemini_model.generate_content(ai_prompt)
                    ai_response = response.text.strip()
                
                return f"Advanced Calculator:\n{ai_response}"
                
            except Exception:
                # Fallback to basic Python evaluation
                try:
                    # Replace common math functions
                    safe_expr = expression.lower()
                    safe_expr = safe_expr.replace('^', '**')
                    safe_expr = safe_expr.replace('sin', 'math.sin')
                    safe_expr = safe_expr.replace('cos', 'math.cos')
                    safe_expr = safe_expr.replace('tan', 'math.tan')
                    safe_expr = safe_expr.replace('log', 'math.log10')
                    safe_expr = safe_expr.replace('ln', 'math.log')
                    safe_expr = safe_expr.replace('sqrt', 'math.sqrt')
                    safe_expr = safe_expr.replace('pi', 'math.pi')
                    safe_expr = safe_expr.replace('e', 'math.e')
                    
                    # Evaluate safely
                    result = eval(safe_expr, {"__builtins__": {}, "math": math})
                    return f"Calculator: {expression} = {result}"
                    
                except Exception:
                    return f"Invalid mathematical expression: '{expression}'"
                    
        except Exception as e:
            return f"Calculator failed: {e}"
    
    def unit_converter(self, query=""):
        try:
            import re
            
            # Extract conversion request
            convert_match = re.search(r'convert\s+(\d+(?:\.\d+)?)\s*(\w+)\s+(?:to|into)\s+(\w+)', query.lower())
            if convert_match:
                value = float(convert_match.group(1))
                from_unit = convert_match.group(2).strip()
                to_unit = convert_match.group(3).strip()
            else:
                return "Usage: 'convert 100 meters to feet' or 'convert 32 fahrenheit to celsius'"
            
            # Use AI for intelligent unit conversion
            try:
                from engine.dual_ai import dual_ai
                
                ai_prompt = f'''Convert {value} {from_unit} to {to_unit}
                
Respond ONLY in this format:
Original: [value] [from_unit]
Converted: [result] [to_unit]
Formula: [conversion formula]
Category: [length/weight/temperature/etc.]
                
Support common units: meters/feet/inches, kg/pounds/ounces, celsius/fahrenheit/kelvin, liters/gallons/cups, etc.
                
Example:
Original: 100 meters
Converted: 328.08 feet
Formula: meters √ó 3.28084 = feet
Category: length'''
                
                if dual_ai.ai_provider == 'groq':
                    response = dual_ai.groq_client.chat.completions.create(
                        messages=[{"role": "user", "content": ai_prompt}],
                        model="llama-3.1-8b-instant"
                    )
                    ai_response = response.choices[0].message.content.strip()
                else:
                    response = dual_ai.gemini_model.generate_content(ai_prompt)
                    ai_response = response.text.strip()
                
                return f"Unit Converter:\n{ai_response}"
                
            except Exception:
                # Fallback to basic conversions
                conversions = {
                    ('meters', 'feet'): 3.28084,
                    ('feet', 'meters'): 0.3048,
                    ('kg', 'pounds'): 2.20462,
                    ('pounds', 'kg'): 0.453592,
                    ('celsius', 'fahrenheit'): lambda c: c * 9/5 + 32,
                    ('fahrenheit', 'celsius'): lambda f: (f - 32) * 5/9,
                }
                
                key = (from_unit.lower(), to_unit.lower())
                if key in conversions:
                    factor = conversions[key]
                    if callable(factor):
                        result = factor(value)
                    else:
                        result = value * factor
                    
                    return f"Unit Conversion: {value} {from_unit} = {result:.4f} {to_unit}"
                else:
                    return f"Conversion from {from_unit} to {to_unit} not supported"
                    
        except Exception as e:
            return f"Unit converter failed: {e}"
    
    def flashcard_system(self, query=""):
        try:
            import json
            import random
            import re
            
            flashcards_file = "flashcards.json"
            
            # Load existing flashcards
            try:
                with open(flashcards_file, 'r') as f:
                    flashcards = json.load(f)
            except:
                flashcards = {'decks': {}}
            
            # Add new flashcard
            if 'add' in query.lower() and 'flashcard' in query.lower():
                # Parse: "add flashcard python: programming language"
                add_match = re.search(r'add flashcard\s+(.+?):\s*(.+)', query.lower())
                if add_match:
                    question = add_match.group(1).strip()
                    answer = add_match.group(2).strip()
                    
                    deck_name = "general"
                    if 'deck' in query.lower():
                        deck_match = re.search(r'deck\s+(\w+)', query.lower())
                        if deck_match:
                            deck_name = deck_match.group(1)
                    
                    if deck_name not in flashcards['decks']:
                        flashcards['decks'][deck_name] = []
                    
                    from datetime import datetime
                    flashcards['decks'][deck_name].append({
                        'question': question,
                        'answer': answer,
                        'created': datetime.now().isoformat()
                    })
                    
                    with open(flashcards_file, 'w') as f:
                        json.dump(flashcards, f, indent=2)
                    
                    return f"Flashcard added to '{deck_name}' deck: {question} -> {answer}"
                else:
                    return "Usage: 'add flashcard [question]: [answer]' - Example: 'add flashcard capital of france: paris'"
            
            # Study flashcards
            elif 'study' in query.lower() or 'flashcard' in query.lower():
                if not flashcards['decks']:
                    return "No flashcards available. Add some first: 'add flashcard [question]: [answer]'"
                
                # Select deck
                deck_name = "general"
                if 'deck' in query.lower():
                    deck_match = re.search(r'deck\s+(\w+)', query.lower())
                    if deck_match:
                        deck_name = deck_match.group(1)
                
                if deck_name not in flashcards['decks'] or not flashcards['decks'][deck_name]:
                    available_decks = list(flashcards['decks'].keys())
                    return f"Deck '{deck_name}' not found. Available decks: {', '.join(available_decks)}"
                
                # Get random flashcard
                cards = flashcards['decks'][deck_name]
                card = random.choice(cards)
                
                return f"Flashcard Study - {deck_name.title()} Deck:\nQuestion: {card['question']}\n\n(Say 'answer' to reveal the answer)"
            
            # Show answer
            elif 'answer' in query.lower():
                return "Feature: Show last flashcard answer (implement session tracking)"
            
            # List decks
            else:
                if not flashcards['decks']:
                    return "No flashcard decks available. Create your first: 'add flashcard [question]: [answer]'"
                
                result = "Flashcard Decks:\n" + "="*30 + "\n"
                for deck_name, cards in flashcards['decks'].items():
                    result += f"{deck_name.title()}: {len(cards)} cards\n"
                
                result += "\nUsage: 'study flashcard deck [name]' or 'add flashcard [question]: [answer]'"
                return result
                
        except Exception as e:
            return f"Flashcard system failed: {e}"
    
    def quiz_generator(self, query=""):
        try:
            import re
            
            # Extract quiz topic
            if 'quiz' in query.lower():
                topic_match = re.search(r'quiz\s+(?:on\s+|about\s+)?(.+)', query.lower())
                if topic_match:
                    topic = topic_match.group(1).strip()
                else:
                    topic = "general knowledge"
            else:
                topic = query.strip() or "general knowledge"
            
            # Use AI to generate quiz questions
            try:
                from engine.dual_ai import dual_ai
                
                ai_prompt = f'''Generate a quiz about: "{topic}"
                
Create 5 multiple choice questions. Respond ONLY in this format:

QUIZ: {topic.upper()}

Q1: [question]
A) [option A]
B) [option B] 
C) [option C]
D) [option D]
Correct: [A/B/C/D]

Q2: [question]
A) [option A]
B) [option B]
C) [option C] 
D) [option D]
Correct: [A/B/C/D]

[Continue for Q3, Q4, Q5]

Make questions educational and appropriate difficulty level.'''
                
                if dual_ai.ai_provider == 'groq':
                    response = dual_ai.groq_client.chat.completions.create(
                        messages=[{"role": "user", "content": ai_prompt}],
                        model="llama-3.1-8b-instant"
                    )
                    ai_response = response.choices[0].message.content.strip()
                else:
                    response = dual_ai.gemini_model.generate_content(ai_prompt)
                    ai_response = response.text.strip()
                
                return f"Quiz Generator:\n{ai_response}\n\nSay 'quiz answers' to see the correct answers!"
                
            except Exception:
                # Fallback to simple quiz
                sample_questions = {
                    "general": [
                        "What is the capital of France? A) London B) Berlin C) Paris D) Madrid",
                        "What is 2+2? A) 3 B) 4 C) 5 D) 6",
                        "Which planet is closest to the Sun? A) Venus B) Mercury C) Earth D) Mars"
                    ],
                    "science": [
                        "What is H2O? A) Hydrogen B) Oxygen C) Water D) Carbon",
                        "Speed of light? A) 300,000 km/s B) 150,000 km/s C) 450,000 km/s D) 600,000 km/s"
                    ]
                }
                
                questions = sample_questions.get("general", sample_questions["general"])
                
                result = f"Quiz: {topic.title()}\n" + "="*30 + "\n"
                for i, q in enumerate(questions[:3], 1):
                    result += f"Q{i}: {q}\n\n"
                
                return result
                
        except Exception as e:
            return f"Quiz generator failed: {e}"
    
    def meme_generator(self, query=""):
        try:
            import re
            
            # Extract meme request
            if 'meme' in query.lower():
                meme_match = re.search(r'meme\s+(.+)', query.lower())
                if meme_match:
                    meme_request = meme_match.group(1).strip()
                else:
                    meme_request = "funny programming joke"
            else:
                meme_request = query.strip() or "random funny meme"
            
            # Use AI to generate meme concept
            try:
                from engine.dual_ai import dual_ai
                
                ai_prompt = f'''Create a meme concept for: "{meme_request}"
                
Respond ONLY in this format:
Template: [meme template name]
Top Text: [text for top]
Bottom Text: [text for bottom]
Style: [humor style]
Description: [visual description]
                
Examples:
Template: Drake Pointing
Top Text: Using print() for debugging
Bottom Text: Using proper debugger
Style: Programming humor
Description: Drake disapproving of print, approving debugger
                
Make it funny and relatable!'''
                
                if dual_ai.ai_provider == 'groq':
                    response = dual_ai.groq_client.chat.completions.create(
                        messages=[{"role": "user", "content": ai_prompt}],
                        model="llama-3.1-8b-instant"
                    )
                    ai_response = response.choices[0].message.content.strip()
                else:
                    response = dual_ai.gemini_model.generate_content(ai_prompt)
                    ai_response = response.text.strip()
                
                return f"Meme Generator:\n{ai_response}\n\nNote: Use online meme generators like imgflip.com to create the actual image!"
                
            except Exception:
                # Fallback meme concepts
                templates = {
                    "programming": "Template: Distracted Boyfriend\nTop: Me\nGirlfriend: Current project\nOther woman: New framework",
                    "work": "Template: This is Fine\nTop: Everything is under control\nBottom: (while everything burns)",
                    "study": "Template: Drake Pointing\nTop: Studying early\nBottom: Cramming last minute"
                }
                
                concept_type = "programming" if any(word in meme_request for word in ['code', 'programming', 'developer']) else "work"
                concept = templates.get(concept_type, templates["work"])
                
                return f"Meme Generator:\n{concept}\n\nUse imgflip.com or similar to create the image!"
                
        except Exception as e:
            return f"Meme generator failed: {e}"
    
    def logo_generator(self, query=""):
        try:
            import re
            
            # Extract logo requirements
            company_match = re.search(r'logo\s+(?:for\s+)?(.+?)(?:\s+(?:blue|red|green|black|white|color))?', query.lower())
            if company_match:
                company_name = company_match.group(1).strip()
            else:
                company_name = "MyCompany"
            
            # Extract colors
            colors = []
            color_words = ['blue', 'red', 'green', 'black', 'white', 'yellow', 'purple', 'orange']
            for color in color_words:
                if color in query.lower():
                    colors.append(color)
            
            if not colors:
                colors = ['blue', 'white']
            
            # Use AI to generate logo concept
            try:
                from engine.dual_ai import dual_ai
                
                ai_prompt = f'''Design a logo concept for: "{company_name}" using colors: {', '.join(colors)}
                
Respond ONLY in this format:
Company: [company name]
Concept: [logo concept]
Colors: [color scheme]
Font: [font style]
Symbol: [icon/symbol idea]
Style: [modern/classic/minimalist/etc]
Description: [detailed visual description]
                
Example:
Company: TechCorp
Concept: Tech innovation and reliability
Colors: Blue (#0066CC) and White (#FFFFFF)
Font: Modern sans-serif, bold
Symbol: Stylized circuit pattern forming a "T"
Style: Modern, minimalist
Description: Clean geometric design with tech elements
                
Make it professional and memorable!'''
                
                if dual_ai.ai_provider == 'groq':
                    response = dual_ai.groq_client.chat.completions.create(
                        messages=[{"role": "user", "content": ai_prompt}],
                        model="llama-3.1-8b-instant"
                    )
                    ai_response = response.choices[0].message.content.strip()
                else:
                    response = dual_ai.gemini_model.generate_content(ai_prompt)
                    ai_response = response.text.strip()
                
                return f"Logo Generator:\n{ai_response}\n\nRecommended tools: Canva, Figma, or Adobe Illustrator"
                
            except Exception:
                # Fallback logo concept
                return f"Logo Generator:\nCompany: {company_name.title()}\nConcept: Professional and modern\nColors: {', '.join(colors)}\nFont: Clean sans-serif\nSymbol: Abstract geometric shape\nStyle: Minimalist\nDescription: Simple, scalable design with company initials"
                
        except Exception as e:
            return f"Logo generator failed: {e}"
    
    def color_palette_generator(self, query=""):
        try:
            import re
            import random
            
            # Extract theme
            theme_match = re.search(r'(?:color|palette)\s+(.+)', query.lower())
            if theme_match:
                theme = theme_match.group(1).strip()
            else:
                theme = "modern"
            
            # Use AI to generate color palette
            try:
                from engine.dual_ai import dual_ai
                
                ai_prompt = f'''Generate a color palette for theme: "{theme}"
                
Respond ONLY in this format:
Theme: [theme name]
Primary: [color name] (#HEXCODE)
Secondary: [color name] (#HEXCODE)
Accent: [color name] (#HEXCODE)
Neutral: [color name] (#HEXCODE)
Background: [color name] (#HEXCODE)
Mood: [emotional description]
Use Case: [where to use this palette]
                
Example:
Theme: Ocean Sunset
Primary: Deep Blue (#1E3A8A)
Secondary: Coral Orange (#FF7F50)
Accent: Golden Yellow (#FFD700)
Neutral: Warm Gray (#8B7355)
Background: Cream White (#FFF8DC)
Mood: Calm, warm, inspiring
Use Case: Website, branding, presentations
                
Provide harmonious, professional colors!'''
                
                if dual_ai.ai_provider == 'groq':
                    response = dual_ai.groq_client.chat.completions.create(
                        messages=[{"role": "user", "content": ai_prompt}],
                        model="llama-3.1-8b-instant"
                    )
                    ai_response = response.choices[0].message.content.strip()
                else:
                    response = dual_ai.gemini_model.generate_content(ai_prompt)
                    ai_response = response.text.strip()
                
                return f"Color Palette Generator:\n{ai_response}\n\nTip: Use tools like Coolors.co or Adobe Color for visualization"
                
            except Exception:
                # Fallback color palettes
                palettes = {
                    "modern": ["#2563EB", "#64748B", "#F59E0B", "#EF4444", "#F8FAFC"],
                    "nature": ["#16A34A", "#84CC16", "#EAB308", "#92400E", "#F7FEE7"],
                    "ocean": ["#0EA5E9", "#06B6D4", "#3B82F6", "#1E40AF", "#F0F9FF"]
                }
                
                colors = palettes.get(theme, palettes["modern"])
                result = f"Color Palette: {theme.title()}\n"
                for i, color in enumerate(colors):
                    labels = ["Primary", "Secondary", "Accent", "Neutral", "Background"]
                    result += f"{labels[i]}: {color}\n"
                
                return result
                
        except Exception as e:
            return f"Color palette generator failed: {e}"
    
    def font_viewer(self, query=""):
        try:
            import platform
            
            # Get system info
            system = platform.system()
            
            # Use AI to recommend fonts
            try:
                from engine.dual_ai import dual_ai
                
                ai_prompt = f'''Recommend fonts for: "{query or 'general use'}"
                
Respond ONLY in this format:
Purpose: [use case]
Heading Font: [font name] - [description]
Body Font: [font name] - [description]
Display Font: [font name] - [description]
Monospace: [font name] - [description]
System Fonts: [list of common system fonts]
Web Safe: [web-safe alternatives]
Google Fonts: [free alternatives]
                
Example:
Purpose: Professional presentation
Heading Font: Arial Black - Bold, impactful
Body Font: Calibri - Clean, readable
Display Font: Impact - Strong presence
Monospace: Consolas - Code and data
System Fonts: Arial, Times New Roman, Verdana
Web Safe: Helvetica, Georgia, Courier
Google Fonts: Roboto, Open Sans, Lato
                
Focus on readability and professionalism!'''
                
                if dual_ai.ai_provider == 'groq':
                    response = dual_ai.groq_client.chat.completions.create(
                        messages=[{"role": "user", "content": ai_prompt}],
                        model="llama-3.1-8b-instant"
                    )
                    ai_response = response.choices[0].message.content.strip()
                else:
                    response = dual_ai.gemini_model.generate_content(ai_prompt)
                    ai_response = response.text.strip()
                
                return f"Font Viewer ({system}):\n{ai_response}\n\nUse Character Map (Windows) or Font Book (Mac) to preview fonts"
                
            except Exception:
                # Fallback font recommendations
                common_fonts = {
                    "Windows": ["Arial", "Calibri", "Times New Roman", "Verdana", "Consolas"],
                    "Darwin": ["Helvetica", "San Francisco", "Times", "Menlo", "Monaco"],
                    "Linux": ["DejaVu Sans", "Liberation Sans", "Ubuntu", "Noto Sans"]
                }
                
                fonts = common_fonts.get(system, common_fonts["Windows"])
                result = f"Font Viewer ({system}):\n"
                result += f"Common System Fonts:\n"
                for font in fonts:
                    result += f"- {font}\n"
                
                return result
                
        except Exception as e:
            return f"Font viewer failed: {e}"
    
    def ascii_art_generator(self, query=""):
        try:
            import re
            
            # Extract text to convert
            text_match = re.search(r'ascii\s+(?:art\s+)?(.+)', query.lower())
            if text_match:
                text = text_match.group(1).strip()
            else:
                text = "HELLO"
            
            # Use AI to generate ASCII art
            try:
                from engine.dual_ai import dual_ai
                
                ai_prompt = f'''Create ASCII art for text: "{text}"
                
Respond ONLY with ASCII art using characters like: # * - = + | \\ / _ ^
                
Make it readable and artistic. Example for "HI":

#   #  ###
#   #   #
#####   #
#   #   #
#   #  ###
                
Create similar art for the given text.'''
                
                if dual_ai.ai_provider == 'groq':
                    response = dual_ai.groq_client.chat.completions.create(
                        messages=[{"role": "user", "content": ai_prompt}],
                        model="llama-3.1-8b-instant"
                    )
                    ai_response = response.choices[0].message.content.strip()
                else:
                    response = dual_ai.gemini_model.generate_content(ai_prompt)
                    ai_response = response.text.strip()
                
                return f"ASCII Art Generator:\n{ai_response}"
                
            except Exception:
                # Fallback simple ASCII
                simple_ascii = {
                    "hello": "#   # ##### #     #     #####\n#   # #     #     #     #    \n##### ##### #     #     #####\n#   # #     #     #     #    \n#   # ##### ##### ##### #####",
                    "hi": "#   #  ###\n#   #   #\n#####   #\n#   #   #\n#   #  ###"
                }
                
                art = simple_ascii.get(text.lower(), f"ASCII: {text.upper()}")
                return f"ASCII Art Generator:\n{art}"
                
        except Exception as e:
            return f"ASCII art generator failed: {e}"
    
    def barcode_generator(self, query=""):
        try:
            import re
            
            # Extract data to encode
            data_match = re.search(r'barcode\s+(.+)', query.lower())
            if data_match:
                data = data_match.group(1).strip()
            else:
                data = "123456789"
            
            # Use AI to generate barcode info
            try:
                from engine.dual_ai import dual_ai
                
                ai_prompt = f'''Generate barcode information for: "{data}"
                
Respond ONLY in this format:
Data: [input data]
Type: [barcode type - Code128/EAN/QR/etc]
Format: [numeric/alphanumeric/text]
Use Case: [where this would be used]
Pattern: [simplified visual pattern]
Tools: [recommended generators]
                
Example:
Data: 123456789
Type: Code128
Format: Numeric
Use Case: Product identification
Pattern: |||| | || ||| | |||| |
Tools: Online generators, ZXing, python-barcode
                
Choose appropriate barcode type for the data!'''
                
                if dual_ai.ai_provider == 'groq':
                    response = dual_ai.groq_client.chat.completions.create(
                        messages=[{"role": "user", "content": ai_prompt}],
                        model="llama-3.1-8b-instant"
                    )
                    ai_response = response.choices[0].message.content.strip()
                else:
                    response = dual_ai.gemini_model.generate_content(ai_prompt)
                    ai_response = response.text.strip()
                
                return f"Barcode Generator:\n{ai_response}\n\nRecommended: Use online barcode generators or python-barcode library"
                
            except Exception:
                # Fallback barcode info
                barcode_type = "QR Code" if len(data) > 20 else "Code128"
                return f"Barcode Generator:\nData: {data}\nType: {barcode_type}\nUse online generators like barcode-generator.org"
                
        except Exception as e:
            return f"Barcode generator failed: {e}"
    
    def mind_map_creator(self, query=""):
        try:
            import re
            
            # Extract topic
            topic_match = re.search(r'mind\s*map\s+(.+)', query.lower())
            if topic_match:
                topic = topic_match.group(1).strip()
            else:
                topic = "project planning"
            
            # Use AI to generate mind map structure
            try:
                from engine.dual_ai import dual_ai
                
                ai_prompt = f'''Create a mind map structure for: "{topic}"
                
Respond ONLY in this format:
Central Topic: [main topic]
Branch 1: [subtopic]
  - [detail 1]
  - [detail 2]
Branch 2: [subtopic]
  - [detail 1]
  - [detail 2]
Branch 3: [subtopic]
  - [detail 1]
  - [detail 2]
Connections: [how branches relate]
Colors: [suggested color scheme]
Tools: [recommended mind mapping tools]
                
Example:
Central Topic: Learning Python
Branch 1: Basics
  - Variables and data types
  - Control structures
Branch 2: Advanced
  - Object-oriented programming
  - Libraries and frameworks
Branch 3: Practice
  - Projects
  - Problem solving
Connections: Basics ‚Üí Advanced ‚Üí Practice
Colors: Blue for basics, Green for advanced, Orange for practice
Tools: XMind, MindMeister, Lucidchart
                
Make it comprehensive and logical!'''
                
                if dual_ai.ai_provider == 'groq':
                    response = dual_ai.groq_client.chat.completions.create(
                        messages=[{"role": "user", "content": ai_prompt}],
                        model="llama-3.1-8b-instant"
                    )
                    ai_response = response.choices[0].message.content.strip()
                else:
                    response = dual_ai.gemini_model.generate_content(ai_prompt)
                    ai_response = response.text.strip()
                
                return f"Mind Map Creator:\n{ai_response}\n\nRecommended tools: XMind, MindMeister, or draw.io for digital creation"
                
            except Exception:
                # Fallback mind map structure
                return f"Mind Map Creator:\nCentral Topic: {topic.title()}\nBranch 1: Planning\n  - Goals\n  - Timeline\nBranch 2: Resources\n  - Tools\n  - People\nBranch 3: Implementation\n  - Steps\n  - Milestones\n\nUse XMind or similar tools to create visual mind map"
                
        except Exception as e:
            return f"Mind map creator failed: {e}"
    
    def password_manager(self, query=""):
        try:
            import json
            import os
            import re
            
            try:
                from cryptography.fernet import Fernet  # type: ignore
            except ImportError:
                return "üîê Password manager requires: pip install cryptography"
            
            # Password storage file
            password_file = "passwords.json"
            key_file = "password_key.key"
            
            # Generate or load encryption key
            if not os.path.exists(key_file):
                key = Fernet.generate_key()
                with open(key_file, 'wb') as f:
                    f.write(key)
            else:
                with open(key_file, 'rb') as f:
                    key = f.read()
            
            cipher = Fernet(key)
            
            # Load existing passwords
            passwords = {}
            if os.path.exists(password_file):
                try:
                    with open(password_file, 'r') as f:
                        encrypted_data = json.load(f)
                    for service, encrypted_pass in encrypted_data.items():
                        passwords[service] = cipher.decrypt(encrypted_pass.encode()).decode()
                except:
                    passwords = {}
            
            # Show password command
            if 'show' in query.lower() or 'get' in query.lower():
                service_match = re.search(r'(?:show|get)\s+(?:my\s+)?(\w+)\s+password', query.lower())
                if service_match:
                    service = service_match.group(1).lower()
                    if service in passwords:
                        return f"üîê {service.title()} password: {passwords[service]}"
                    else:
                        return f"üîê No password stored for {service}. Available: {', '.join(passwords.keys())}"
                else:
                    return f"üîê Stored passwords: {', '.join(passwords.keys()) if passwords else 'None'}\nUsage: 'show gmail password'"
            
            # Add password command
            elif 'add' in query.lower() or 'store' in query.lower():
                add_match = re.search(r'(?:add|store)\s+(\w+)\s+password\s+(.+)', query.lower())
                if add_match:
                    service = add_match.group(1).lower()
                    password = add_match.group(2).strip()
                    
                    passwords[service] = password
                    
                    # Encrypt and save
                    encrypted_data = {}
                    for svc, pwd in passwords.items():
                        encrypted_data[svc] = cipher.encrypt(pwd.encode()).decode()
                    
                    with open(password_file, 'w') as f:
                        json.dump(encrypted_data, f)
                    
                    return f" Password for {service} stored securely"
                else:
                    return " Usage: 'add gmail password mypassword123'"
            
            # List passwords
            else:
                if passwords:
                    return f" Password Manager - Stored accounts: {', '.join(passwords.keys())}\nSay 'show [service] password' to retrieve"
                else:
                    return " Password Manager - No passwords stored yet\nUsage: 'add gmail password mypassword123'"
                    
        except Exception as e:
            return f" Password manager failed: {e}"
    
    def startup_manager(self, query=""):
        try:
            import subprocess
            import os
            import re
            
            # Add startup app
            if 'add' in query.lower():
                app_match = re.search(r'add\s+(?:startup\s+)?(\w+)', query.lower())
                if app_match:
                    app_name = app_match.group(1)
                    
                    # Windows startup registry
                    try:
                        import winreg
                        key_path = r"SOFTWARE\Microsoft\Windows\CurrentVersion\Run"
                        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, key_path, 0, winreg.KEY_SET_VALUE)
                        
                        # For demo, we'll add notepad as example
                        app_path = "notepad.exe" if app_name.lower() == "notepad" else f"{app_name}.exe"
                        winreg.SetValueEx(key, app_name, 0, winreg.REG_SZ, app_path)
                        winreg.CloseKey(key)
                        
                        return f"Added {app_name} to startup programs"
                    except Exception as e:
                        return f"Failed to add {app_name} to startup: {e}"
                else:
                    return "Usage: 'add startup notepad' or 'add chrome to startup'"
            
            # Remove startup app
            elif 'remove' in query.lower():
                app_match = re.search(r'remove\s+(?:startup\s+)?(\w+)', query.lower())
                if app_match:
                    app_name = app_match.group(1)
                    
                    try:
                        import winreg
                        key_path = r"SOFTWARE\Microsoft\Windows\CurrentVersion\Run"
                        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, key_path, 0, winreg.KEY_SET_VALUE)
                        
                        winreg.DeleteValue(key, app_name)
                        winreg.CloseKey(key)
                        
                        return f"Removed {app_name} from startup programs"
                    except FileNotFoundError:
                        return f"{app_name} not found in startup programs"
                    except Exception as e:
                        return f"Failed to remove {app_name}: {e}"
                else:
                    return "Usage: 'remove startup notepad'"
            
            # List startup apps
            else:
                try:
                    import winreg
                    key_path = r"SOFTWARE\Microsoft\Windows\CurrentVersion\Run"
                    key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, key_path, 0, winreg.KEY_READ)
                    
                    startup_apps = []
                    i = 0
                    while True:
                        try:
                            name, value, _ = winreg.EnumValue(key, i)
                            startup_apps.append(f"{name}: {value}")
                            i += 1
                        except WindowsError:
                            break
                    
                    winreg.CloseKey(key)
                    
                    if startup_apps:
                        result = "Startup Programs:\n" + "\n".join(startup_apps)
                    else:
                        result = "No custom startup programs found"
                    
                    return result
                    
                except Exception as e:
                    return f"Failed to list startup programs: {e}"
                    
        except Exception as e:
            return f"Startup manager failed: {e}"
    
    def git_helper(self, query=""):
        try:
            import subprocess
            import os
            import re
            
            # Check if in git repository
            try:
                subprocess.run(['git', 'status'], capture_output=True, check=True)
            except subprocess.CalledProcessError:
                return "Not in a git repository. Navigate to a git project first."
            
            # Git commit
            if 'commit' in query.lower():
                message_match = re.search(r'commit\s+["\']?(.+?)["\']?$', query)
                if message_match:
                    commit_message = message_match.group(1).strip()
                else:
                    commit_message = "Auto commit via Jarvis"
                
                try:
                    # Add all changes
                    subprocess.run(['git', 'add', '.'], check=True)
                    
                    # Commit with message
                    result = subprocess.run(['git', 'commit', '-m', commit_message], 
                                          capture_output=True, text=True, check=True)
                    
                    return f"Git commit successful: '{commit_message}'\n{result.stdout}"
                except subprocess.CalledProcessError as e:
                    return f"Git commit failed: {e.stderr}"
            
            # Git push
            elif 'push' in query.lower():
                try:
                    result = subprocess.run(['git', 'push'], capture_output=True, text=True, check=True)
                    return f"Git push successful\n{result.stdout}"
                except subprocess.CalledProcessError as e:
                    # Try with upstream setup if no upstream branch
                    if "no upstream branch" in e.stderr:
                        try:
                            result = subprocess.run(['git', 'push', '--set-upstream', 'origin', 'main'], 
                                                  capture_output=True, text=True, check=True)
                            return f"Git push successful (upstream set)\n{result.stdout}"
                        except subprocess.CalledProcessError as e2:
                            return f"Git push failed: {e2.stderr}"
                    return f"Git push failed: {e.stderr}"
            
            # Git status
            elif 'status' in query.lower():
                try:
                    result = subprocess.run(['git', 'status', '--short'], capture_output=True, text=True, check=True)
                    if result.stdout.strip():
                        return f"Git status:\n{result.stdout}"
                    else:
                        return "Git status: Working directory clean"
                except subprocess.CalledProcessError as e:
                    return f"Git status failed: {e.stderr}"
            
            # Default: show git status
            else:
                try:
                    status_result = subprocess.run(['git', 'status', '--short'], capture_output=True, text=True)
                    branch_result = subprocess.run(['git', 'branch', '--show-current'], capture_output=True, text=True)
                    
                    current_branch = branch_result.stdout.strip()
                    status = status_result.stdout.strip()
                    
                    result = f"Git Helper - Branch: {current_branch}\n"
                    if status:
                        result += f"Changes:\n{status}\n"
                    else:
                        result += "Working directory clean\n"
                    
                    result += "\nCommands: 'git commit message', 'git push', 'git status'"
                    return result
                    
                except subprocess.CalledProcessError:
                    return "Git Helper - Repository status unavailable"
                    
        except FileNotFoundError:
            return "Git not installed. Please install Git first."
        except Exception as e:
            return f"Git helper failed: {e}"
    
    def open_app(self, query=""):
        """Universal app opener - works with any application"""
        try:
            import re
            
            # Extract app name from query
            app_match = re.search(r'(?:open|launch|start|run)\s+(.+)', query.lower())
            if app_match:
                app_name = app_match.group(1).strip()
            else:
                return "Usage: 'open [app name]' - Example: 'open notepad' or 'open chrome'"
            
            # COMPLETE Windows App Mappings - ALL Available Applications
            app_mappings = {
                # === MICROSOFT OFFICE SUITE ===
                'word': 'winword', 'microsoft word': 'winword', 'ms word': 'winword',
                'excel': 'excel', 'microsoft excel': 'excel', 'ms excel': 'excel',
                'powerpoint': 'powerpnt', 'microsoft powerpoint': 'powerpnt', 'ms powerpoint': 'powerpnt', 'ppt': 'powerpnt',
                'outlook': 'OUTLOOK', 'microsoft outlook': 'OUTLOOK', 'ms outlook': 'OUTLOOK',
                'onenote': 'onenote', 'microsoft onenote': 'onenote', 'ms onenote': 'onenote',
                'access': 'msaccess', 'microsoft access': 'msaccess', 'ms access': 'msaccess',
                'publisher': 'mspub', 'microsoft publisher': 'mspub', 'ms publisher': 'mspub',
                'visio': 'visio', 'microsoft visio': 'visio', 'ms visio': 'visio',
                'project': 'winproj', 'microsoft project': 'winproj', 'ms project': 'winproj',
                'teams': 'teams', 'microsoft teams': 'teams', 'ms teams': 'teams',
                'sharepoint': 'sharepoint', 'onedrive': 'onedrive',
                
                # === WEB BROWSERS ===
                'chrome': 'chrome', 'google chrome': 'chrome', 'googlechrome': 'chrome',
                'firefox': 'firefox', 'mozilla firefox': 'firefox', 'mozilla': 'firefox',
                'edge': 'msedge', 'microsoft edge': 'msedge', 'ms edge': 'msedge',
                'opera': 'opera', 'opera gx': 'opera',
                'brave': 'brave', 'brave browser': 'brave',
                'safari': 'safari', 'internet explorer': 'iexplore', 'ie': 'iexplore',
                'tor': 'tor', 'tor browser': 'tor',
                'vivaldi': 'vivaldi', 'waterfox': 'waterfox',
                
                # === WINDOWS BUILT-IN APPS ===
                'camera': 'microsoft.windows.camera:', 'windows camera': 'microsoft.windows.camera:',
                'photos': 'microsoft.windows.photos:', 'windows photos': 'microsoft.windows.photos:',
                'mail': 'hxoutlook', 'windows mail': 'hxoutlook', 'mail app': 'hxoutlook',
                'calendar': 'hxcalendarappimm', 'windows calendar': 'hxcalendarappimm', 'calendar app': 'hxcalendarappimm',
                'calculator': 'calculator', 'calc': 'calculator', 'windows calculator': 'calculator',
                'notepad': 'notepad', 'text editor': 'notepad',
                'wordpad': 'wordpad', 'rich text editor': 'wordpad',
                'paint': 'mspaint', 'microsoft paint': 'mspaint', 'ms paint': 'mspaint',
                'paint 3d': 'ms-paint:', 'microsoft paint 3d': 'ms-paint:', 'paint3d': 'ms-paint:',
                'snipping tool': 'snippingtool', 'screenshot': 'snippingtool', 'snip': 'snippingtool',
                'sticky notes': 'stickynotes', 'notes': 'stickynotes',
                'voice recorder': 'soundrecorder', 'sound recorder': 'soundrecorder', 'recorder': 'soundrecorder',
                'movies tv': 'microsoft.zunevideo:', 'movies and tv': 'microsoft.zunevideo:', 'video player': 'microsoft.zunevideo:',
                'groove music': 'microsoft.zunemusic:', 'music': 'microsoft.zunemusic:', 'music player': 'microsoft.zunemusic:',
                'maps': 'microsoft.windowsmaps:', 'windows maps': 'microsoft.windowsmaps:', 'map': 'microsoft.windowsmaps:',
                'weather': 'microsoft.bingweather:', 'windows weather': 'microsoft.bingweather:', 'weather app': 'microsoft.bingweather:',
                'news': 'microsoft.bingnews:', 'microsoft news': 'microsoft.bingnews:', 'news app': 'microsoft.bingnews:',
                'store': 'ms-windows-store:', 'microsoft store': 'ms-windows-store:', 'windows store': 'ms-windows-store:',
                'xbox': 'microsoft.xboxapp:', 'xbox app': 'microsoft.xboxapp:', 'xbox console companion': 'microsoft.xboxapp:',
                'cortana': 'searchui', 'search': 'searchui',
                'people': 'microsoft.people:', 'contacts': 'microsoft.people:',
                'alarms': 'microsoft.windowsalarms:', 'clock': 'microsoft.windowsalarms:', 'timer': 'microsoft.windowsalarms:',
                'feedback hub': 'microsoft.windowsfeedbackhub:', 'feedback': 'microsoft.windowsfeedbackhub:',
                'get help': 'microsoft.gethelp:', 'help': 'microsoft.gethelp:',
                'tips': 'microsoft.getstarted:', 'get started': 'microsoft.getstarted:',
                'mixed reality portal': 'microsoft.windows.holographic.firstrun:', 'mr portal': 'microsoft.windows.holographic.firstrun:',
                'your phone': 'microsoft.yourphone:', 'phone companion': 'microsoft.yourphone:',
                
                # === SYSTEM TOOLS & UTILITIES ===
                'cmd': 'cmd', 'command prompt': 'cmd', 'command line': 'cmd', 'terminal': 'cmd',
                'powershell': 'powershell', 'windows powershell': 'powershell', 'ps': 'powershell',
                'task manager': 'taskmgr', 'taskmgr': 'taskmgr', 'process manager': 'taskmgr',
                'control panel': 'control', 'control': 'control', 'system settings': 'control',
                'settings': 'ms-settings:', 'windows settings': 'ms-settings:', 'pc settings': 'ms-settings:',
                'file explorer': 'explorer', 'explorer': 'explorer', 'files': 'explorer', 'folder': 'explorer',
                'registry editor': 'regedit', 'regedit': 'regedit', 'registry': 'regedit',
                'device manager': 'devmgmt.msc', 'devices': 'devmgmt.msc',
                'disk management': 'diskmgmt.msc', 'disk manager': 'diskmgmt.msc',
                'services': 'services.msc', 'windows services': 'services.msc',
                'event viewer': 'eventvwr.msc', 'events': 'eventvwr.msc', 'logs': 'eventvwr.msc',
                'system information': 'msinfo32', 'system info': 'msinfo32', 'sysinfo': 'msinfo32',
                'system configuration': 'msconfig', 'msconfig': 'msconfig', 'boot config': 'msconfig',
                'resource monitor': 'resmon', 'resmon': 'resmon', 'performance': 'resmon',
                'performance monitor': 'perfmon', 'perfmon': 'perfmon',
                'computer management': 'compmgmt.msc', 'management console': 'compmgmt.msc',
                'disk cleanup': 'cleanmgr', 'cleanup': 'cleanmgr',
                'defragment': 'dfrgui', 'disk defragmenter': 'dfrgui',
                'character map': 'charmap', 'charmap': 'charmap', 'symbols': 'charmap',
                'magnifier': 'magnify', 'zoom': 'magnify', 'screen magnifier': 'magnify',
                'narrator': 'narrator', 'screen reader': 'narrator',
                'on screen keyboard': 'osk', 'virtual keyboard': 'osk', 'osk': 'osk',
                'remote desktop': 'mstsc', 'rdp': 'mstsc', 'remote connection': 'mstsc',
                'windows defender': 'msascuil', 'defender': 'msascuil', 'antivirus': 'msascuil',
                'firewall': 'wf.msc', 'windows firewall': 'wf.msc',
                'group policy': 'gpedit.msc', 'gpedit': 'gpedit.msc', 'policy editor': 'gpedit.msc',
                'local users': 'lusrmgr.msc', 'user manager': 'lusrmgr.msc',
                'certificate manager': 'certmgr.msc', 'certificates': 'certmgr.msc',
                'component services': 'dcomcnfg', 'dcom': 'dcomcnfg',
                'iis manager': 'inetmgr', 'internet information services': 'inetmgr',
                
                # === DEVELOPMENT TOOLS ===
                'vscode': 'code', 'vs code': 'code', 'visual studio code': 'code', 'code': 'code',
                'visual studio': 'devenv', 'vs': 'devenv', 'visual studio 2022': 'devenv', 'visual studio 2019': 'devenv',
                'git bash': 'git-bash', 'git': 'git-bash', 'bash': 'git-bash',
                'github desktop': 'githubdesktop', 'github': 'githubdesktop',
                'android studio': 'studio64', 'android': 'studio64',
                'intellij': 'idea64', 'intellij idea': 'idea64', 'idea': 'idea64',
                'pycharm': 'pycharm64', 'pycharm community': 'pycharm64', 'pycharm professional': 'pycharm64',
                'sublime text': 'sublime_text', 'sublime': 'sublime_text',
                'atom': 'atom', 'atom editor': 'atom',
                'brackets': 'brackets', 'adobe brackets': 'brackets',
                'notepad++': 'notepad++', 'notepadplusplus': 'notepad++', 'npp': 'notepad++',
                'eclipse': 'eclipse', 'eclipse ide': 'eclipse',
                'netbeans': 'netbeans', 'netbeans ide': 'netbeans',
                'webstorm': 'webstorm', 'phpstorm': 'phpstorm', 'clion': 'clion',
                'xampp': 'xampp-control', 'wamp': 'wampmanager', 'laragon': 'laragon',
                'docker': 'docker desktop', 'docker desktop': 'docker desktop',
                'postman': 'postman', 'insomnia': 'insomnia',
                'sourcetree': 'sourcetree', 'gitkraken': 'gitkraken',
                'unity': 'unity', 'unity hub': 'unity hub', 'unreal engine': 'unrealengine',
                
                # === MEDIA & ENTERTAINMENT ===
                'spotify': 'spotify', 'spotify music': 'spotify',
                'vlc': 'vlc', 'vlc media player': 'vlc', 'vlc player': 'vlc',
                'windows media player': 'wmplayer', 'media player': 'wmplayer', 'wmp': 'wmplayer',
                'itunes': 'itunes', 'apple music': 'itunes',
                'audacity': 'audacity', 'audio editor': 'audacity',
                'obs': 'obs64', 'obs studio': 'obs64', 'streaming': 'obs64',
                'handbrake': 'handbrake', 'video converter': 'handbrake',
                'kodi': 'kodi', 'media center': 'kodi',
                'plex': 'plex', 'plex media server': 'plex',
                'netflix': 'microsoft.netflix:', 'youtube': 'microsoft.youtube:',
                'amazon prime': 'primevideo', 'disney plus': 'disney+',
                'twitch': 'twitch', 'youtube music': 'youtube music',
                'foobar2000': 'foobar2000', 'winamp': 'winamp',
                'mpc': 'mpc-hc64', 'media player classic': 'mpc-hc64',
                'potplayer': 'potplayermini64', 'kmplayer': 'kmplayer',
                'adobe premiere': 'premiere', 'premiere pro': 'premiere',
                'adobe after effects': 'afterfx', 'after effects': 'afterfx',
                'davinci resolve': 'resolve', 'final cut': 'final cut pro',
                'camtasia': 'camtasia', 'bandicam': 'bandicam',
                
                # === COMMUNICATION ===
                'discord': 'discord', 'discord app': 'discord',
                'skype': 'skype', 'skype for business': 'lync',
                'zoom': 'zoom', 'zoom meetings': 'zoom',
                'whatsapp': 'whatsapp', 'whatsapp desktop': 'whatsapp',
                'telegram': 'telegram', 'telegram desktop': 'telegram',
                'slack': 'slack', 'slack desktop': 'slack',
                'signal': 'signal', 'signal desktop': 'signal',
                'viber': 'viber', 'viber desktop': 'viber',
                'line': 'line', 'wechat': 'wechat', 'qq': 'qq',
                'facebook messenger': 'messenger', 'messenger': 'messenger',
                'google meet': 'meet', 'google hangouts': 'hangouts',
                'webex': 'webex', 'cisco webex': 'webex',
                'gotomeeting': 'gotomeeting', 'teamviewer': 'teamviewer',
                
                # === GAMING ===
                'steam': 'steam', 'steam client': 'steam',
                'epic games': 'epicgameslauncher', 'epic': 'epicgameslauncher', 'epic launcher': 'epicgameslauncher',
                'origin': 'origin', 'ea origin': 'origin', 'ea desktop': 'eadesktop',
                'uplay': 'uplay', 'ubisoft connect': 'ubisoftconnect',
                'battle.net': 'battle.net', 'battlenet': 'battle.net', 'blizzard': 'battle.net',
                'gog galaxy': 'goggalaxy', 'gog': 'goggalaxy',
                'minecraft': 'minecraft', 'minecraft launcher': 'minecraftlauncher',
                'roblox': 'roblox', 'roblox player': 'robloxplayerbeta',
                'xbox game bar': 'gamebar', 'game bar': 'gamebar',
                'nvidia geforce': 'geforce experience', 'geforce experience': 'geforce experience',
                'amd radeon': 'radeon software', 'radeon software': 'radeon software',
                'msi afterburner': 'msiafterburner', 'afterburner': 'msiafterburner',
                'fraps': 'fraps', 'bandicam': 'bandicam',
                
                # === CREATIVE & DESIGN ===
                'photoshop': 'photoshop', 'adobe photoshop': 'photoshop', 'ps': 'photoshop',
                'illustrator': 'illustrator', 'adobe illustrator': 'illustrator', 'ai': 'illustrator',
                'indesign': 'indesign', 'adobe indesign': 'indesign', 'id': 'indesign',
                'lightroom': 'lightroom', 'adobe lightroom': 'lightroom', 'lr': 'lightroom',
                'acrobat': 'acrobat', 'adobe acrobat': 'acrobat', 'pdf reader': 'acrobat',
                'dreamweaver': 'dreamweaver', 'adobe dreamweaver': 'dreamweaver',
                'animate': 'animate', 'adobe animate': 'animate', 'flash': 'animate',
                'xd': 'adobe xd', 'adobe xd': 'adobe xd',
                'gimp': 'gimp', 'gnu image manipulation': 'gimp',
                'blender': 'blender', '3d modeling': 'blender',
                'figma': 'figma', 'sketch': 'sketch',
                'canva': 'canva', 'canva desktop': 'canva',
                'coreldraw': 'coreldraw', 'corel': 'coreldraw',
                'paint.net': 'paintdotnet', 'paintnet': 'paintdotnet',
                'krita': 'krita', 'inkscape': 'inkscape',
                'autodesk maya': 'maya', 'maya': 'maya',
                'autocad': 'autocad', 'autodesk autocad': 'autocad',
                '3ds max': '3dsmax', 'autodesk 3ds max': '3dsmax',
                'solidworks': 'solidworks', 'fusion 360': 'fusion360',
                
                # === PRODUCTIVITY ===
                'notion': 'notion', 'notion desktop': 'notion',
                'evernote': 'evernote', 'evernote desktop': 'evernote',
                'trello': 'trello', 'trello desktop': 'trello',
                'todoist': 'todoist', 'todoist desktop': 'todoist',
                'asana': 'asana', 'monday': 'monday',
                'clickup': 'clickup', 'airtable': 'airtable',
                'obsidian': 'obsidian', 'roam research': 'roam',
                'logseq': 'logseq', 'remnote': 'remnote',
                'anki': 'anki', 'flashcards': 'anki',
                'zotero': 'zotero', 'mendeley': 'mendeley',
                
                # === CLOUD STORAGE ===
                'dropbox': 'dropbox', 'dropbox desktop': 'dropbox',
                'google drive': 'googledrivefs', 'drive': 'googledrivefs',
                'icloud': 'icloud', 'apple icloud': 'icloud',
                'box': 'box', 'box sync': 'box sync',
                'mega': 'megasync', 'megasync': 'megasync',
                'pcloud': 'pcloud', 'sync.com': 'sync',
                
                # === UTILITIES & TOOLS ===
                'winrar': 'winrar', 'rar': 'winrar',
                '7zip': '7zfm', '7-zip': '7zfm', 'seven zip': '7zfm',
                'winzip': 'winzip32', 'zip': 'winzip32',
                'peazip': 'peazip', 'bandizip': 'bandizip',
                'ccleaner': 'ccleaner', 'system cleaner': 'ccleaner',
                'malwarebytes': 'malwarebytes', 'mbam': 'malwarebytes',
                'avast': 'avastui', 'avg': 'avgui', 'norton': 'norton',
                'kaspersky': 'kaspersky', 'bitdefender': 'bitdefender',
                'anydesk': 'anydesk', 'remote access': 'anydesk',
                'putty': 'putty', 'ssh client': 'putty',
                'filezilla': 'filezilla', 'ftp client': 'filezilla',
                'wireshark': 'wireshark', 'network analyzer': 'wireshark',
                'nmap': 'nmap', 'network scanner': 'nmap',
                'virtualbox': 'virtualbox', 'vm': 'virtualbox',
                'vmware': 'vmware', 'vmware workstation': 'vmware',
                'hyper-v': 'virtmgmt.msc', 'hyperv': 'virtmgmt.msc',
                'cpu-z': 'cpuz', 'gpu-z': 'gpuz',
                'hwinfo': 'hwinfo64', 'speccy': 'speccy',
                'crystaldiskinfo': 'diskinfo64', 'crystaldiskmark': 'diskmark64',
                'process explorer': 'procexp64', 'process monitor': 'procmon',
                'autoruns': 'autoruns64', 'sysinternals': 'procexp64',
                'everything': 'everything', 'file search': 'everything',
                'powertoys': 'powertoys', 'microsoft powertoys': 'powertoys',
                'f.lux': 'flux', 'blue light filter': 'flux',
                'rainmeter': 'rainmeter', 'desktop customization': 'rainmeter',
                'wallpaper engine': 'wallpaper32', 'animated wallpaper': 'wallpaper32',
                
                # === BROWSERS WITH MODES ===
                'chrome incognito': 'chrome --incognito',
                'firefox private': 'firefox -private-window',
                'edge inprivate': 'msedge --inprivate',
                'chrome dev tools': 'chrome --auto-open-devtools-for-tabs',
                
                # === SYSTEM SHORTCUTS ===
                'run': 'explorer shell:AppsFolder\\Microsoft.Windows.StartMenuExperienceHost_cw5n1h2txyewy!App',
                'startup folder': 'shell:startup',
                'temp folder': 'temp',
                'system32': 'system32',
                'program files': 'explorer "C:\\Program Files"',
                'documents': 'explorer shell:MyComputerFolder',
                'downloads': 'explorer shell:Downloads',
                'desktop': 'explorer shell:Desktop',
                'pictures': 'explorer shell:MyPictures',
                'music folder': 'explorer shell:MyMusic',
                'videos': 'explorer shell:MyVideo'
            }
            
            # Use mapped name if available (check exact match first, then partial)
            actual_app_name = app_mappings.get(app_name.lower(), app_name)
            
            # If no exact match, try partial matching
            if actual_app_name == app_name:
                for key, value in app_mappings.items():
                    if app_name.lower() in key or key in app_name.lower():
                        actual_app_name = value
                        break
            
            # AI fallback if no mapping found
            if actual_app_name == app_name:
                try:
                    from engine.dual_ai import dual_ai
                    ai_prompt = f'What is the exact executable name for "{app_name}" on Windows? Respond with ONLY the executable name (like "notepad" or "chrome"), no explanations.'
                    
                    if dual_ai.ai_provider == 'groq':
                        response = dual_ai.groq_client.chat.completions.create(
                            messages=[{"role": "user", "content": ai_prompt}],
                            model="llama-3.1-8b-instant",
                            max_tokens=20
                        )
                        ai_app_name = response.choices[0].message.content.strip().lower()
                        if ai_app_name and len(ai_app_name) < 50:
                            actual_app_name = ai_app_name
                except Exception:
                    pass
            
            # Try multiple methods to open the app
            opened = False
            
            # Method 1: Windows start command with mapped name
            try:
                subprocess.run(f'start "" "{actual_app_name}"', shell=True, check=True)
                opened = True
            except:
                pass
            
            # Method 1.1: Try original app name with start
            if not opened:
                try:
                    subprocess.run(f'start "" "{app_name}"', shell=True, check=True)
                    opened = True
                except:
                    pass
            
            # Method 1.5: Comprehensive Office app detection
            if not opened and app_name.lower() in ['outlook', 'word', 'excel', 'powerpoint', 'onenote', 'access', 'publisher']:
                # All possible Office installation paths
                office_versions = ['Office16', 'Office15', 'Office14', 'Office12']
                office_roots = [
                    'C:\\Program Files\\Microsoft Office\\root',
                    'C:\\Program Files (x86)\\Microsoft Office\\root',
                    'C:\\Program Files\\Microsoft Office',
                    'C:\\Program Files (x86)\\Microsoft Office'
                ]
                
                # Try all combinations
                for root in office_roots:
                    for version in office_versions:
                        office_path = f"{root}\\{version}\\{actual_app_name}.exe"
                        if os.path.exists(office_path):
                            try:
                                subprocess.Popen(office_path)
                                opened = True
                                break
                            except:
                                pass
                    if opened:
                        break
                
                # Also try direct Office folder
                if not opened:
                    direct_paths = [
                        f"C:\\Program Files\\Microsoft Office\\{actual_app_name}.exe",
                        f"C:\\Program Files (x86)\\Microsoft Office\\{actual_app_name}.exe"
                    ]
                    for path in direct_paths:
                        if os.path.exists(path):
                            try:
                                subprocess.Popen(path)
                                opened = True
                                break
                            except:
                                pass
            
            # Method 2: PowerShell Get-Command to find executable
            if not opened:
                try:
                    result = subprocess.run(f'powershell "Get-Command {actual_app_name} -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Source"', 
                                          shell=True, capture_output=True, text=True)
                    if result.stdout.strip():
                        exe_path = result.stdout.strip()
                        subprocess.Popen(exe_path)
                        opened = True
                except:
                    pass
            
            # Method 2.1: Try with original name
            if not opened:
                try:
                    result = subprocess.run(f'powershell "Get-Command {app_name} -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Source"', 
                                          shell=True, capture_output=True, text=True)
                    if result.stdout.strip():
                        exe_path = result.stdout.strip()
                        subprocess.Popen(exe_path)
                        opened = True
                except:
                    pass
            
            # Method 3: Where command to locate executable
            if not opened:
                try:
                    result = subprocess.run(f'where {actual_app_name}', shell=True, capture_output=True, text=True)
                    if result.returncode == 0 and result.stdout.strip():
                        exe_path = result.stdout.strip().split('\n')[0]
                        subprocess.Popen(exe_path)
                        opened = True
                except:
                    pass
            
            # Method 3.1: Where with .exe extension
            if not opened:
                try:
                    result = subprocess.run(f'where {actual_app_name}.exe', shell=True, capture_output=True, text=True)
                    if result.returncode == 0 and result.stdout.strip():
                        exe_path = result.stdout.strip().split('\n')[0]
                        subprocess.Popen(exe_path)
                        opened = True
                except:
                    pass
            
            # Method 4: Try original name if mapping failed
            if not opened and actual_app_name != app_name:
                try:
                    subprocess.run(f'start {app_name}', shell=True, check=True)
                    opened = True
                except:
                    pass
            
            # Method 5: Search system and program files
            if not opened:
                search_paths = [
                    f"C:\\Windows\\System32\\{actual_app_name}.exe",
                    f"C:\\Windows\\{actual_app_name}.exe",
                    f"C:\\Program Files\\{app_name}\\{actual_app_name}.exe",
                    f"C:\\Program Files (x86)\\{app_name}\\{actual_app_name}.exe",
                    f"C:\\Program Files\\{actual_app_name}\\{actual_app_name}.exe",
                    f"C:\\Program Files (x86)\\{actual_app_name}\\{actual_app_name}.exe"
                ]
                
                for path in search_paths:
                    if os.path.exists(path):
                        try:
                            subprocess.Popen(path)
                            opened = True
                            break
                        except:
                            pass
            
            # Method 6: Use Windows Registry to find Office apps
            if not opened and app_name.lower() in ['outlook', 'word', 'excel', 'powerpoint']:
                try:
                    import winreg
                    
                    # Check registry for Office installation
                    reg_paths = [
                        r"SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\{}.exe".format(actual_app_name),
                        r"SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\App Paths\{}.exe".format(actual_app_name)
                    ]
                    
                    for reg_path in reg_paths:
                        try:
                            key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, reg_path)
                            exe_path = winreg.QueryValue(key, "")
                            winreg.CloseKey(key)
                            
                            if exe_path and os.path.exists(exe_path):
                                subprocess.Popen(exe_path)
                                opened = True
                                break
                        except:
                            continue
                            
                except Exception:
                    pass
            
            if opened:
                return f"Opened {app_name} successfully"
            else:
                return f"Could not open {app_name}. Try the full application name or check if it's installed."
                        
        except Exception as e:
            return f"App opener failed: {e}"
    
    def close_app(self, query=""):
        """Universal app closer - works with any running application"""
        try:
            import re
            
            # Extract app name from query
            app_match = re.search(r'(?:close|quit|exit|kill)\s+(.+)', query.lower())
            if app_match:
                app_name = app_match.group(1).strip()
            else:
                return "Usage: 'close [app name]' - Example: 'close notepad' or 'close chrome'"
            
            # COMPLETE Process Name Mappings for Closing ALL Applications
            app_mappings = {
                # === MICROSOFT OFFICE SUITE ===
                'word': 'WINWORD', 'microsoft word': 'WINWORD', 'ms word': 'WINWORD',
                'excel': 'EXCEL', 'microsoft excel': 'EXCEL', 'ms excel': 'EXCEL',
                'powerpoint': 'POWERPNT', 'microsoft powerpoint': 'POWERPNT', 'ms powerpoint': 'POWERPNT', 'ppt': 'POWERPNT',
                'outlook': 'OUTLOOK', 'microsoft outlook': 'OUTLOOK', 'ms outlook': 'OUTLOOK',
                'onenote': 'ONENOTE', 'microsoft onenote': 'ONENOTE', 'ms onenote': 'ONENOTE',
                'access': 'MSACCESS', 'microsoft access': 'MSACCESS', 'ms access': 'MSACCESS',
                'publisher': 'MSPUB', 'microsoft publisher': 'MSPUB', 'ms publisher': 'MSPUB',
                'visio': 'VISIO', 'microsoft visio': 'VISIO', 'ms visio': 'VISIO',
                'project': 'WINPROJ', 'microsoft project': 'WINPROJ', 'ms project': 'WINPROJ',
                'teams': 'Teams', 'microsoft teams': 'Teams', 'ms teams': 'Teams',
                'sharepoint': 'sharepoint', 'onedrive': 'OneDrive',
                
                # === WEB BROWSERS ===
                'chrome': 'chrome', 'google chrome': 'chrome', 'googlechrome': 'chrome',
                'firefox': 'firefox', 'mozilla firefox': 'firefox', 'mozilla': 'firefox',
                'edge': 'msedge', 'microsoft edge': 'msedge', 'ms edge': 'msedge',
                'opera': 'opera', 'opera gx': 'opera',
                'brave': 'brave', 'brave browser': 'brave',
                'safari': 'safari', 'internet explorer': 'iexplore', 'ie': 'iexplore',
                'tor': 'tor', 'tor browser': 'tor',
                'vivaldi': 'vivaldi', 'waterfox': 'waterfox',
                
                # === WINDOWS BUILT-IN APPS ===
                'camera': 'WindowsCamera', 'windows camera': 'WindowsCamera',
                'photos': 'Microsoft.Photos', 'windows photos': 'Microsoft.Photos',
                'mail': 'HxOutlook', 'windows mail': 'HxOutlook', 'mail app': 'HxOutlook',
                'calendar': 'HxCalendarAppImm', 'windows calendar': 'HxCalendarAppImm', 'calendar app': 'HxCalendarAppImm',
                'calculator': 'Calculator', 'calc': 'Calculator', 'windows calculator': 'Calculator',
                'notepad': 'notepad', 'text editor': 'notepad',
                'wordpad': 'wordpad', 'rich text editor': 'wordpad',
                'paint': 'mspaint', 'microsoft paint': 'mspaint', 'ms paint': 'mspaint',
                'paint 3d': 'PaintStudio.View', 'microsoft paint 3d': 'PaintStudio.View', 'paint3d': 'PaintStudio.View',
                'snipping tool': 'SnippingTool', 'screenshot': 'SnippingTool', 'snip': 'SnippingTool',
                'sticky notes': 'StickyNotes', 'notes': 'StickyNotes',
                'voice recorder': 'SoundRecorder', 'sound recorder': 'SoundRecorder', 'recorder': 'SoundRecorder',
                'movies tv': 'Video.UI', 'movies and tv': 'Video.UI', 'video player': 'Video.UI',
                'groove music': 'Music.UI', 'music': 'Music.UI', 'music player': 'Music.UI',
                'maps': 'Maps', 'windows maps': 'Maps', 'map': 'Maps',
                'weather': 'Microsoft.BingWeather', 'windows weather': 'Microsoft.BingWeather', 'weather app': 'Microsoft.BingWeather',
                'news': 'Microsoft.BingNews', 'microsoft news': 'Microsoft.BingNews', 'news app': 'Microsoft.BingNews',
                'store': 'WinStore.App', 'microsoft store': 'WinStore.App', 'windows store': 'WinStore.App',
                'xbox': 'XboxApp', 'xbox app': 'XboxApp', 'xbox console companion': 'XboxApp',
                'cortana': 'SearchUI', 'search': 'SearchUI',
                'people': 'Microsoft.People', 'contacts': 'Microsoft.People',
                'alarms': 'Microsoft.WindowsAlarms', 'clock': 'Microsoft.WindowsAlarms', 'timer': 'Microsoft.WindowsAlarms',
                'feedback hub': 'Microsoft.WindowsFeedbackHub', 'feedback': 'Microsoft.WindowsFeedbackHub',
                'get help': 'Microsoft.GetHelp', 'help': 'Microsoft.GetHelp',
                'tips': 'Microsoft.Getstarted', 'get started': 'Microsoft.Getstarted',
                'mixed reality portal': 'MixedRealityPortal', 'mr portal': 'MixedRealityPortal',
                'your phone': 'YourPhone', 'phone companion': 'YourPhone',
                
                # === SYSTEM TOOLS & UTILITIES ===
                'cmd': 'cmd', 'command prompt': 'cmd', 'command line': 'cmd', 'terminal': 'cmd',
                'powershell': 'powershell', 'windows powershell': 'powershell', 'ps': 'powershell',
                'task manager': 'Taskmgr', 'taskmgr': 'Taskmgr', 'process manager': 'Taskmgr',
                'control panel': 'control', 'control': 'control', 'system settings': 'control',
                'file explorer': 'explorer', 'explorer': 'explorer', 'files': 'explorer', 'folder': 'explorer',
                'registry editor': 'regedit', 'regedit': 'regedit', 'registry': 'regedit',
                'device manager': 'mmc', 'devices': 'mmc',
                'disk management': 'mmc', 'disk manager': 'mmc',
                'services': 'mmc', 'windows services': 'mmc',
                'event viewer': 'mmc', 'events': 'mmc', 'logs': 'mmc',
                'system information': 'msinfo32', 'system info': 'msinfo32', 'sysinfo': 'msinfo32',
                'system configuration': 'msconfig', 'msconfig': 'msconfig', 'boot config': 'msconfig',
                'resource monitor': 'resmon', 'resmon': 'resmon', 'performance': 'resmon',
                'performance monitor': 'perfmon', 'perfmon': 'perfmon',
                'computer management': 'mmc', 'management console': 'mmc',
                'disk cleanup': 'cleanmgr', 'cleanup': 'cleanmgr',
                'defragment': 'dfrgui', 'disk defragmenter': 'dfrgui',
                'character map': 'charmap', 'charmap': 'charmap', 'symbols': 'charmap',
                'magnifier': 'Magnify', 'zoom': 'Magnify', 'screen magnifier': 'Magnify',
                'narrator': 'Narrator', 'screen reader': 'Narrator',
                'on screen keyboard': 'osk', 'virtual keyboard': 'osk', 'osk': 'osk',
                'remote desktop': 'mstsc', 'rdp': 'mstsc', 'remote connection': 'mstsc',
                'windows defender': 'MsMpEng', 'defender': 'MsMpEng', 'antivirus': 'MsMpEng',
                'firewall': 'mmc', 'windows firewall': 'mmc',
                'group policy': 'mmc', 'gpedit': 'mmc', 'policy editor': 'mmc',
                'local users': 'mmc', 'user manager': 'mmc',
                'certificate manager': 'mmc', 'certificates': 'mmc',
                'component services': 'dcomcnfg', 'dcom': 'dcomcnfg',
                'iis manager': 'inetmgr', 'internet information services': 'inetmgr',
                
                # === DEVELOPMENT TOOLS ===
                'vscode': 'Code', 'vs code': 'Code', 'visual studio code': 'Code', 'code': 'Code',
                'visual studio': 'devenv', 'vs': 'devenv', 'visual studio 2022': 'devenv', 'visual studio 2019': 'devenv',
                'git bash': 'mintty', 'git': 'mintty', 'bash': 'mintty',
                'github desktop': 'GitHubDesktop', 'github': 'GitHubDesktop',
                'android studio': 'studio64', 'android': 'studio64',
                'intellij': 'idea64', 'intellij idea': 'idea64', 'idea': 'idea64',
                'pycharm': 'pycharm64', 'pycharm community': 'pycharm64', 'pycharm professional': 'pycharm64',
                'sublime text': 'sublime_text', 'sublime': 'sublime_text',
                'atom': 'atom', 'atom editor': 'atom',
                'brackets': 'Brackets', 'adobe brackets': 'Brackets',
                'notepad++': 'notepad++', 'notepadplusplus': 'notepad++', 'npp': 'notepad++',
                'eclipse': 'eclipse', 'eclipse ide': 'eclipse',
                'netbeans': 'netbeans', 'netbeans ide': 'netbeans',
                'webstorm': 'webstorm', 'phpstorm': 'phpstorm', 'clion': 'clion',
                'xampp': 'xampp-control', 'wamp': 'wampmanager', 'laragon': 'laragon',
                'docker': 'Docker Desktop', 'docker desktop': 'Docker Desktop',
                'postman': 'Postman', 'insomnia': 'Insomnia',
                'sourcetree': 'SourceTree', 'gitkraken': 'GitKraken',
                'unity': 'Unity', 'unity hub': 'Unity Hub', 'unreal engine': 'UnrealEngine',
                
                # === MEDIA & ENTERTAINMENT ===
                'spotify': 'Spotify', 'spotify music': 'Spotify',
                'vlc': 'vlc', 'vlc media player': 'vlc', 'vlc player': 'vlc',
                'windows media player': 'wmplayer', 'media player': 'wmplayer', 'wmp': 'wmplayer',
                'itunes': 'iTunes', 'apple music': 'iTunes',
                'audacity': 'audacity', 'audio editor': 'audacity',
                'obs': 'obs64', 'obs studio': 'obs64', 'streaming': 'obs64',
                'handbrake': 'HandBrake', 'video converter': 'HandBrake',
                'kodi': 'Kodi', 'media center': 'Kodi',
                'plex': 'Plex Media Server', 'plex media server': 'Plex Media Server',
                'netflix': 'Netflix', 'youtube': 'chrome',
                'amazon prime': 'PrimeVideo', 'disney plus': 'Disney+',
                'twitch': 'Twitch', 'youtube music': 'YouTube Music',
                'foobar2000': 'foobar2000', 'winamp': 'winamp',
                'mpc': 'mpc-hc64', 'media player classic': 'mpc-hc64',
                'potplayer': 'PotPlayerMini64', 'kmplayer': 'KMPlayer',
                'adobe premiere': 'Adobe Premiere Pro', 'premiere pro': 'Adobe Premiere Pro',
                'adobe after effects': 'AfterFX', 'after effects': 'AfterFX',
                'davinci resolve': 'Resolve', 'final cut': 'Final Cut Pro',
                'camtasia': 'CamtasiaStudio', 'bandicam': 'bandicam',
                
                # === COMMUNICATION ===
                'discord': 'Discord', 'discord app': 'Discord',
                'skype': 'Skype', 'skype for business': 'lync',
                'zoom': 'Zoom', 'zoom meetings': 'Zoom',
                'whatsapp': 'WhatsApp', 'whatsapp desktop': 'WhatsApp',
                'telegram': 'Telegram', 'telegram desktop': 'Telegram',
                'slack': 'slack', 'slack desktop': 'slack',
                'signal': 'Signal', 'signal desktop': 'Signal',
                'viber': 'Viber', 'viber desktop': 'Viber',
                'line': 'LINE', 'wechat': 'WeChat', 'qq': 'QQ',
                'facebook messenger': 'Messenger', 'messenger': 'Messenger',
                'google meet': 'Meet', 'google hangouts': 'Hangouts',
                'webex': 'CiscoWebexMeetings', 'cisco webex': 'CiscoWebexMeetings',
                'gotomeeting': 'GoToMeeting', 'teamviewer': 'TeamViewer',
                
                # === GAMING ===
                'steam': 'steam', 'steam client': 'steam',
                'epic games': 'EpicGamesLauncher', 'epic': 'EpicGamesLauncher', 'epic launcher': 'EpicGamesLauncher',
                'origin': 'Origin', 'ea origin': 'Origin', 'ea desktop': 'EADesktop',
                'uplay': 'upc', 'ubisoft connect': 'UbisoftConnect',
                'battle.net': 'Battle.net', 'battlenet': 'Battle.net', 'blizzard': 'Battle.net',
                'gog galaxy': 'GalaxyClient', 'gog': 'GalaxyClient',
                'minecraft': 'Minecraft', 'minecraft launcher': 'MinecraftLauncher',
                'roblox': 'RobloxPlayerBeta', 'roblox player': 'RobloxPlayerBeta',
                'xbox game bar': 'GameBar', 'game bar': 'GameBar',
                'nvidia geforce': 'NVIDIA GeForce Experience', 'geforce experience': 'NVIDIA GeForce Experience',
                'amd radeon': 'RadeonSoftware', 'radeon software': 'RadeonSoftware',
                'msi afterburner': 'MSIAfterburner', 'afterburner': 'MSIAfterburner',
                'fraps': 'fraps', 'bandicam': 'bandicam',
                
                # === CREATIVE & DESIGN ===
                'photoshop': 'Photoshop', 'adobe photoshop': 'Photoshop', 'ps': 'Photoshop',
                'illustrator': 'Illustrator', 'adobe illustrator': 'Illustrator', 'ai': 'Illustrator',
                'indesign': 'InDesign', 'adobe indesign': 'InDesign', 'id': 'InDesign',
                'lightroom': 'Lightroom', 'adobe lightroom': 'Lightroom', 'lr': 'Lightroom',
                'acrobat': 'Acrobat', 'adobe acrobat': 'Acrobat', 'pdf reader': 'Acrobat',
                'dreamweaver': 'Dreamweaver', 'adobe dreamweaver': 'Dreamweaver',
                'animate': 'Animate', 'adobe animate': 'Animate', 'flash': 'Animate',
                'xd': 'Adobe XD', 'adobe xd': 'Adobe XD',
                'gimp': 'gimp', 'gnu image manipulation': 'gimp',
                'blender': 'blender', '3d modeling': 'blender',
                'figma': 'Figma', 'sketch': 'Sketch',
                'canva': 'Canva', 'canva desktop': 'Canva',
                'coreldraw': 'CorelDRAW', 'corel': 'CorelDRAW',
                'paint.net': 'PaintDotNet', 'paintnet': 'PaintDotNet',
                'krita': 'krita', 'inkscape': 'inkscape',
                'autodesk maya': 'maya', 'maya': 'maya',
                'autocad': 'acad', 'autodesk autocad': 'acad',
                '3ds max': '3dsmax', 'autodesk 3ds max': '3dsmax',
                'solidworks': 'SLDWORKS', 'fusion 360': 'Fusion360',
                
                # === PRODUCTIVITY ===
                'notion': 'Notion', 'notion desktop': 'Notion',
                'evernote': 'Evernote', 'evernote desktop': 'Evernote',
                'trello': 'Trello', 'trello desktop': 'Trello',
                'todoist': 'Todoist', 'todoist desktop': 'Todoist',
                'asana': 'Asana', 'monday': 'Monday',
                'clickup': 'ClickUp', 'airtable': 'Airtable',
                'obsidian': 'Obsidian', 'roam research': 'Roam',
                'logseq': 'Logseq', 'remnote': 'RemNote',
                'anki': 'anki', 'flashcards': 'anki',
                'zotero': 'zotero', 'mendeley': 'Mendeley Desktop',
                
                # === CLOUD STORAGE ===
                'dropbox': 'Dropbox', 'dropbox desktop': 'Dropbox',
                'google drive': 'GoogleDriveFS', 'drive': 'GoogleDriveFS',
                'icloud': 'iCloudServices', 'apple icloud': 'iCloudServices',
                'box': 'Box', 'box sync': 'Box Sync',
                'mega': 'MEGAsync', 'megasync': 'MEGAsync',
                'pcloud': 'pCloud', 'sync.com': 'Sync',
                
                # === UTILITIES & TOOLS ===
                'winrar': 'WinRAR', 'rar': 'WinRAR',
                '7zip': '7zFM', '7-zip': '7zFM', 'seven zip': '7zFM',
                'winzip': 'WINZIP32', 'zip': 'WINZIP32',
                'peazip': 'peazip', 'bandizip': 'Bandizip',
                'ccleaner': 'CCleaner64', 'system cleaner': 'CCleaner64',
                'malwarebytes': 'mbam', 'mbam': 'mbam',
                'avast': 'AvastUI', 'avg': 'AVGUI', 'norton': 'Norton',
                'kaspersky': 'Kaspersky', 'bitdefender': 'Bitdefender',
                'anydesk': 'AnyDesk', 'remote access': 'AnyDesk',
                'putty': 'putty', 'ssh client': 'putty',
                'filezilla': 'filezilla', 'ftp client': 'filezilla',
                'wireshark': 'Wireshark', 'network analyzer': 'Wireshark',
                'nmap': 'nmap', 'network scanner': 'nmap',
                'virtualbox': 'VirtualBox', 'vm': 'VirtualBox',
                'vmware': 'vmware', 'vmware workstation': 'vmware-vmx',
                'hyper-v': 'vmms', 'hyperv': 'vmms',
                'cpu-z': 'cpuz', 'gpu-z': 'GPU-Z',
                'hwinfo': 'HWiNFO64', 'speccy': 'Speccy64',
                'crystaldiskinfo': 'DiskInfo64', 'crystaldiskmark': 'DiskMark64',
                'process explorer': 'procexp64', 'process monitor': 'Procmon',
                'autoruns': 'Autoruns64', 'sysinternals': 'procexp64',
                'everything': 'Everything', 'file search': 'Everything',
                'powertoys': 'PowerToys', 'microsoft powertoys': 'PowerToys',
                'f.lux': 'flux', 'blue light filter': 'flux',
                'rainmeter': 'Rainmeter', 'desktop customization': 'Rainmeter',
                'wallpaper engine': 'wallpaper32', 'animated wallpaper': 'wallpaper32'
            }
            
            # Get actual process name
            actual_app_name = app_mappings.get(app_name.lower(), app_name)
            
            # If no exact match, try partial matching
            if actual_app_name == app_name:
                for key, value in app_mappings.items():
                    if app_name.lower() in key or key in app_name.lower():
                        actual_app_name = value
                        break
            
            # AI fallback for process name
            if actual_app_name == app_name:
                try:
                    from engine.dual_ai import dual_ai
                    ai_prompt = f'What is the exact process name for "{app_name}" on Windows? Respond with ONLY the process name (like "notepad" or "chrome"), no explanations.'
                    
                    if dual_ai.ai_provider == 'groq':
                        response = dual_ai.groq_client.chat.completions.create(
                            messages=[{"role": "user", "content": ai_prompt}],
                            model="llama-3.1-8b-instant",
                            max_tokens=20
                        )
                        ai_process_name = response.choices[0].message.content.strip()
                        if ai_process_name and len(ai_process_name) < 50:
                            actual_app_name = ai_process_name
                except Exception:
                    pass
            
            # Try multiple methods to close the app
            success_count = 0
            
            try:
                # Method 1: Kill by mapped process name with .exe
                result = subprocess.run(f'taskkill /f /im "{actual_app_name}.exe"', 
                                      shell=True, capture_output=True, text=True)
                if result.returncode == 0 and "SUCCESS" in result.stdout:
                    success_count += 1
            except:
                pass
            
            try:
                # Method 2: Kill by mapped process name without .exe
                result = subprocess.run(f'taskkill /f /im "{actual_app_name}"', 
                                      shell=True, capture_output=True, text=True)
                if result.returncode == 0 and "SUCCESS" in result.stdout:
                    success_count += 1
            except:
                pass
            
            try:
                # Method 3: Kill by original name with .exe
                result = subprocess.run(f'taskkill /f /im "{app_name}.exe"', 
                                      shell=True, capture_output=True, text=True)
                if result.returncode == 0 and "SUCCESS" in result.stdout:
                    success_count += 1
            except:
                pass
            
            try:
                # Method 4: Kill by original name without .exe
                result = subprocess.run(f'taskkill /f /im "{app_name}"', 
                                      shell=True, capture_output=True, text=True)
                if result.returncode == 0 and "SUCCESS" in result.stdout:
                    success_count += 1
            except:
                pass
            
            try:
                # Method 5: Kill by window title (partial match)
                result = subprocess.run(f'taskkill /f /fi "WINDOWTITLE eq *{app_name}*"', 
                                      shell=True, capture_output=True, text=True)
                if result.returncode == 0 and "SUCCESS" in result.stdout:
                    success_count += 1
            except:
                pass
            
            if success_count > 0:
                return f"Closed {app_name} successfully"
            else:
                return f"Could not close {app_name}. App may not be running or name not recognized."
                
        except Exception as e:
            return f"App closer failed: {e}"
    
    def port_scanner(self, query=""):
        try:
            import threading
            import re
            from datetime import datetime
            
            # Extract target and port range
            target = "127.0.0.1"  # localhost default
            start_port = 1
            end_port = 1000
            
            # Parse target IP/hostname
            ip_match = re.search(r'scan\s+([\d\.]+|\w+\.\w+)', query.lower())
            if ip_match:
                target = ip_match.group(1)
            
            # Parse port range
            port_match = re.search(r'port[s]?\s+(\d+)(?:-(\d+))?', query.lower())
            if port_match:
                start_port = int(port_match.group(1))
                end_port = int(port_match.group(2)) if port_match.group(2) else start_port
            
            # Limit scan range for safety
            if end_port - start_port > 1000:
                end_port = start_port + 1000
            
            open_ports = []
            
            def scan_port(host, port):
                try:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(1)
                    result = sock.connect_ex((host, port))
                    if result == 0:
                        open_ports.append(port)
                    sock.close()
                except:
                    pass
            
            # Start scanning
            start_time = datetime.now()
            threads = []
            
            for port in range(start_port, end_port + 1):
                thread = threading.Thread(target=scan_port, args=(target, port))
                threads.append(thread)
                thread.start()
                
                # Limit concurrent threads
                if len(threads) >= 50:
                    for t in threads:
                        t.join()
                    threads = []
            
            # Wait for remaining threads
            for thread in threads:
                thread.join()
            
            end_time = datetime.now()
            scan_duration = (end_time - start_time).total_seconds()
            
            # Common port services
            port_services = {
                21: "FTP", 22: "SSH", 80: "HTTP", 443: "HTTPS", 3389: "RDP"
            }
            
            result = f"üîç Port Scanner Results\n"
            result += f"Target: {target}\n"
            result += f"Scanned: {start_port}-{end_port}\n"
            result += f"Duration: {scan_duration:.2f}s\n\n"
            
            if open_ports:
                result += f"Open Ports ({len(open_ports)} found):\n"
                for port in sorted(open_ports):
                    service = port_services.get(port, "Unknown")
                    result += f"  {port}/tcp - {service}\n"
            else:
                result += "No open ports found\n"
            
            return result
            
        except Exception as e:
            return f"üîç Port scanner failed: {e}"
    
    def _setup_auto_response(self, query):
        """Setup AI auto-response for incoming emails"""
        try:
            import threading
            import time
            import imaplib
            import email
            from email.header import decode_header
            import smtplib
            from email.mime.text import MIMEText
            from email.mime.multipart import MIMEMultipart
            from email_config import SMTP_SERVER, SMTP_PORT, SENDER_EMAIL, SENDER_PASSWORD
            
            if 'enable' in query.lower() or 'start' in query.lower():
                # Extract custom message from query
                import re
                import json
                import os
                
                # Extract meeting info and time
                custom_message = ""
                if 'meeting' in query.lower():
                    # Extract time info
                    time_match = re.search(r'(\d{1,2}\s*(?:am|pm|:\d{2}))', query.lower())
                    meeting_time = time_match.group(1) if time_match else "later"
                    
                    custom_message = f"Thank you for your email. I am currently in a meeting and will respond after {meeting_time}. Your message is important to me and I will get back to you as soon as possible."
                elif 'busy' in query.lower() or 'unavailable' in query.lower():
                    custom_message = "Thank you for your email. I am currently unavailable but will respond as soon as possible."
                
                # Save custom message
                with open('auto_reply_message.txt', 'w') as f:
                    f.write(custom_message)
                
                replied_emails = set()
                
                # Clear previous tracking
                if os.path.exists('replied_emails.json'):
                    os.remove('replied_emails.json')
                
                def auto_response_monitor():
                    while True:
                        try:
                            # Connect to Gmail IMAP
                            mail = imaplib.IMAP4_SSL('imap.gmail.com')
                            mail.login(SENDER_EMAIL, SENDER_PASSWORD)
                            mail.select('inbox')
                            
                            # Search for unread emails
                            status, messages = mail.search(None, 'UNSEEN')
                            
                            if messages[0]:
                                for msg_id in messages[0].split():
                                    # Fetch email
                                    status, msg_data = mail.fetch(msg_id, '(RFC822)')
                                    msg = email.message_from_bytes(msg_data[0][1])
                                    
                                    # Get sender and subject
                                    sender = msg['From']
                                    subject = msg['Subject']
                                    msg_id_str = msg_id.decode()
                                    
                                    # Skip if already replied to this email
                                    if msg_id_str in replied_emails:
                                        continue
                                    
                                    # Skip promotional/newsletter emails
                                    promotional_keywords = ['unsubscribe', 'newsletter', 'promotion', 'offer', 'deal', 'sale', 'marketing', 'noreply', 'no-reply']
                                    sender_lower = sender.lower()
                                    subject_lower = subject.lower() if subject else ''
                                    
                                    if any(keyword in sender_lower or keyword in subject_lower for keyword in promotional_keywords):
                                        print(f"SKIPPED PROMOTIONAL: {sender} - {subject}")
                                        mail.store(msg_id, '+FLAGS', '\\Seen')
                                        continue
                                    
                                    replied_emails.add(msg_id_str)
                                    
                                    # Get email body with error handling
                                    body = ""
                                    try:
                                        if msg.is_multipart():
                                            for part in msg.walk():
                                                if part.get_content_type() == "text/plain":
                                                    payload = part.get_payload(decode=True)
                                                    if payload:
                                                        body = payload.decode('utf-8', errors='ignore')
                                                        break
                                        else:
                                            payload = msg.get_payload(decode=True)
                                            if payload:
                                                body = payload.decode('utf-8', errors='ignore')
                                    except:
                                        body = "[Email content could not be decoded]"
                                    
                                    # Generate AI response
                                    try:
                                        # Check for custom message
                                        custom_msg = ""
                                        if os.path.exists('auto_reply_message.txt'):
                                            with open('auto_reply_message.txt', 'r') as f:
                                                custom_msg = f.read().strip()
                                        
                                        if custom_msg:
                                            ai_response = custom_msg
                                        else:
                                            from engine.dual_ai import dual_ai
                                            
                                            ai_prompt = f'''Generate a professional auto-reply for this email:
                                            From: {sender}
                                            Subject: {subject}
                                            Content: {body[:500]}...
                                            
                                            Respond with a helpful, professional auto-reply message (max 100 words).'''
                                            
                                            if dual_ai.ai_provider == 'groq':
                                                response = dual_ai.groq_client.chat.completions.create(
                                                    messages=[{"role": "user", "content": ai_prompt}],
                                                    model="llama-3.1-8b-instant"
                                                )
                                                ai_response = response.choices[0].message.content.strip()
                                            else:
                                                response = dual_ai.gemini_model.generate_content(ai_prompt)
                                                ai_response = response.text.strip()

                                        
                                        # Send auto-reply
                                        reply_msg = MIMEMultipart()
                                        reply_msg['From'] = SENDER_EMAIL
                                        reply_msg['To'] = sender
                                        reply_msg['Subject'] = f"Re: {subject}"
                                        reply_msg.attach(MIMEText(ai_response, 'plain'))
                                        
                                        server = smtplib.SMTP(SMTP_SERVER, SMTP_PORT)
                                        server.starttls()
                                        server.login(SENDER_EMAIL, SENDER_PASSWORD)
                                        server.sendmail(SENDER_EMAIL, sender, reply_msg.as_string())
                                        server.quit()
                                        
                                        # Log auto-reply activity
                                        print(f"AUTO-REPLY SENT: To {sender} - Subject: Re: {subject}")
                                        
                                        # Mark as read
                                        mail.store(msg_id, '+FLAGS', '\\Seen')
                                        
                                    except Exception as e:
                                        print(f"Auto-reply failed for {sender}: {e}")
                            
                            mail.close()
                            mail.logout()
                            
                        except Exception as e:
                            print(f"Email monitoring error: {e}")
                        
                        time.sleep(30)  # Check every 30 seconds
                
                threading.Thread(target=auto_response_monitor, daemon=True).start()
                return "EMAIL: AI Auto-response enabled - monitoring inbox every 30 seconds"
            
            elif 'disable' in query.lower() or 'stop' in query.lower():
                return "EMAIL: Auto-response disabled (restart to re-enable)"
            
            else:
                return "EMAIL: Auto-response commands - 'enable auto reply' or 'disable auto reply'"
                
        except Exception as e:
            return f"Auto-response setup failed: {e}"
    
    def _schedule_email(self, query):
        """Schedule email for later sending"""
        try:
            import re
            import json
            import os
            import threading
            import time
            from datetime import datetime, timedelta
            
            # Extract email details and timing - support multiple formats
            # Format 1: "send mail to user@email.com sub hello test in 5second"
            email_match = re.search(r'(?:send\s+mail\s+to|schedule\s+email\s+to)\s+([\w\.-]+@[\w\.-]+)\s+sub(?:ject)?\s+(.+?)\s+in\s+(\d+)\s*(second|seconds|minute|minutes|hour|hours)', query.lower())
            if not email_match:
                return "Usage: 'send mail to user@email.com sub Hello test in 5second'"
            
            recipient = email_match.group(1)
            subject = email_match.group(2).strip()
            delay_num = int(email_match.group(3))
            delay_unit = email_match.group(4)
            
            # Convert to seconds
            if 'hour' in delay_unit:
                delay_seconds = delay_num * 3600
            elif 'minute' in delay_unit:
                delay_seconds = delay_num * 60
            else:  # seconds
                delay_seconds = delay_num
            
            # Schedule the email
            schedule_time = datetime.now() + timedelta(seconds=delay_seconds)
            
            def send_scheduled_email():
                time.sleep(delay_seconds)
                # Send the actual email using existing email_sender logic
                from email_config import SMTP_SERVER, SMTP_PORT, SENDER_EMAIL, SENDER_PASSWORD
                import smtplib
                from email.mime.text import MIMEText
                from email.mime.multipart import MIMEMultipart
                
                try:
                    msg = MIMEMultipart()
                    msg['From'] = SENDER_EMAIL
                    msg['To'] = recipient
                    msg['Subject'] = subject
                    msg.attach(MIMEText(f"Scheduled message: {subject}", 'plain'))
                    
                    server = smtplib.SMTP(SMTP_SERVER, SMTP_PORT)
                    server.starttls()
                    server.login(SENDER_EMAIL, SENDER_PASSWORD)
                    server.sendmail(SENDER_EMAIL, recipient, msg.as_string())
                    server.quit()
                except:
                    pass
            
            threading.Thread(target=send_scheduled_email, daemon=True).start()
            
            return f"EMAIL: Scheduled for {schedule_time.strftime('%Y-%m-%d %H:%M')} to {recipient} - Subject: {subject}"
            
        except Exception as e:
            return f"Email scheduling failed: {e}"
    
    def email_sender(self, query=""):
        try:
            import smtplib
            import re
            from email.mime.text import MIMEText
            from email.mime.multipart import MIMEMultipart
            from email_config import SMTP_SERVER, SMTP_PORT, SENDER_EMAIL, SENDER_PASSWORD
            
            # Check for auto-response setup
            if 'auto reply' in query.lower() or 'auto response' in query.lower():
                return self._setup_auto_response(query)
            
            # Check for scheduling - detect 'in X seconds/minutes/hours'
            if 'schedule' in query.lower() or 'later' in query.lower() or re.search(r'\s+in\s+\d+\s*(second|seconds|minute|minutes|hour|hours)', query.lower()):
                return self._schedule_email(query)
            
            # Parse multiple email formats
            # Format 1: "send email to user@email.com subject hello message test"
            email_pattern1 = r'send\s+email\s+to\s+([\w\.-]+@[\w\.-]+)\s+subject\s+(.+?)\s+message\s+(.+)'
            # Format 2: "user@email.com sub hello test" (your format)
            email_pattern2 = r'([\w\.-]+@[\w\.-]+)\s+sub\s+(.+?)\s+(.+)'
            
            match = re.search(email_pattern1, query.lower()) or re.search(email_pattern2, query.lower())
            
            if not match:
                return "EMAIL: Formats - 1. 'send email to user@email.com subject Hello message Test' 2. 'user@email.com sub Hello Test'"
            
            recipient = match.group(1)
            subject = match.group(2).strip()
            message = match.group(3).strip()
            
            # Create email
            msg = MIMEMultipart()
            msg['From'] = SENDER_EMAIL
            msg['To'] = recipient
            msg['Subject'] = subject
            
            msg.attach(MIMEText(message, 'plain'))
            
            # Send email
            server = smtplib.SMTP(SMTP_SERVER, SMTP_PORT)
            server.starttls()
            server.login(SENDER_EMAIL, SENDER_PASSWORD)
            
            text = msg.as_string()
            server.sendmail(SENDER_EMAIL, recipient, text)
            server.quit()
            
            return f"EMAIL: Sent successfully to {recipient} - Subject: {subject} - Message: {message}"
            
        except Exception as e:
            return f"EMAIL: Failed - {str(e)} - Check your email_config.py settings"
    
    def financial_tools(self, query=""):
        try:
            from engine.dual_ai import dual_ai
            import requests
            import json
            import re
            from datetime import datetime
            
            # AI-powered expense tracker
            if "expense" in query.lower() or "spending" in query.lower():
                try:
                    ai_prompt = f'Extract expense info from: "{query}"\nRespond: Amount: [number]\nCategory: [category]\nAction: [add/show/total]'
                    
                    if dual_ai.ai_provider == 'groq':
                        response = dual_ai.groq_client.chat.completions.create(
                            messages=[{"role": "user", "content": ai_prompt}],
                            model="llama-3.1-8b-instant"
                        )
                        ai_response = response.choices[0].message.content.strip()
                    else:
                        response = dual_ai.gemini_model.generate_content(ai_prompt)
                        ai_response = response.text.strip()
                    
                    amount_match = re.search(r'Amount:\s*(\d+(?:\.\d{2})?)', ai_response)
                    category_match = re.search(r'Category:\s*(\w+)', ai_response)
                    action_match = re.search(r'Action:\s*(\w+)', ai_response)
                    
                    if amount_match and action_match and action_match.group(1).lower() == 'add':
                        amount = float(amount_match.group(1))
                        category = category_match.group(1) if category_match else "general"
                        
                        expense_file = "expenses.json"
                        try:
                            with open(expense_file, 'r') as f:
                                expenses = json.load(f)
                        except:
                            expenses = []
                        
                        expenses.append({
                            "date": datetime.now().strftime("%Y-%m-%d"),
                            "amount": amount,
                            "category": category,
                            "description": query
                        })
                        
                        with open(expense_file, 'w') as f:
                            json.dump(expenses, f, indent=2)
                        
                        return f"AI Expense Tracker: Added ${amount} for {category}"
                    
                    elif action_match and action_match.group(1).lower() in ['show', 'total']:
                        try:
                            with open("expenses.json", 'r') as f:
                                expenses = json.load(f)
                            total = sum(exp['amount'] for exp in expenses)
                            return f"AI Expense Analysis: Total ${total:.2f} across {len(expenses)} transactions"
                        except:
                            return "No expenses recorded yet"
                    
                except Exception:
                    pass
                
                return "AI Expense Tracker: Say 'add expense 50 on food' or 'show total expenses'"
            
            # Real-time currency converter
            elif "convert" in query.lower() and "currency" in query.lower():
                try:
                    amount_match = re.search(r'(\d+(?:\.\d{2})?)', query)
                    currency_match = re.search(r'(\w{3})\s+to\s+(\w{3})', query.upper())
                    
                    if amount_match and currency_match:
                        amount = float(amount_match.group(1))
                        from_curr = currency_match.group(1)
                        to_curr = currency_match.group(2)
                        
                        # Real-time API
                        url = f"https://api.exchangerate-api.com/v4/latest/{from_curr}"
                        response = requests.get(url, timeout=5)
                        
                        if response.status_code == 200:
                            data = response.json()
                            rate = data['rates'].get(to_curr)
                            
                            if rate:
                                converted = amount * rate
                                return f"Real-time Currency: {amount} {from_curr} = {converted:.2f} {to_curr}\nLive Rate: 1 {from_curr} = {rate:.4f} {to_curr}"
                    
                    return "Format: 'convert 100 USD to EUR'"
                except Exception as e:
                    return f"Currency API error: {e}"
            
            # Real-time stock/crypto prices
            elif "stock" in query.lower() or "crypto" in query.lower() or "price" in query.lower():
                symbol_match = re.search(r'(\w+)\s+(?:stock|price|crypto)', query.lower())
                
                if symbol_match:
                    symbol = symbol_match.group(1).upper()
                    
                    try:
                        # Try real crypto API first
                        if symbol in ['BTC', 'ETH', 'ADA', 'DOT', 'SOL', 'DOGE']:
                            crypto_url = f"https://api.coingecko.com/api/v3/simple/price?ids={symbol.lower()}&vs_currencies=usd"
                            response = requests.get(crypto_url, timeout=5)
                            if response.status_code == 200:
                                data = response.json()
                                if symbol.lower() in data:
                                    price = data[symbol.lower()]['usd']
                                    return f"Live Crypto: {symbol} = ${price:,.2f} USD"
                        
                        # Indian stocks mapping
                        indian_stocks = {
                            'TATA': 'TATAMOTORS.NS',
                            'TCS': 'TCS.NS', 
                            'RELIANCE': 'RELIANCE.NS',
                            'INFY': 'INFY.NS',
                            'HDFC': 'HDFCBANK.NS',
                            'ICICI': 'ICICIBANK.NS',
                            'SBI': 'SBIN.NS',
                            'ITC': 'ITC.NS',
                            'WIPRO': 'WIPRO.NS',
                            'BHARTI': 'BHARTIARTL.NS'
                        }
                        
                        # Check if it's an Indian stock
                        yahoo_symbol = symbol
                        if symbol in indian_stocks:
                            yahoo_symbol = indian_stocks[symbol]
                        
                        # Try Yahoo Finance API
                        stock_url = f"https://query1.finance.yahoo.com/v8/finance/chart/{yahoo_symbol}"
                        response = requests.get(stock_url, timeout=10)
                        
                        if response.status_code == 200:
                            data = response.json()
                            if 'chart' in data and data['chart']['result'] and len(data['chart']['result']) > 0:
                                result = data['chart']['result'][0]
                                if 'meta' in result and 'regularMarketPrice' in result['meta']:
                                    price = result['meta']['regularMarketPrice']
                                    currency = result['meta'].get('currency', 'USD')
                                    
                                    if symbol in indian_stocks:
                                        return f"Live Indian Stock: {symbol} = Rs.{price:.2f} INR"
                                    else:
                                        return f"Live Stock: {symbol} = ${price:.2f} {currency}"
                        
                        # Use Gemini AI for stock information
                        try:
                            ai_prompt = f'Get current stock information for {symbol}. Provide: Current Price, Market Cap, 52-week high/low, and brief analysis. Format as: Stock: {symbol}\nPrice: $X.XX\nMarket Cap: $X.XB\nAnalysis: [brief market insight]'
                            
                            if dual_ai.ai_provider == 'groq':
                                response = dual_ai.groq_client.chat.completions.create(
                                    messages=[{"role": "user", "content": ai_prompt}],
                                    model="llama-3.1-8b-instant"
                                )
                                ai_response = response.choices[0].message.content.strip()
                            else:
                                response = dual_ai.gemini_model.generate_content(ai_prompt)
                                ai_response = response.text.strip()
                            
                            return f"AI Stock Analysis:\n{ai_response}"
                        
                        except Exception as e:
                            return f"AI stock analysis failed: {e}"
                    
                    except Exception as e:
                        return f"Price API error: {e}"
                else:
                    return "Format: 'AAPL stock price', 'TATA stock price', or 'BTC crypto price'"
            
            # Real-time movie info
            elif "movie" in query.lower() or "imdb" in query.lower():
                movie_match = re.search(r'movie\s+(.+?)(?:\s+rating|$)', query.lower())
                
                if movie_match:
                    movie_name = movie_match.group(1).strip()
                    
                    try:
                        # Try OMDB API (free with demo key)
                        omdb_url = f"http://www.omdbapi.com/?t={movie_name}&apikey=demo"
                        response = requests.get(omdb_url, timeout=5)
                        
                        if response.status_code == 200:
                            data = response.json()
                            if data.get('Response') == 'True':
                                title = data.get('Title', 'Unknown')
                                year = data.get('Year', 'Unknown')
                                rating = data.get('imdbRating', 'N/A')
                                genre = data.get('Genre', 'Unknown')
                                plot = data.get('Plot', 'No plot available')
                                
                                result = f"Live Movie Info:\n"
                                result += f"Title: {title}\n"
                                result += f"Year: {year}\n"
                                result += f"IMDb Rating: {rating}/10\n"
                                result += f"Genre: {genre}\n"
                                result += f"Plot: {plot[:100]}..."
                                
                                return result
                        
                        # Try TMDB API alternative
                        tmdb_url = f"https://api.themoviedb.org/3/search/movie?api_key=demo&query={movie_name}"
                        response = requests.get(tmdb_url, timeout=5)
                        
                        if response.status_code == 200:
                            data = response.json()
                            if data.get('results'):
                                movie = data['results'][0]
                                title = movie.get('title', 'Unknown')
                                year = movie.get('release_date', 'Unknown')[:4] if movie.get('release_date') else 'Unknown'
                                rating = movie.get('vote_average', 'N/A')
                                overview = movie.get('overview', 'No overview available')
                                
                                result = f"Live Movie Info (TMDB):\n"
                                result += f"Title: {title}\n"
                                result += f"Year: {year}\n"
                                result += f"Rating: {rating}/10\n"
                                result += f"Overview: {overview[:100]}..."
                                
                                return result
                        
                        return f"Movie '{movie_name}' not found in databases. Check spelling or try another title."
                    
                    except Exception as e:
                        return f"Movie API error: {e}"
                else:
                    return "Format: 'movie inception' or 'imdb avatar'"
            
            # AI-powered location-specific news
            # AI-powered location-specific news
            elif "news" in query.lower():
                try:
                    # Extract location and count from query
                    location_match = re.search(r'news\s+on\s+(\w+)', query.lower())
                    count_match = re.search(r'(\d+)\s+news', query.lower())
                    
                    location = location_match.group(1) if location_match else "general"
                    count = int(count_match.group(1)) if count_match else 5
                    
                    # Use Gemini for real-time news, Groq as fallback
                    from engine.dual_ai import dual_ai
                    
                    try:
                        ai_prompt = f'Get latest {count} real-time news headlines about {location}. Include brief descriptions.'
                        response = dual_ai.gemini_model.generate_content(ai_prompt)
                        ai_response = response.text.strip()
                    except:
                        ai_prompt = f'Generate {count} news headlines about {location}. Format: 1. [Headline]\n   [Description]'
                        response = dual_ai.groq_client.chat.completions.create(
                            messages=[{"role": "user", "content": ai_prompt}],
                            model="llama-3.1-8b-instant"
                        )
                        ai_response = response.choices[0].message.content.strip()
                    
                    return f"News for {location.title()}:\n{ai_response}"
                
                except Exception as e:
                    return f"News error: {e}"


                    

            
            # AI joke generator
            elif "joke" in query.lower():
                try:
                    ai_prompt = 'Generate a funny, clean joke. Make it original and clever.'
                    
                    if dual_ai.ai_provider == 'groq':
                        response = dual_ai.groq_client.chat.completions.create(
                            messages=[{"role": "user", "content": ai_prompt}],
                            model="llama-3.1-8b-instant"
                        )
                        ai_response = response.choices[0].message.content.strip()
                    else:
                        response = dual_ai.gemini_model.generate_content(ai_prompt)
                        ai_response = response.text.strip()
                    
                    return f"AI Joke: {ai_response}"
                
                except Exception as e:
                    return f"AI joke failed: {e}"
            
            # Spotify with AI
            elif "spotify" in query.lower():
                try:
                    import subprocess
                    
                    if "play" in query.lower():
                        subprocess.run(['nircmd', 'sendkeypress', 'media_play_pause'], check=False)
                        return "Spotify: Playing music"
                    elif "pause" in query.lower():
                        subprocess.run(['nircmd', 'sendkeypress', 'media_play_pause'], check=False)
                        return "Spotify: Paused"
                    elif "next" in query.lower():
                        subprocess.run(['nircmd', 'sendkeypress', 'media_next_track'], check=False)
                        return "Spotify: Next track"
                    elif "previous" in query.lower():
                        subprocess.run(['nircmd', 'sendkeypress', 'media_prev_track'], check=False)
                        return "Spotify: Previous track"
                    else:
                        return "Spotify AI: Commands - play, pause, next, previous"
                
                except Exception as e:
                    return f"Spotify control failed: {e}"
            
            else:
                return "AI Financial Tools: expense tracker, real-time currency, live stock/crypto prices, spotify control, AI movie info, live news, AI jokes"
        
        except Exception as e:
            return f"Financial AI tools error: {e}"
    
    def speed_test(self, query=""):
        try:
            import time
            import requests
            import subprocess
            
            def ping_test():
                try:
                    result = subprocess.run(['ping', '-n', '4', '8.8.8.8'], 
                                          capture_output=True, text=True, timeout=10)
                    if result.returncode == 0:
                        import re
                        avg_match = re.search(r'Average = (\d+)ms', result.stdout)
                        return int(avg_match.group(1)) if avg_match else 0
                    return 0
                except:
                    return 0
            
            def download_test():
                try:
                    start_time = time.time()
                    test_url = "http://speedtest.ftp.otenet.gr/files/test1Mb.db"
                    response = requests.get(test_url, timeout=30)
                    download_time = time.time() - start_time
                    
                    if response.status_code == 200:
                        file_size_mb = len(response.content) / (1024 * 1024)
                        download_speed = (file_size_mb / download_time) * 8
                        return download_speed
                    return 0
                except:
                    return 0
            
            def upload_test():
                try:
                    start_time = time.time()
                    test_data = b'0' * (100 * 1024)
                    response = requests.post('https://httpbin.org/post', data=test_data, timeout=10)
                    upload_time = time.time() - start_time
                    upload_speed = (0.1 / upload_time) * 8 if upload_time > 0 else 0
                    return upload_speed
                except:
                    return 0
            
            ping = ping_test()
            download_speed = download_test()
            upload_speed = upload_test()
            
            result = f"Internet Speed Test Results:\n"
            result += f"Download: {download_speed:.1f} Mbps\n"
            result += f"Upload: {upload_speed:.1f} Mbps\n"
            result += f"Ping: {ping} ms\n"
            
            if download_speed > 25:
                result += "Status: Excellent connection"
            elif download_speed > 10:
                result += "Status: Good connection"
            elif download_speed > 5:
                result += "Status: Average connection"
            else:
                result += "Status: Slow connection"
            
            return result
        
        except Exception as e:
            return f"Speed test failed: {e}"
    
    def battery_health(self, query=""):
        try:
            import psutil
            import subprocess
            from datetime import datetime
            
            # Get battery information
            battery = psutil.sensors_battery()
            if not battery:
                return "Battery not detected (desktop computer or battery unavailable)"
            
            # Basic battery info
            percent = battery.percent
            plugged = battery.power_plugged
            
            # Get detailed battery info (Windows)
            try:
                result = subprocess.run(['powercfg', '/batteryreport', '/output', 'battery_report.html'], 
                                      capture_output=True, text=True, timeout=10)
                report_generated = result.returncode == 0
            except:
                report_generated = False
            
            # Battery health analysis
            health_status = "Good"
            warnings = []
            
            if percent < 20 and not plugged:
                warnings.append("Low battery - charge soon")
                health_status = "Needs charging"
            
            if plugged and percent > 95:
                warnings.append("Overcharging detected - unplug to preserve battery")
            
            # Estimate cycles (simplified)
            try:
                # Get battery design capacity vs current capacity
                wmi_result = subprocess.run(['wmic', 'path', 'Win32_Battery', 'get', 'DesignCapacity,FullChargeCapacity'], 
                                          capture_output=True, text=True, timeout=5)
                if wmi_result.returncode == 0:
                    lines = wmi_result.stdout.strip().split('\n')
                    if len(lines) > 1:
                        data = lines[1].split()
                        if len(data) >= 2:
                            design_cap = int(data[0]) if data[0].isdigit() else 0
                            current_cap = int(data[1]) if data[1].isdigit() else 0
                            if design_cap > 0 and current_cap > 0:
                                health_percent = (current_cap / design_cap) * 100
                                if health_percent < 80:
                                    warnings.append(f"Battery degraded to {health_percent:.1f}% of original capacity")
                                    health_status = "Degraded"
            except:
                pass
            
            # Create result
            result = f"Battery Health Monitor:\n"
            result += f"Current charge: {percent}%\n"
            result += f"Power adapter: {'Connected' if plugged else 'Disconnected'}\n"
            result += f"Health status: {health_status}\n"
            
            if warnings:
                result += f"\nWarnings:\n"
                for warning in warnings:
                    result += f"‚ö†Ô∏è {warning}\n"
            
            if report_generated:
                result += f"\nDetailed report: battery_report.html"
            
            # Show notification for critical issues
            if percent < 15 and not plugged:
                self._show_notification("üîã Critical Battery", f"Battery at {percent}% - Charge immediately!")
            elif warnings:
                self._show_notification("üîã Battery Alert", warnings[0])
            
            return result
            
        except Exception as e:
            return f"Battery health check failed: {e}"
    
    def thermal_monitor(self, query=""):
        try:
            import psutil
            import subprocess
            from datetime import datetime
            
            # Get CPU temperature and usage
            cpu_percent = psutil.cpu_percent(interval=1)
            
            # Try to get temperature sensors
            temperatures = {}
            alerts = []
            
            try:
                # Windows: Try WMI for temperature
                wmi_result = subprocess.run(['wmic', '/namespace:\\\\root\\wmi', 'PATH', 'MSAcpi_ThermalZoneTemperature', 'get', 'CurrentTemperature'], 
                                          capture_output=True, text=True, timeout=5)
                if wmi_result.returncode == 0:
                    lines = wmi_result.stdout.strip().split('\n')
                    for line in lines[1:]:
                        if line.strip().isdigit():
                            # Convert from tenths of Kelvin to Celsius
                            temp_kelvin = int(line.strip()) / 10
                            temp_celsius = temp_kelvin - 273.15
                            temperatures['CPU'] = temp_celsius
                            break
            except:
                pass
            
            # Try psutil sensors (Linux/some Windows systems)
            try:
                sensors = psutil.sensors_temperatures()
                if sensors:
                    for name, entries in sensors.items():
                        for entry in entries:
                            label = entry.label or name
                            temp = entry.current
                            temperatures[label] = temp
            except:
                pass
            
            # If no temperature sensors, estimate from CPU usage
            if not temperatures:
                estimated_temp = 30 + (cpu_percent * 0.5)  # Rough estimation
                temperatures['CPU (estimated)'] = estimated_temp
            
            # Analyze temperatures and generate alerts
            critical_temp = 85
            warning_temp = 75
            
            for component, temp in temperatures.items():
                if temp > critical_temp:
                    alerts.append(f"üî• CRITICAL: {component} at {temp:.1f}¬∞C - System may shutdown!")
                elif temp > warning_temp:
                    alerts.append(f"‚ö†Ô∏è WARNING: {component} at {temp:.1f}¬∞C - High temperature")
            
            # Check CPU usage for thermal correlation
            if cpu_percent > 90:
                alerts.append(f"üî• High CPU usage ({cpu_percent}%) may cause overheating")
            
            # Create result
            result = f"Thermal Monitor:\n"
            result += f"CPU Usage: {cpu_percent}%\n"
            
            if temperatures:
                result += f"\nTemperatures:\n"
                for component, temp in temperatures.items():
                    status = "üî•" if temp > critical_temp else "‚ö†Ô∏è" if temp > warning_temp else "‚úÖ"
                    result += f"{status} {component}: {temp:.1f}¬∞C\n"
            else:
                result += "\nTemperature sensors not available\n"
            
            # Add thermal guidelines
            result += f"\nThermal Guidelines:\n"
            result += f"‚úÖ Normal: < 75¬∞C\n"
            result += f"‚ö†Ô∏è Warning: 75-85¬∞C\n"
            result += f"üî• Critical: > 85¬∞C\n"
            
            if alerts:
                result += f"\nAlerts:\n"
                for alert in alerts:
                    result += f"{alert}\n"
                
                # Show notification for critical temperatures
                if any("CRITICAL" in alert for alert in alerts):
                    self._show_notification("üî• OVERHEATING ALERT", "Critical temperature detected! Check cooling system.")
                elif any("WARNING" in alert for alert in alerts):
                    self._show_notification("‚ö†Ô∏è Temperature Warning", "High temperature detected - monitor system")
            
            return result
            
        except Exception as e:
            return f"Thermal monitoring failed: {e}"
    
    def disk_health_scanner(self, query=""):
        try:
            import subprocess
            import re
            from datetime import datetime
            
            # Get disk information using WMIC (Windows)
            try:
                # Get disk health using SMART data
                smart_result = subprocess.run(['wmic', 'diskdrive', 'get', 'status,size,model'], 
                                            capture_output=True, text=True, timeout=10)
                
                if smart_result.returncode == 0:
                    lines = smart_result.stdout.strip().split('\n')
                    disk_info = []
                    
                    for line in lines[1:]:  # Skip header
                        if line.strip():
                            parts = line.strip().split()
                            if len(parts) >= 2:
                                disk_info.append(line.strip())
                
                # Get disk space information
                space_result = subprocess.run(['wmic', 'logicaldisk', 'get', 'size,freespace,caption'], 
                                            capture_output=True, text=True, timeout=10)
                
                disk_space = []
                if space_result.returncode == 0:
                    lines = space_result.stdout.strip().split('\n')
                    for line in lines[1:]:
                        if line.strip() and 'Caption' not in line:
                            parts = line.strip().split()
                            if len(parts) >= 3:
                                caption = parts[0]
                                free_space = int(parts[1]) if parts[1].isdigit() else 0
                                total_space = int(parts[2]) if parts[2].isdigit() else 0
                                
                                if total_space > 0:
                                    used_space = total_space - free_space
                                    usage_percent = (used_space / total_space) * 100
                                    
                                    disk_space.append({
                                        'drive': caption,
                                        'total_gb': total_space // (1024**3),
                                        'free_gb': free_space // (1024**3),
                                        'used_percent': usage_percent
                                    })
                
                # Create health report
                result = f"Disk Health Scanner:\n"
                result += f"Scan Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
                
                # Disk status
                if disk_info:
                    result += "Physical Disks:\n"
                    for info in disk_info[:3]:  # Show first 3 disks
                        result += f"- {info}\n"
                else:
                    result += "Physical Disks: Status OK\n"
                
                # Disk space analysis
                if disk_space:
                    result += "\nDisk Space Analysis:\n"
                    warnings = []
                    
                    for disk in disk_space:
                        drive = disk['drive']
                        total = disk['total_gb']
                        free = disk['free_gb']
                        used_pct = disk['used_percent']
                        
                        status = "‚úÖ Good"
                        if used_pct > 90:
                            status = "üî¥ Critical"
                            warnings.append(f"Drive {drive} is {used_pct:.1f}% full - Clean up space immediately!")
                        elif used_pct > 80:
                            status = "‚ö†Ô∏è Warning"
                            warnings.append(f"Drive {drive} is {used_pct:.1f}% full - Consider cleanup")
                        
                        result += f"Drive {drive}: {free}GB free / {total}GB total ({used_pct:.1f}% used) {status}\n"
                    
                    # Show warnings
                    if warnings:
                        result += "\nWarnings:\n"
                        for warning in warnings:
                            result += f"‚ö†Ô∏è {warning}\n"
                        
                        # Show critical notification
                        if any("Critical" in w for w in warnings):
                            self._show_notification("üî¥ Disk Space Critical", "One or more drives are critically full!")
                        elif warnings:
                            self._show_notification("‚ö†Ô∏è Disk Space Warning", "Some drives are getting full")
                
                # Health recommendations
                result += "\nHealth Recommendations:\n"
                result += "‚úÖ Run disk cleanup regularly\n"
                result += "‚úÖ Check for disk errors: chkdsk /f\n"
                result += "‚úÖ Defragment HDDs monthly\n"
                result += "‚úÖ Monitor SMART data for early warnings\n"
                
                return result
                
            except subprocess.TimeoutExpired:
                return "Disk health scan timed out - system may be busy"
            except Exception as scan_error:
                return f"Disk scan error: {scan_error}"
                
        except Exception as e:
            return f"Disk health scanner failed: {e}"
    
    def usb_device_manager(self, query=""):
        try:
            import subprocess
            import re
            from datetime import datetime
            
            # Get USB device information (Windows)
            try:
                # Get USB devices using WMIC
                usb_result = subprocess.run(['wmic', 'path', 'Win32_USBHub', 'get', 'Name,DeviceID,Status'], 
                                          capture_output=True, text=True, timeout=10)
                
                usb_devices = []
                if usb_result.returncode == 0:
                    lines = usb_result.stdout.strip().split('\n')
                    for line in lines[1:]:
                        if line.strip() and 'DeviceID' not in line:
                            parts = line.strip().split()
                            if len(parts) >= 2:
                                usb_devices.append(line.strip())
                
                # Get removable drives
                drives_result = subprocess.run(['wmic', 'logicaldisk', 'where', 'drivetype=2', 'get', 'caption,label,size'], 
                                             capture_output=True, text=True, timeout=10)
                
                removable_drives = []
                if drives_result.returncode == 0:
                    lines = drives_result.stdout.strip().split('\n')
                    for line in lines[1:]:
                        if line.strip() and 'Caption' not in line:
                            parts = line.strip().split()
                            if len(parts) >= 1:
                                removable_drives.append(line.strip())
                
                # Create device report
                result = f"USB Device Manager:\n"
                result += f"Scan Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
                
                # USB Hubs and Controllers
                if usb_devices:
                    result += f"USB Controllers ({len(usb_devices)}):\n"
                    for device in usb_devices[:5]:  # Show first 5
                        result += f"- {device}\n"
                else:
                    result += "USB Controllers: None detected\n"
                
                # Removable drives
                if removable_drives:
                    result += f"\nRemovable Drives ({len(removable_drives)}):\n"
                    for drive in removable_drives:
                        result += f"- {drive}\n"
                else:
                    result += "\nRemovable Drives: None connected\n"
                
                # USB Safety tips
                result += "\nUSB Safety Tips:\n"
                result += "‚úÖ Safely eject before removing\n"
                result += "‚úÖ Scan for malware regularly\n"
                result += "‚úÖ Use trusted devices only\n"
                result += "‚úÖ Keep drivers updated\n"
                
                # Quick actions
                result += "\nQuick Actions:\n"
                result += "- 'eject usb' - Safely eject all removable drives\n"
                result += "- 'scan usb' - Check for malware\n"
                
                return result
                
            except subprocess.TimeoutExpired:
                return "USB device scan timed out"
            except Exception as scan_error:
                return f"USB scan error: {scan_error}"
                
        except Exception as e:
            return f"USB device manager failed: {e}"
    
    def quick_note_taker(self, query=""):
        try:
            import json
            import os
            from datetime import datetime
            
            notes_file = "quick_notes.json"
            
            # Load existing notes
            notes = []
            if os.path.exists(notes_file):
                try:
                    with open(notes_file, 'r', encoding='utf-8') as f:
                        notes = json.load(f)
                except:
                    notes = []
            
            # List recent notes first
            if 'list' in query.lower() or 'show' in query.lower():
                if not notes:
                    return "[NOTE] No notes found. Create your first: 'quick note [your note]'"
                
                # Show last 10 notes
                recent_notes = notes[-10:]
                result = f"[NOTE] Quick Notes ({len(notes)} total):\n" + "="*40 + "\n"
                
                for note in reversed(recent_notes):
                    result += f"#{note['id']} [{note['time']}] {note['text']}\n"
                
                return result
            
            # Add new note
            elif any(word in query.lower() for word in ['note', 'remember', 'log', 'record']) or query.strip():
                # Extract note content
                note_text = ""
                if 'note' in query.lower():
                    import re
                    note_match = re.search(r'(?:note|take note|quick note)\s+(.+)', query, re.IGNORECASE)
                    if note_match:
                        note_text = note_match.group(1).strip()
                elif len(query.strip()) > 0:
                    note_text = query.strip()
                
                if not note_text:
                    return "[NOTE] Usage: 'quick note [your note]' or 'note meeting at 3pm'"
                
                # Create timestamped note
                timestamp = datetime.now()
                note_entry = {
                    'id': len(notes) + 1,
                    'text': note_text,
                    'timestamp': timestamp.isoformat(),
                    'date': timestamp.strftime('%Y-%m-%d'),
                    'time': timestamp.strftime('%H:%M:%S')
                }
                
                notes.append(note_entry)
                
                # Save notes
                with open(notes_file, 'w', encoding='utf-8') as f:
                    json.dump(notes, f, indent=2, ensure_ascii=False)
                
                self._show_notification("Note Saved", f"Note #{note_entry['id']}: {note_text[:50]}..." if len(note_text) > 50 else f"Note #{note_entry['id']}: {note_text}")
                
                return f"[NOTE] #{note_entry['id']} saved at {note_entry['time']}\n'{note_text}'"
            
            # Search notes
            elif 'search' in query.lower():
                import re
                search_match = re.search(r'search\s+(.+)', query, re.IGNORECASE)
                if search_match:
                    search_term = search_match.group(1).strip().lower()
                    
                    matching_notes = [note for note in notes if search_term in note['text'].lower()]
                    
                    if matching_notes:
                        result = f"[NOTE] Found {len(matching_notes)} notes for '{search_term}':\n"
                        for note in matching_notes[-5:]:  # Last 5 matches
                            result += f"#{note['id']} [{note['time']}] {note['text']}\n"
                        return result
                    else:
                        return f"[NOTE] No notes found containing '{search_term}'"
                else:
                    return "[NOTE] Usage: 'search [keyword]'"
            
            # Delete note
            elif 'delete' in query.lower():
                import re
                delete_match = re.search(r'delete\s+(?:note\s+)?(\d+)', query, re.IGNORECASE)
                if delete_match:
                    note_id = int(delete_match.group(1))
                    
                    # Find and remove note
                    for i, note in enumerate(notes):
                        if note['id'] == note_id:
                            deleted_note = notes.pop(i)
                            
                            # Save updated notes
                            with open(notes_file, 'w', encoding='utf-8') as f:
                                json.dump(notes, f, indent=2, ensure_ascii=False)
                            
                            return f" Deleted note #{note_id}: '{deleted_note['text']}'"
                    
                    return f"Note #{note_id} not found"
                else:
                    return " Usage: 'delete note [number]'"
            
            # Default help
            else:
                return " Quick Note Taker Commands:\n‚Ä¢ 'quick note [text]' - Add note\n‚Ä¢ 'list notes' - Show recent notes\n‚Ä¢ 'search [keyword]' - Find notes\n‚Ä¢ 'delete note [number]' - Remove note"
                
        except Exception as e:
            return f"Quick note taker failed: {e}"
    
    def large_file_scanner(self, query=""):
        try:
            import os
            from datetime import datetime
            
            # Default scan path
            scan_path = "C:\\" if os.path.exists("C:\\") else os.path.expanduser("~")
            
            # Extract custom path if provided
            if 'scan' in query.lower() and (':\\' in query or '/' in query):
                import re
                path_match = re.search(r'([A-Za-z]:\\[^\s]+|/[^\s]+)', query)
                if path_match:
                    custom_path = path_match.group(1)
                    if os.path.exists(custom_path):
                        scan_path = custom_path
            
            large_files = []
            min_size = 100 * 1024 * 1024  # 100MB threshold
            
            # Scan for large files
            for root, dirs, files in os.walk(scan_path):
                # Skip system directories
                dirs[:] = [d for d in dirs if d not in ['System Volume Information', '$Recycle.Bin', 'Windows']]
                
                for file in files:
                    try:
                        file_path = os.path.join(root, file)
                        size = os.path.getsize(file_path)
                        
                        if size > min_size:
                            size_mb = size / (1024 * 1024)
                            large_files.append({
                                'path': file_path,
                                'size': size,
                                'size_mb': round(size_mb, 1),
                                'name': file
                            })
                        
                        # Limit scan to prevent timeout
                        if len(large_files) >= 20:
                            break
                    except (OSError, PermissionError):
                        continue
                
                if len(large_files) >= 20:
                    break
            
            # Sort by size (largest first)
            large_files.sort(key=lambda x: x['size'], reverse=True)
            
            result = f"Large File Scanner - {scan_path}\n"
            result += f"Scan Time: {datetime.now().strftime('%H:%M:%S')}\n\n"
            
            if large_files:
                result += f"Found {len(large_files)} files >100MB:\n"
                for file in large_files[:10]:  # Show top 10
                    result += f"‚Ä¢ {file['size_mb']}MB - {file['name']}\n"
            else:
                result += "No large files (>100MB) found\n"
            
            return result
            
        except Exception as e:
            return f"Large file scanner failed: {e}"
    
    def file_search_engine(self, query=""):
        try:
            import os
            import re
            from datetime import datetime
            
            # Extract search term
            search_term = ""
            if 'search' in query.lower():
                search_match = re.search(r'search\s+(?:for\s+)?(.+)', query, re.IGNORECASE)
                if search_match:
                    search_term = search_match.group(1).strip()
            elif query.strip():
                search_term = query.strip()
            
            if not search_term:
                return "File Search Engine\nUsage: 'search [filename]' or 'find [keyword]'"
            
            # Search locations
            search_paths = [
                os.path.expanduser("~\\Desktop"),
                os.path.expanduser("~\\Documents"),
                os.path.expanduser("~\\Downloads"),
                "C:\\Users\\Hp\\Videos\\inp"  # Current workspace
            ]
            
            found_files = []
            
            for search_path in search_paths:
                if not os.path.exists(search_path):
                    continue
                
                try:
                    for root, dirs, files in os.walk(search_path):
                        for file in files:
                            if search_term.lower() in file.lower():
                                file_path = os.path.join(root, file)
                                try:
                                    size = os.path.getsize(file_path)
                                    modified = datetime.fromtimestamp(os.path.getmtime(file_path))
                                    
                                    found_files.append({
                                        'name': file,
                                        'path': file_path,
                                        'size': size,
                                        'modified': modified.strftime('%Y-%m-%d %H:%M')
                                    })
                                except (OSError, PermissionError):
                                    continue
                        
                        # Limit results
                        if len(found_files) >= 15:
                            break
                except (OSError, PermissionError):
                    continue
            
            # Sort by modification time (newest first)
            found_files.sort(key=lambda x: x['modified'], reverse=True)
            
            result = f"File Search Results for '{search_term}'\n"
            result += f"Found {len(found_files)} files:\n\n"
            
            if found_files:
                for file in found_files[:10]:  # Show top 10
                    size_kb = file['size'] / 1024
                    result += f"üìÑ {file['name']}\n"
                    result += f"   üìÅ {file['path']}\n"
                    result += f"   üìÖ {file['modified']} | {size_kb:.1f}KB\n\n"
            else:
                result += f"No files found containing '{search_term}'\n"
            
            return result
            
        except Exception as e:
            return f"File search engine failed: {e}"
    
    def recent_files_tracker(self, query=""):
        try:
            import os
            import json
            import subprocess
            from datetime import datetime, timedelta
            
            recent_file = "recent_files.json"
            
            # Parse query for number and open command
            show_count = 12  # default
            open_file = False
            
            if query:
                # Extract number if specified
                import re
                numbers = re.findall(r'\d+', query)
                if numbers:
                    show_count = min(int(numbers[0]), 20)  # max 20
                
                # Check for open command
                if 'open' in query.lower():
                    open_file = True
            
            # Load existing recent files
            recent_files = []
            if os.path.exists(recent_file):
                try:
                    with open(recent_file, 'r', encoding='utf-8') as f:
                        recent_files = json.load(f)
                except:
                    recent_files = []
            
            # Auto-scan common directories for recent files
            scan_paths = [
                os.path.expanduser("~\\Desktop"),
                os.path.expanduser("~\\Documents"),
                os.path.expanduser("~\\Downloads"),
                "C:\\Users\\Hp\\Videos\\inp"
            ]
            
            current_files = []
            cutoff_time = datetime.now() - timedelta(days=7)
            
            for scan_path in scan_paths:
                if not os.path.exists(scan_path):
                    continue
                
                try:
                    for root, dirs, files in os.walk(scan_path):
                        if root.count(os.sep) - scan_path.count(os.sep) > 2:
                            continue
                        
                        for file in files:
                            try:
                                file_path = os.path.join(root, file)
                                modified_time = datetime.fromtimestamp(os.path.getmtime(file_path))
                                
                                if modified_time > cutoff_time:
                                    current_files.append({
                                        'name': file,
                                        'path': file_path,
                                        'modified': modified_time.isoformat(),
                                        'modified_str': modified_time.strftime('%Y-%m-%d %H:%M'),
                                        'size': os.path.getsize(file_path)
                                    })
                                
                                if len(current_files) >= 25:
                                    break
                            except (OSError, PermissionError):
                                continue
                        
                        if len(current_files) >= 25:
                            break
                except (OSError, PermissionError):
                    continue
            
            # Sort by modification time (newest first)
            current_files.sort(key=lambda x: x['modified'], reverse=True)
            recent_files = current_files[:20]
            
            # Save updated list
            try:
                with open(recent_file, 'w', encoding='utf-8') as f:
                    json.dump(recent_files, f, indent=2, ensure_ascii=False)
            except:
                pass
            
            # Open file if requested
            if open_file and recent_files:
                try:
                    os.startfile(recent_files[0]['path'])
                    return f"Opening: {recent_files[0]['name']}"
                except Exception as e:
                    return f"Failed to open file: {e}"
            
            result = f"Recent Files (Last 7 days) - Showing {min(show_count, len(recent_files))}\n"
            result += f"Updated: {datetime.now().strftime('%H:%M:%S')}\n\n"
            
            if recent_files:
                for i, file in enumerate(recent_files[:show_count], 1):
                    size_kb = file['size'] / 1024
                    result += f"{i}. üìÑ {file['name']}\n"
                    result += f"   üìÖ {file['modified_str']} | {size_kb:.1f}KB\n\n"
            else:
                result += "No recent files found\n"
            
            return result
            
        except Exception as e:
            return f"Recent files tracker failed: {e}"
    
    def recently_installed_apps(self, query=""):
        try:
            import subprocess
            import re
            from datetime import datetime, timedelta
            
            # Parse query for number
            show_count = 10  # default
            if query:
                numbers = re.findall(r'\d+', query)
                if numbers:
                    show_count = min(int(numbers[0]), 50)  # max 50
            
            # Get installed apps using PowerShell
            cmd = "Get-WmiObject -Class Win32_Product | Select-Object Name, InstallDate | Sort-Object InstallDate -Descending"
            result = subprocess.run(["powershell", "-Command", cmd], capture_output=True, text=True, timeout=30)
            
            if result.returncode != 0:
                return "Failed to retrieve installed apps"
            
            lines = result.stdout.strip().split('\n')
            apps = []
            
            for line in lines[3:]:  # Skip header lines
                if line.strip():
                    parts = line.strip().split()
                    if len(parts) >= 2:
                        date_str = parts[-1]
                        name = ' '.join(parts[:-1])
                        
                        if date_str and date_str != 'InstallDate':
                            try:
                                # Parse date format YYYYMMDD
                                if len(date_str) == 8 and date_str.isdigit():
                                    install_date = datetime.strptime(date_str, '%Y%m%d')
                                    apps.append({
                                        'name': name,
                                        'date': install_date.strftime('%Y-%m-%d'),
                                        'days_ago': (datetime.now() - install_date).days
                                    })
                            except:
                                continue
            
            # Sort by install date (newest first)
            apps.sort(key=lambda x: x['date'], reverse=True)
            
            output = f"Recently Installed Apps - Showing {min(show_count, len(apps))}\n"
            output += f"Updated: {datetime.now().strftime('%H:%M:%S')}\n\n"
            
            if apps:
                for i, app in enumerate(apps[:show_count], 1):
                    days_text = "today" if app['days_ago'] == 0 else f"{app['days_ago']} days ago"
                    output += f"{i}. üì± {app['name']}\n"
                    output += f"   üìÖ {app['date']} ({days_text})\n\n"
            else:
                output += "No recently installed apps found\n"
            
            return output
            
        except Exception as e:
            return f"Recently installed apps failed: {e}"
    


    
    def open_website(self, query=""):
        """Universal website opener with comprehensive mappings and AI fallback"""
        try:
            import webbrowser
            import re
            
            # Comprehensive website mappings
            website_mappings = {
                # Search Engines
                'google': 'https://www.google.com',
                'bing': 'https://www.bing.com',
                'yahoo': 'https://www.yahoo.com',
                'duckduckgo': 'https://duckduckgo.com',
                'yandex': 'https://yandex.com',
                'baidu': 'https://www.baidu.com',
                
                # Social Media
                'facebook': 'https://www.facebook.com',
                'twitter': 'https://www.twitter.com',
                'x': 'https://www.x.com',
                'instagram': 'https://www.instagram.com',
                'linkedin': 'https://www.linkedin.com',
                'tiktok': 'https://www.tiktok.com',
                'snapchat': 'https://www.snapchat.com',
                'pinterest': 'https://www.pinterest.com',
                'reddit': 'https://www.reddit.com',
                'discord': 'https://discord.com',
                'telegram': 'https://web.telegram.org',
                'whatsapp': 'https://web.whatsapp.com',
                'youtube': 'https://www.youtube.com',
                
                # Entertainment & Media
                'netflix': 'https://www.netflix.com',
                'amazon prime': 'https://www.primevideo.com',
                'disney plus': 'https://www.disneyplus.com',
                'hulu': 'https://www.hulu.com',
                'spotify': 'https://open.spotify.com',
                'apple music': 'https://music.apple.com',
                'soundcloud': 'https://soundcloud.com',
                'twitch': 'https://www.twitch.tv',
                'vimeo': 'https://vimeo.com',
                'dailymotion': 'https://www.dailymotion.com',
                
                # Shopping & E-commerce
                'amazon': 'https://www.amazon.com',
                'ebay': 'https://www.ebay.com',
                'alibaba': 'https://www.alibaba.com',
                'aliexpress': 'https://www.aliexpress.com',
                'walmart': 'https://www.walmart.com',
                'target': 'https://www.target.com',
                'bestbuy': 'https://www.bestbuy.com',
                'etsy': 'https://www.etsy.com',
                'shopify': 'https://www.shopify.com',
                
                # News & Information
                'cnn': 'https://www.cnn.com',
                'bbc': 'https://www.bbc.com',
                'reuters': 'https://www.reuters.com',
                'nytimes': 'https://www.nytimes.com',
                'guardian': 'https://www.theguardian.com',
                'wikipedia': 'https://www.wikipedia.org',
                'wikimedia': 'https://www.wikimedia.org',
                
                # Technology & Development
                'github': 'https://github.com',
                'stackoverflow': 'https://stackoverflow.com',
                'gitlab': 'https://gitlab.com',
                'bitbucket': 'https://bitbucket.org',
                'codepen': 'https://codepen.io',
                'jsfiddle': 'https://jsfiddle.net',
                'replit': 'https://replit.com',
                'codesandbox': 'https://codesandbox.io',
                'npm': 'https://www.npmjs.com',
                'pypi': 'https://pypi.org',
                
                # Cloud & Productivity
                'google drive': 'https://drive.google.com',
                'dropbox': 'https://www.dropbox.com',
                'onedrive': 'https://onedrive.live.com',
                'icloud': 'https://www.icloud.com',
                'gmail': 'https://mail.google.com',
                'outlook': 'https://outlook.live.com',
                'yahoo mail': 'https://mail.yahoo.com',
                'google docs': 'https://docs.google.com',
                'google sheets': 'https://sheets.google.com',
                'google slides': 'https://slides.google.com',
                'office 365': 'https://office.com',
                'notion': 'https://www.notion.so',
                'trello': 'https://trello.com',
                'slack': 'https://slack.com',
                'zoom': 'https://zoom.us',
                'teams': 'https://teams.microsoft.com',
                
                # Education & Learning
                'coursera': 'https://www.coursera.org',
                'udemy': 'https://www.udemy.com',
                'edx': 'https://www.edx.org',
                'khan academy': 'https://www.khanacademy.org',
                'codecademy': 'https://www.codecademy.com',
                'freecodecamp': 'https://www.freecodecamp.org',
                'duolingo': 'https://www.duolingo.com',
                
                # Finance & Banking
                'paypal': 'https://www.paypal.com',
                'stripe': 'https://stripe.com',
                'coinbase': 'https://www.coinbase.com',
                'binance': 'https://www.binance.com',
                'robinhood': 'https://robinhood.com',
                
                # Travel & Maps
                'google maps': 'https://maps.google.com',
                'booking': 'https://www.booking.com',
                'airbnb': 'https://www.airbnb.com',
                'expedia': 'https://www.expedia.com',
                'tripadvisor': 'https://www.tripadvisor.com',
                
                # Health & Fitness
                'webmd': 'https://www.webmd.com',
                'mayo clinic': 'https://www.mayoclinic.org',
                'fitbit': 'https://www.fitbit.com',
                'myfitnesspal': 'https://www.myfitnesspal.com',
                
                # Gaming
                'steam': 'https://store.steampowered.com',
                'epic games': 'https://www.epicgames.com',
                'origin': 'https://www.origin.com',
                'battle.net': 'https://www.battle.net',
                'xbox': 'https://www.xbox.com',
                'playstation': 'https://www.playstation.com',
                'nintendo': 'https://www.nintendo.com',
                
                # Design & Creative
                'behance': 'https://www.behance.net',
                'dribbble': 'https://dribbble.com',
                'figma': 'https://www.figma.com',
                'canva': 'https://www.canva.com',
                'adobe': 'https://www.adobe.com',
                'unsplash': 'https://unsplash.com',
                'pexels': 'https://www.pexels.com',
                
                # Communication
                'skype': 'https://web.skype.com',
                'viber': 'https://www.viber.com',
                'messenger': 'https://www.messenger.com',
                
                # Food & Delivery
                'ubereats': 'https://www.ubereats.com',
                'doordash': 'https://www.doordash.com',
                'grubhub': 'https://www.grubhub.com',
                'zomato': 'https://www.zomato.com',
                
                # Weather
                'weather': 'https://weather.com',
                'accuweather': 'https://www.accuweather.com',
                
                # Miscellaneous
                'craigslist': 'https://craigslist.org',
                'indeed': 'https://www.indeed.com',
                'glassdoor': 'https://www.glassdoor.com',
                'quora': 'https://www.quora.com',
                'medium': 'https://medium.com',
                'tumblr': 'https://www.tumblr.com',
                'flickr': 'https://www.flickr.com',
                'imdb': 'https://www.imdb.com',
                'rottentomatoes': 'https://www.rottentomatoes.com'
            }
            
            # Extract website name from query
            website_name = ""
            query_lower = query.lower().strip()
            
            # Remove common prefixes
            for prefix in ['open ', 'launch ', 'start ', 'run ', 'website ', 'site ', 'web ', 'browse ', 'go to ']:
                if query_lower.startswith(prefix):
                    query_lower = query_lower[len(prefix):].strip()
                    break
            
            # Check if it's already a URL
            if any(protocol in query_lower for protocol in ['http://', 'https://', 'www.']):
                url = query_lower
                if not url.startswith(('http://', 'https://')):
                    url = 'https://' + url
                webbrowser.open(url)
                return f"üåê Opened website: {url}"
            
            # Check direct mappings first
            website_name = query_lower
            if website_name in website_mappings:
                url = website_mappings[website_name]
                webbrowser.open(url)
                return f"üåê Opened {website_name.title()}: {url}"
            
            # Check partial matches
            for site, url in website_mappings.items():
                if site in query_lower or query_lower in site:
                    webbrowser.open(url)
                    return f"üåê Opened {site.title()}: {url}"
            
            # AI fallback for unknown websites
            try:
                from engine.dual_ai import dual_ai
                
                ai_prompt = f'''Find the correct website URL for: "{query}"
                
Respond ONLY in this format:
Website: [website name]
URL: [full https URL]
Description: [brief description]
                
Examples:
Website: OpenAI
URL: https://www.openai.com
Description: AI research company

Website: Microsoft
URL: https://www.microsoft.com
Description: Technology corporation
                
If unsure, provide the most likely official website URL.'''
                
                if dual_ai.ai_provider == 'groq':
                    response = dual_ai.groq_client.chat.completions.create(
                        messages=[{"role": "user", "content": ai_prompt}],
                        model="llama-3.1-8b-instant"
                    )
                    ai_response = response.choices[0].message.content.strip()
                else:
                    response = dual_ai.gemini_model.generate_content(ai_prompt)
                    ai_response = response.text.strip()
                
                # Parse AI response
                url_match = re.search(r'URL:\s*(https?://[^\s]+)', ai_response, re.IGNORECASE)
                name_match = re.search(r'Website:\s*(.+)', ai_response, re.IGNORECASE)
                
                if url_match:
                    url = url_match.group(1).strip()
                    name = name_match.group(1).strip() if name_match else query
                    
                    webbrowser.open(url)
                    return f"üåê AI found and opened {name}: {url}"
                else:
                    # Fallback: construct likely URL
                    clean_name = re.sub(r'[^a-zA-Z0-9]', '', query_lower)
                    fallback_url = f"https://www.{clean_name}.com"
                    webbrowser.open(fallback_url)
                    return f"üåê Opened best guess: {fallback_url}"
                    
            except Exception as ai_error:
                print(f"AI website lookup failed: {ai_error}")
                
                # Final fallback: Google search
                search_query = query.replace(' ', '+')
                google_search = f"https://www.google.com/search?q={search_query}+official+website"
                webbrowser.open(google_search)
                return f"üåê Opened Google search for '{query}' official website"
                
        except Exception as e:
            return f"Website opening failed: {e}"


  
    def close_website(self, query=""):
        """Close browser or specific website tabs"""
        try:
            import subprocess
            import re
            
            # Website mappings for recognition
            website_mappings = {
                'google': 'Google', 'bing': 'Bing', 'yahoo': 'Yahoo', 'duckduckgo': 'DuckDuckGo',
                'facebook': 'Facebook', 'twitter': 'Twitter', 'x': 'X', 'instagram': 'Instagram',
                'linkedin': 'LinkedIn', 'tiktok': 'TikTok', 'youtube': 'YouTube', 'netflix': 'Netflix',
                'amazon': 'Amazon', 'ebay': 'eBay', 'github': 'GitHub', 'stackoverflow': 'Stack Overflow',
                'gmail': 'Gmail', 'outlook': 'Outlook', 'zoom': 'Zoom', 'teams': 'Microsoft Teams',
                'spotify': 'Spotify', 'discord': 'Discord', 'slack': 'Slack', 'reddit': 'Reddit'
            }
            
            browsers = {
                'chrome': 'chrome.exe',
                'firefox': 'firefox.exe', 
                'edge': 'msedge.exe',
                'safari': 'safari.exe',
                'opera': 'opera.exe'
            }
            
            if not query:
                for browser in browsers.values():
                    subprocess.run(['taskkill', '/f', '/im', browser], capture_output=True)
                return "Closed all browsers"
            
            query_lower = query.lower().strip()
            
            # Remove common prefixes
            for prefix in ['close ', 'quit ', 'exit ', 'stop ']:
                if query_lower.startswith(prefix):
                    query_lower = query_lower[len(prefix):].strip()
                    break
            
            # Close specific browser
            if query_lower in browsers:
                subprocess.run(['taskkill', '/f', '/im', browsers[query_lower]], capture_output=True)
                return f" Closed {query_lower}"
            
            # Close all browsers if "browser" mentioned
            if 'browser' in query_lower:
                for browser in browsers.values():
                    subprocess.run(['taskkill', '/f', '/im', browser], capture_output=True)
                return " Closed all browsers"
            
            # Check website mappings
            if query_lower in website_mappings:
                for browser in browsers.values():
                    subprocess.run(['taskkill', '/f', '/im', browser], capture_output=True)
                return f" Closed browsers (was viewing {website_mappings[query_lower]})"
            
            # AI fallback
            try:
                from engine.dual_ai import dual_ai
                
                ai_prompt = f'''Identify if "{query}" is a website or browser name.
                
Respond ONLY:
Type: [website/browser/unknown]
Action: [close_browser/close_all/unknown]
                
Examples:
Type: website
Action: close_browser

Type: browser
Action: close_browser'''
                
                if dual_ai.ai_provider == 'groq':
                    response = dual_ai.groq_client.chat.completions.create(
                        messages=[{"role": "user", "content": ai_prompt}],
                        model="llama-3.1-8b-instant"
                    )
                    ai_response = response.choices[0].message.content.strip()
                else:
                    response = dual_ai.gemini_model.generate_content(ai_prompt)
                    ai_response = response.text.strip()
                
                if 'close_browser' in ai_response.lower():
                    for browser in browsers.values():
                        subprocess.run(['taskkill', '/f', '/im', browser], capture_output=True)
                    return f" AI closed browsers (was viewing {query})"
                    
            except Exception:
                pass
            
            # Final fallback - close all browsers
            for browser in browsers.values():
                subprocess.run(['taskkill', '/f', '/im', browser], capture_output=True)
            return f" Closed browsers for '{query}'"
            
        except Exception as e:
            return f"Failed to close: {e}"
        
    def python_packages(self, query=""):
        import subprocess
        import re
        
        limit = 10
        numbers = re.findall(r'\d+', query)
        if numbers:
            limit = int(numbers[0])
        
        try:
            result = subprocess.run(['pip', 'list'], capture_output=True, text=True)
            lines = result.stdout.strip().split('\n')[2:]
            
            packages = []
            for line in lines[:limit]:
                if line.strip():
                    parts = line.split()
                    if len(parts) >= 2:
                        packages.append(f"{parts[0]} ({parts[1]})")
            
            return f"Top {len(packages)} installed packages:\n" + "\n".join(packages)
        
        except Exception as e:
            return f"Error getting packages: {e}"



new_features = NewFeatures()

def get_new_feature_response(query):
    return new_features.execute(query)
"""
AI Personality Manager - Controls response style and personality across all Jarvis features
"""

import json
import os

class PersonalityManager:
    def __init__(self):
        self.config_file = 'personality_config.json'
        self.load_config()
        
        # Response style templates
        self.response_styles = {
            'professional': {
                'prefix': 'I shall ',
                'suffix': ', sir.',
                'tone': 'formal',
                'examples': {
                    'success': 'I have successfully completed the requested operation',
                    'error': 'I regret to inform you that the operation could not be completed',
                    'executing': 'I am proceeding with the requested task'
                }
            },
            'casual': {
                'prefix': '',
                'suffix': '!',
                'tone': 'relaxed',
                'examples': {
                    'success': 'Got it done for you',
                    'error': 'Oops, that didn\'t work out',
                    'executing': 'Working on it'
                }
            },
            'friendly': {
                'prefix': 'I\'d be happy to ',
                'suffix': '!',
                'tone': 'warm',
                'examples': {
                    'success': 'I\'m glad I could help you with that',
                    'error': 'Sorry, I couldn\'t get that to work',
                    'executing': 'I\'m working on that for you right now'
                }
            },
            'technical': {
                'prefix': 'Executing ',
                'suffix': '...',
                'tone': 'precise',
                'examples': {
                    'success': 'Operation completed successfully',
                    'error': 'Error: Operation failed with status code',
                    'executing': 'Processing request with system parameters'
                }
            }
        }
        
        # AI personality traits
        self.personalities = {
            'normal': {
                'greeting': 'Hello! How can I help you?',
                'acknowledgment': 'Okay.',
                'completion': 'Task completed.',
                'style': 'default and natural'
            },
            'formal': {
                'greeting': 'Good day, sir. How may I assist you?',
                'acknowledgment': 'Very well, sir.',
                'completion': 'The task has been completed to your specifications.',
                'style': 'respectful and structured'
            },
            'humorous': {
                'greeting': 'Hey there! Ready for some digital magic?',
                'acknowledgment': 'You got it, boss!',
                'completion': 'Mission accomplished! *virtual high-five*',
                'style': 'witty and playful'
            },
            'serious': {
                'greeting': 'Ready for commands.',
                'acknowledgment': 'Understood.',
                'completion': 'Task completed.',
                'style': 'direct and focused'
            },
            'creative': {
                'greeting': 'Hello! Let\'s create something amazing together!',
                'acknowledgment': 'Interesting choice! Let me work my magic.',
                'completion': 'Voil√†! Another masterpiece delivered!',
                'style': 'imaginative and inspiring'
            }
        }
    
    def load_config(self):
        """Load personality configuration"""
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, 'r') as f:
                    config = json.load(f)
                    self.current_style = config.get('response_style', 'professional')
                    self.current_personality = config.get('ai_personality', 'formal')
            else:
                self.current_style = 'professional'
                self.current_personality = 'formal'
                self.save_config()
        except:
            self.current_style = 'professional'
            self.current_personality = 'formal'
    
    def save_config(self):
        """Save personality configuration"""
        try:
            config = {
                'response_style': self.current_style,
                'ai_personality': self.current_personality
            }
            with open(self.config_file, 'w') as f:
                json.dump(config, f)
        except:
            pass
    
    def set_response_style(self, style):
        """Set response style"""
        if style.lower() in self.response_styles:
            self.current_style = style.lower()
            self.save_config()
            return f"Response style set to {style}"
        return "Invalid response style"
    
    def set_personality(self, personality):
        """Set AI personality"""
        if personality.lower() in self.personalities:
            self.current_personality = personality.lower()
            self.save_config()
            return f"AI personality set to {personality}"
        return "Invalid personality type"
    
    def transform_response(self, base_response, context='general'):
        """Transform response using Groq AI for personality"""
        if not base_response:
            return "Task completed."
        
        # If normal personality, return original response without transformation
        if self.current_personality == 'normal':
            return base_response
        
        try:
            from groq import Groq
            from engine.groq_config import GROQ_API_KEY
            
            client = Groq(api_key=GROQ_API_KEY)
            
            # Get both style and personality from config
            style_tone = self.response_styles.get(self.current_style, {}).get('tone', 'normal')
            personality_trait = self.personalities.get(self.current_personality, {}).get('style', 'normal')
            
            prompt = f'Transform "{base_response}" using {style_tone} tone with {personality_trait} personality. Max 8 words:'
            
            response = client.chat.completions.create(
                messages=[{"role": "user", "content": prompt}],
                model="llama-3.1-8b-instant",
                max_tokens=30
            )
            
            transformed = response.choices[0].message.content.strip().strip('"').strip("'")
            
            return transformed if transformed else base_response
            
        except:
            return base_response
    
    def _apply_personality_transform(self, response, personality):
        """Apply personality transformations"""
        if self.current_personality == 'humorous':
            response += ' (with style!)'
        elif self.current_personality == 'creative':
            response = response.replace('increased', 'amplified').replace('opened', 'summoned').replace('completed', 'crafted')
        elif self.current_personality == 'serious':
            response = response.replace('!', '.').replace('...', '.')
        
        return response
    
    def _apply_style_transform(self, response, style, context):
        """Apply style transformations"""
        if self.current_style == 'professional':
            if not response.endswith('.'):
                response += '.'
            response = response.replace('opened', 'has been opened')
        elif self.current_style == 'casual':
            if not response.endswith('!'):
                response = response.rstrip('.') + '!'
        elif self.current_style == 'friendly':
            response = f"Great! {response}"
        elif self.current_style == 'technical':
            response = f"[SUCCESS] {response}"
        
        return response
    
    def get_greeting(self):
        """Get personality-appropriate greeting"""
        personality = self.personalities.get(self.current_personality, self.personalities['formal'])
        return self.transform_response(personality['greeting'])
    
    def get_acknowledgment(self):
        """Get personality-appropriate acknowledgment"""
        personality = self.personalities.get(self.current_personality, self.personalities['formal'])
        return self.transform_response(personality['acknowledgment'])
    
    def get_current_settings(self):
        """Get current personality settings"""
        return {
            'response_style': self.current_style.capitalize(),
            'ai_personality': self.current_personality.capitalize()
        }

# Global instance
personality_manager = PersonalityManager()
import subprocess
import time
from engine.command import speak

# Use the main app's speak (routes to frontend via eel)

def check_adb_connection():
    """Check if ADB device is connected"""
    try:
        result = subprocess.run('C:\\platform-tools\\adb.exe devices', shell=True, capture_output=True, text=True)
        lines = result.stdout.strip().split('\n')
        connected_devices = [line for line in lines[1:] if line.strip() and 'device' in line]
        return len(connected_devices) > 0
    except:
        return False

def handle_phone_commands(query):
    """Handle all phone-related commands"""
    
    # Basic swipe commands
    if "swipe up" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell input swipe 500 1500 500 500', shell=True)
            speak("Swiped up")
        else:
            speak("Phone not connected")
    
    elif "swipe down" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell input swipe 500 500 500 1500', shell=True)
            speak("Swiped down")
        else:
            speak("Phone not connected")
    
    elif "swipe left" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell input swipe 800 800 200 800', shell=True)
            speak("Swiped left")
        else:
            speak("Phone not connected")
    
    elif "swipe right" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell input swipe 200 800 800 800', shell=True)
            speak("Swiped right")
        else:
            speak("Phone not connected")
    
    elif "back" in query or "go back" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell input keyevent KEYCODE_BACK', shell=True)
            speak("Going back")
        else:
            speak("Phone not connected")
    
    elif "home" in query or "go home" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell input keyevent KEYCODE_HOME', shell=True)
            speak("Going home")
        else:
            speak("Phone not connected")
    
    elif "tap" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell input tap 500 800', shell=True)
            speak("Screen tapped")
        else:
            speak("Phone not connected")
    
    # Phone control commands
    elif "unlock" in query or "wake up" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell input keyevent KEYCODE_POWER', shell=True)
            subprocess.run('C:\\platform-tools\\adb.exe shell input swipe 500 1500 500 500', shell=True)
            speak("Phone unlocked")
        else:
            speak("Phone not connected")
        
    elif "lock" in query or "sleep" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell input keyevent KEYCODE_POWER', shell=True)
            speak("Phone locked")
        else:
            speak("Phone not connected")
        
    elif "volume up" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell input keyevent KEYCODE_VOLUME_UP', shell=True)
            speak("Volume increased")
        else:
            speak("Phone not connected")
        
    elif "volume down" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell input keyevent KEYCODE_VOLUME_DOWN', shell=True)
            speak("Volume decreased")
        else:
            speak("Phone not connected")
        
    elif "mute" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell input keyevent KEYCODE_VOLUME_MUTE', shell=True)
            speak("Phone muted")
        else:
            speak("Phone not connected")
        
    elif "screenshot" in query or "capture screen" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell screencap -p /sdcard/screenshot.png', shell=True)
            subprocess.run('C:\\platform-tools\\adb.exe pull /sdcard/screenshot.png .', shell=True)
            speak("Screenshot taken")
        else:
            speak("Phone not connected")
    
    # Screen mirroring
    elif "mirror" in query or "show screen" in query or "display screen" in query:
        if check_adb_connection():
            speak("Starting phone mirroring")
            subprocess.Popen('C:\\scrcpy-win64-v3.3.2\\scrcpy.exe --stay-awake', shell=True)
            speak("Phone screen mirrored")
        else:
            speak("Phone not connected")
    
    elif "stop mirroring" in query or "close screen" in query:
        speak("Stopping screen mirroring")
        subprocess.run('taskkill /f /im scrcpy.exe', shell=True)
        speak("Screen mirroring stopped")
    
    # URL open on phone - handle before generic "open" app routing
    elif "open url on phone" in query or "open link on phone" in query:
        if check_adb_connection():
            import re
            m = re.search(r'(https?://\S+)', query)
            if m:
                url = m.group(1)
                subprocess.run(f'C\\platform-tools\\adb.exe shell am start -a android.intent.action.VIEW -d "{url}"', shell=True)
                speak("Opened link on phone")
            else:
                speak("Please say: open URL on phone followed by the link")
        else:
            speak("Phone not connected")

    # App opening
    elif "open" in query:
        app_name = query.replace("open", "").strip()
        
        phone_apps = {
            'whatsapp': 'com.whatsapp',
            'instagram': 'com.instagram.android', 
            'facebook': 'com.facebook.katana',
            'youtube': 'com.google.android.youtube',
            'gmail': 'com.google.android.gm',
            'chrome': 'com.android.chrome',
            'maps': 'com.google.android.apps.maps',
            'camera': 'com.android.camera',
            'gallery': 'com.miui.gallery',
            'settings': 'com.android.settings'
        }
        
        if app_name in phone_apps:
            if check_adb_connection():
                speak(f"Opening {app_name}")
                subprocess.run(f'C:\\platform-tools\\adb.exe shell monkey -p {phone_apps[app_name]} 1', shell=True)
                speak(f"{app_name} opened")
            else:
                speak("Phone not connected")
        else:
            speak(f"{app_name} not found")
    
    # Advanced gesture controls
    elif "double tap" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell input tap 500 800', shell=True)
            time.sleep(0.1)
            subprocess.run('C:\\platform-tools\\adb.exe shell input tap 500 800', shell=True)
            speak("Double tap performed")
        else:
            speak("Phone not connected")
    
    elif "long press" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell input swipe 500 800 500 800 1000', shell=True)
            speak("Long press performed")
        else:
            speak("Phone not connected")
    
    elif "scroll up" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell input swipe 500 1200 500 800', shell=True)
            speak("Scrolled up")
        else:
            speak("Phone not connected")
    
    elif "scroll down" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell input swipe 500 800 500 1200', shell=True)
            speak("Scrolled down")
        else:
            speak("Phone not connected")
    
    elif "zoom in" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell input swipe 400 600 300 500 & C:\\platform-tools\\adb.exe shell input swipe 600 600 700 700', shell=True)
            speak("Zoomed in")
        else:
            speak("Phone not connected")
    
    elif "zoom out" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell input swipe 300 500 400 600 & C:\\platform-tools\\adb.exe shell input swipe 700 700 600 600', shell=True)
            speak("Zoomed out")
        else:
            speak("Phone not connected")
    
    # System controls
    elif "wifi on" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell svc wifi enable', shell=True)
            speak("WiFi enabled")
        else:
            speak("Phone not connected")
    
    elif "wifi off" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell svc wifi disable', shell=True)
            speak("WiFi disabled")
        else:
            speak("Phone not connected")
    
    # Removed generic "wifi" handler to avoid duplication; use "wifi on/off" instead
    
    elif "bluetooth on" in query:
        if check_adb_connection():
            # Modern Android supports cmd bluetooth enable
            subprocess.run('C:\\platform-tools\\adb.exe shell cmd bluetooth enable', shell=True)
            speak("Bluetooth enabled")
        else:
            speak("Phone not connected")
    
    elif "bluetooth off" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell cmd bluetooth disable', shell=True)
            speak("Bluetooth disabled")
        else:
            speak("Phone not connected")
    
    # Removed generic "bluetooth" handler to avoid duplication; use "bluetooth on/off" instead
    
    elif "flashlight on" in query or "torch on" in query:
        if check_adb_connection():
            # Try direct torch command first (Android 13+)
            result = subprocess.run('C:\\platform-tools\\adb.exe shell cmd torch on', shell=True)
            if result.returncode != 0:
                # Fallback to quick settings tile
                subprocess.run('C:\\platform-tools\\adb.exe shell input swipe 500 0 500 800', shell=True)
                time.sleep(1)
                subprocess.run('C:\\platform-tools\\adb.exe shell input tap 200 200', shell=True)
            speak("Flashlight turned on")
        else:
            speak("Phone not connected")
    
    elif "flashlight off" in query or "torch off" in query:
        if check_adb_connection():
            # Try direct torch command first (Android 13+)
            result = subprocess.run('C:\\platform-tools\\adb.exe shell cmd torch off', shell=True)
            if result.returncode != 0:
                # Fallback to quick settings tile
                subprocess.run('C:\\platform-tools\\adb.exe shell input swipe 500 0 500 800', shell=True)
                time.sleep(1)
                subprocess.run('C:\\platform-tools\\adb.exe shell input tap 200 200', shell=True)
            speak("Flashlight turned off")
        else:
            speak("Phone not connected")
    
    elif "brightness up" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell input swipe 500 0 500 800', shell=True)
            time.sleep(1)
            subprocess.run('C:\\platform-tools\\adb.exe shell input swipe 200 600 700 600', shell=True)
            speak("Brightness increased")
        else:
            speak("Phone not connected")
    
    elif "brightness down" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell input swipe 500 0 500 800', shell=True)
            time.sleep(1)
            subprocess.run('C:\\platform-tools\\adb.exe shell input swipe 700 600 200 600', shell=True)
            speak("Brightness decreased")
        else:
            speak("Phone not connected")
    
    # Media controls
    elif "play music" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell input keyevent KEYCODE_MEDIA_PLAY', shell=True)
            speak("Music playing")
        else:
            speak("Phone not connected")
    
    elif "pause music" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell input keyevent KEYCODE_MEDIA_PAUSE', shell=True)
            speak("Music paused")
        else:
            speak("Phone not connected")
    
    elif "next song" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell input keyevent KEYCODE_MEDIA_NEXT', shell=True)
            speak("Next song")
        else:
            speak("Phone not connected")
    
    elif "previous song" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell input keyevent KEYCODE_MEDIA_PREVIOUS', shell=True)
            speak("Previous song")
        else:
            speak("Phone not connected")
    
    # Smart modes
    elif "bedtime mode" in query or "sleep mode" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell settings put global zen_mode 1', shell=True)
            subprocess.run('C:\\platform-tools\\adb.exe shell settings put system screen_brightness 50', shell=True)
            speak("Bedtime mode activated")
        else:
            speak("Phone not connected")
    
    elif "morning mode" in query or "wake up mode" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell settings put global zen_mode 0', shell=True)
            subprocess.run('C:\\platform-tools\\adb.exe shell settings put system screen_brightness 200', shell=True)
            speak("Morning mode activated")
        else:
            speak("Phone not connected")
    
    elif "driving mode" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell settings put global zen_mode 1', shell=True)
            subprocess.run('C:\\platform-tools\\adb.exe shell monkey -p com.google.android.apps.maps 1', shell=True)
            speak("Driving mode activated")
        else:
            speak("Phone not connected")
    
    # Battery and performance
    elif "battery" in query:
        if check_adb_connection():
            result = subprocess.run('C:\\platform-tools\\adb.exe shell dumpsys battery | findstr level', shell=True, capture_output=True, text=True)
            if result.stdout:
                level = result.stdout.split(':')[1].strip()
                speak(f"Battery is at {level} percent")
            else:
                speak("Could not get battery info")
        else:
            speak("Phone not connected")
    
    elif "battery saver" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell settings put global low_power 1', shell=True)
            speak("Battery saver enabled")
        else:
            speak("Phone not connected")
    
    elif "dark mode" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell cmd uimode night yes', shell=True)
            speak("Dark mode enabled")
        else:
            speak("Phone not connected")
    
    elif "light mode" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell cmd uimode night no', shell=True)
            speak("Light mode enabled")
        else:
            speak("Phone not connected")
    
    # Text input
    elif "type" in query:
        from engine.command import takecommand
        if check_adb_connection():
            speak("What text do you want to type?")
            text = takecommand()
            if text:
                subprocess.run(f'C:\\platform-tools\\adb.exe shell input text "{text}"', shell=True)
                speak("Text entered")
        else:
            speak("Phone not connected")
    
    # Emergency and utility
    elif "find phone" in query or "locate phone" in query:
        if check_adb_connection():
            # Disable DND and raise volumes
            try:
                subprocess.run('C:\\platform-tools\\adb.exe shell settings put global zen_mode 0', shell=True)
            except:
                pass
            try:
                for _ in range(15):
                    subprocess.run('C:\\platform-tools\\adb.exe shell input keyevent KEYCODE_VOLUME_UP', shell=True)
                    time.sleep(0.08)
            except:
                pass
            try:
                subprocess.run('C:\\platform-tools\\adb.exe shell cmd audio set-master-mute false', shell=True)
            except:
                pass

            # Try to trigger an alarm/alert activity (varies by OEM)
            alarm_intents = [
                'am start -n com.google.android.deskclock/com.android.deskclock.alerting.AlertFullscreenActivity',
                'am start -n com.google.android.deskclock/com.android.deskclock.AlarmActivity',
                'am start -n com.android.deskclock/.AlarmAlertFullScreen',
                'am start -a com.android.deskclock.ALARM_ALERT'
            ]
            for intent in alarm_intents:
                try:
                    subprocess.run(f'C:\\platform-tools\\adb.exe shell {intent}', shell=True)
                    time.sleep(0.4)
                except:
                    continue

            # Post multiple high-priority notifications (some ROMs play default sound)
            try:
                for _ in range(4):
                    subprocess.run('C:\\platform-tools\\adb.exe shell cmd notification post -t "Find Phone" "jarvis.find" "Phone is here"', shell=True)
                    time.sleep(0.6)
            except:
                pass

            # Try to play a built-in ringtone file via media viewer
            ringtone_candidates = [
                'file:///sdcard/Download/jarvis_ring.ogg',
                'file:///system/media/audio/ringtones/Ring_Synth_04.ogg',
                'file:///system/media/audio/ringtones/Basic_tone.ogg',
                'file:///system/media/audio/ringtones/Orion.ogg',
                'file:///system/media/audio/notifications/Argon.ogg'
            ]
            for uri in ringtone_candidates:
                try:
                    subprocess.run(f'C\\platform-tools\\adb.exe shell am start -a android.intent.action.VIEW -d {uri} -t audio/*', shell=True)
                    time.sleep(0.4)
                    # Try to force playback
                    for _ in range(3):
                        subprocess.run('C\\platform-tools\\adb.exe shell input keyevent KEYCODE_MEDIA_PLAY', shell=True)
                        time.sleep(0.2)
                    # Also try media dispatch play (Android 13+)
                    subprocess.run('C\\platform-tools\\adb.exe shell cmd media dispatch play', shell=True)
                    # Boost volume again just in case
                    for _ in range(3):
                        subprocess.run('C\\platform-tools\\adb.exe shell input keyevent KEYCODE_VOLUME_UP', shell=True)
                        time.sleep(0.1)
                except:
                    continue

            # Removed web URL fallback to avoid opening Chrome
            speak("Phone is ringing to help you find it")
        else:
            speak("Phone not connected")
    
    elif "restart" in query or "reboot" in query:
        if check_adb_connection():
            speak("Restarting phone")
            subprocess.run('C:\\platform-tools\\adb.exe shell reboot', shell=True)
        else:
            speak("Phone not connected")
    
    elif "connection" in query or "status" in query:
        if check_adb_connection():
            speak("Phone is connected and ready")
        else:
            speak("Phone not connected")
    
    # MIUI Specific Features for Redmi 12 5G
    elif "game mode" in query or "gaming mode" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell am start -n com.miui.securitycenter/com.miui.gamebooster.ui.GameBoosterMainActivity', shell=True)
            speak("Game mode activated")
        else:
            speak("Phone not connected")
    
    elif "game turbo" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell am start -n com.xiaomi.gamecenter.sdk.service/.GameCenterService', shell=True)
            speak("Game turbo enabled")
        else:
            speak("Phone not connected")
    
    elif "security center" in query or "security app" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell monkey -p com.miui.securitycenter 1', shell=True)
            speak("Security center opened")
        else:
            speak("Phone not connected")
    
    elif "cleaner" in query or "clean phone" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell am start -n com.miui.securitycenter/com.miui.optimizecenter.MainActivity', shell=True)
            speak("Phone cleaner opened")
        else:
            speak("Phone not connected")
    
    elif "boost performance" in query or "performance boost" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell am start -n com.miui.securitycenter/com.miui.powercenter.PowerCenterActivity', shell=True)
            speak("Performance boost activated")
        else:
            speak("Phone not connected")
    
    elif "mi mover" in query or "clone phone" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell monkey -p com.miui.huanji 1', shell=True)
            speak("Mi Mover opened")
        else:
            speak("Phone not connected")
    
    elif "themes" in query or "theme store" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell monkey -p com.android.thememanager 1', shell=True)
            speak("Theme store opened")
        else:
            speak("Phone not connected")
    
    elif "mi remote" in query or "infrared" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell monkey -p com.duokan.phone.remotecontroller 1', shell=True)
            speak("Mi Remote opened")
        else:
            speak("Phone not connected")
    
    elif "compass" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell monkey -p com.miui.compass 1', shell=True)
            speak("Compass opened")
        else:
            speak("Phone not connected")
    
    elif "scanner" in query or "qr scanner" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell monkey -p com.xiaomi.scanner 1', shell=True)
            speak("Scanner opened")
        else:
            speak("Phone not connected")
    
    elif "recorder" in query or "voice recorder" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell monkey -p com.android.soundrecorder 1', shell=True)
            speak("Voice recorder opened")
        else:
            speak("Phone not connected")
    
    elif "file manager" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell monkey -p com.mi.android.globalFileexplorer 1', shell=True)
            speak("File manager opened")
        else:
            speak("Phone not connected")
    
    elif "downloads" in query or "download manager" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell am start -a android.intent.action.VIEW_DOWNLOADS', shell=True)
            speak("Downloads opened")
        else:
            speak("Phone not connected")
    
    # Clipboard and URL handoff
    elif "send clipboard to phone" in query or "clipboard to phone" in query:
        if check_adb_connection():
            try:
                pc_clip = subprocess.run(['powershell', '-NoProfile', '-Command', 'Get-Clipboard'], capture_output=True, text=True)
                clip_text = (pc_clip.stdout or "").strip()
            except Exception:
                clip_text = ""
            if clip_text:
                safe_text = clip_text.replace('"', '\\"')
                subprocess.run(f'C:\\platform-tools\\adb.exe shell cmd clipboard set "{safe_text}"', shell=True)
                speak("Clipboard sent to phone")
            else:
                speak("PC clipboard is empty")
        else:
            speak("Phone not connected")

    elif "copy from phone clipboard" in query or "get phone clipboard" in query:
        if check_adb_connection():
            result = subprocess.run('C:\\platform-tools\\adb.exe shell cmd clipboard get', shell=True, capture_output=True, text=True)
            phone_clip = (result.stdout or "").strip()
            if phone_clip:
                try:
                    # Use PowerShell here-string to preserve content
                    subprocess.run(['powershell', '-NoProfile', '-Command', f'Set-Clipboard -Value @"\n{phone_clip}\n"@'], shell=False)
                except Exception:
                    pass
                speak("Copied phone clipboard to computer")
            else:
                speak("Phone clipboard is empty")
        else:
            speak("Phone not connected")

    elif "open url on phone" in query or "open link on phone" in query:
        if check_adb_connection():
            import re
            m = re.search(r'(https?://\S+)', query)
            if m:
                url = m.group(1)
                subprocess.run(f'C:\\platform-tools\\adb.exe shell am start -a android.intent.action.VIEW -d "{url}"', shell=True)
                speak("Opened link on phone")
            else:
                speak("Please say: open URL on phone followed by the link")
        else:
            speak("Phone not connected")
    
    # File/Image transfer helpers
    elif "pull latest photo" in query or "get latest photo" in query:
        if check_adb_connection():
            # Try Camera folder first
            result = subprocess.run('C:\\platform-tools\\adb.exe shell ls -t /sdcard/DCIM/Camera | head -1', shell=True, capture_output=True, text=True)
            latest = (result.stdout or "").strip().splitlines()[0] if result.stdout else ""
            if latest:
                subprocess.run(f'C:\\platform-tools\\adb.exe pull /sdcard/DCIM/Camera/{latest} .', shell=True)
                speak("Latest photo saved to computer")
            else:
                speak("Could not find latest photo")
        else:
            speak("Phone not connected")
    
    elif "pull latest screenshot" in query or "get latest screenshot" in query:
        if check_adb_connection():
            result = subprocess.run('C:\\platform-tools\\adb.exe shell ls -t /sdcard/Pictures/Screenshots | head -1', shell=True, capture_output=True, text=True)
            latest = (result.stdout or "").strip().splitlines()[0] if result.stdout else ""
            if latest:
                subprocess.run(f'C:\\platform-tools\\adb.exe pull /sdcard/Pictures/Screenshots/{latest} .', shell=True)
                speak("Latest screenshot saved to computer")
            else:
                speak("Could not find latest screenshot")
        else:
            speak("Phone not connected")
    
    elif "pull recent photos" in query or "get recent photos" in query:
        if check_adb_connection():
            # Pull top 3 recent camera images
            result = subprocess.run('C:\\platform-tools\\adb.exe shell ls -t /sdcard/DCIM/Camera | head -3', shell=True, capture_output=True, text=True)
            files = [f.strip() for f in (result.stdout or "").splitlines() if f.strip()]
            if files:
                for f in files:
                    subprocess.run(f'C:\\platform-tools\\adb.exe pull /sdcard/DCIM/Camera/{f} .', shell=True)
                speak("Recent photos saved to computer")
            else:
                speak("Could not find recent photos")
        else:
            speak("Phone not connected")
    
    elif "push download" in query or "send to phone" in query:
        if check_adb_connection():
            # Expect a filename spoken after the phrase, e.g., "send to phone sample.jpg"
            parts = query.split()
            candidate = None
            for p in parts[::-1]:
                if "." in p and len(p) <= 64:
                    candidate = p
                    break
            if candidate:
                # Push from current directory to phone Downloads
                subprocess.run(f'C:\\platform-tools\\adb.exe push "{candidate}" /sdcard/Download/', shell=True)
                speak("File sent to phone Downloads")
            else:
                speak("Say: send to phone <filename with extension>")
        else:
            speak("Phone not connected")
    
    # Phone calling feature
    elif "call" in query:
        if check_adb_connection():
            from engine.command import takecommand
            speak("What number do you want to call?")
            number = takecommand()
            if number:
                # Extract digits from speech
                import re
                digits = re.findall(r'\d+', number)
                if digits:
                    phone_number = ''.join(digits)
                    subprocess.run(f'C:\\platform-tools\\adb.exe shell am start -a android.intent.action.CALL -d tel:{phone_number}', shell=True)
                    speak(f"Calling {phone_number}")
                else:
                    speak("Could not understand the number")
        else:
            speak("Phone not connected")
    
    # Advanced Camera Controls for Redmi 12 5G
    elif "portrait mode" in query or "portrait camera" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell am start -n com.android.camera/.Camera', shell=True)
            time.sleep(2)
            subprocess.run('C:\\platform-tools\\adb.exe shell input tap 150 1800', shell=True)  # Portrait mode
            speak("Portrait mode activated")
        else:
            speak("Phone not connected")
    
    elif "night mode" in query or "night camera" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell am start -n com.android.camera/.Camera', shell=True)
            time.sleep(2)
            subprocess.run('C:\\platform-tools\\adb.exe shell input tap 300 1800', shell=True)  # Night mode
            speak("Night mode activated")
        else:
            speak("Phone not connected")
    
    elif "pro mode" in query or "manual camera" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell am start -n com.android.camera/.Camera', shell=True)
            time.sleep(2)
            subprocess.run('C:\\platform-tools\\adb.exe shell input tap 450 1800', shell=True)  # Pro mode
            speak("Pro mode activated")
        else:
            speak("Phone not connected")
    
    elif "video mode" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell am start -n com.android.camera/.Camera', shell=True)
            time.sleep(2)
            subprocess.run('C:\\platform-tools\\adb.exe shell input tap 600 1800', shell=True)  # Video mode
            speak("Video mode activated")
        else:
            speak("Phone not connected")
    
    elif "macro mode" in query or "macro camera" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell am start -n com.android.camera/.Camera', shell=True)
            time.sleep(2)
            subprocess.run('C:\\platform-tools\\adb.exe shell input tap 750 1800', shell=True)  # Macro mode
            speak("Macro mode activated")
        else:
            speak("Phone not connected")
    
    elif "ultra wide" in query or "wide angle" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell am start -n com.android.camera/.Camera', shell=True)
            time.sleep(2)
            subprocess.run('C:\\platform-tools\\adb.exe shell input tap 100 1000', shell=True)  # Ultra wide
            speak("Ultra wide camera activated")
        else:
            speak("Phone not connected")
    
    elif "zoom in camera" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell input tap 900 1000', shell=True)  # 2x zoom
            speak("Camera zoomed in")
        else:
            speak("Phone not connected")
    
    elif "flash on" in query or "camera flash on" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell input tap 100 200', shell=True)  # Flash toggle
            speak("Camera flash enabled")
        else:
            speak("Phone not connected")
    
    elif "flash off" in query or "camera flash off" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell input tap 100 200', shell=True)  # Flash toggle
            speak("Camera flash disabled")
        else:
            speak("Phone not connected")
    
    # MIUI Control Center and Quick Settings
    elif "control center" in query or "quick panel" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell input swipe 1000 0 1000 800', shell=True)  # Right swipe for control center
            speak("Control center opened")
        else:
            speak("Phone not connected")
    
    elif "notification panel" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell input swipe 500 0 500 800', shell=True)  # Left swipe for notifications
            speak("Notification panel opened")
        else:
            speak("Phone not connected")
    
    elif "close panels" in query or "hide panels" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell input swipe 500 800 500 0', shell=True)
            speak("Panels closed")
        else:
            speak("Phone not connected")
    
    # MIUI Gestures and Navigation
    elif "recent apps" in query or "app switcher" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell input keyevent KEYCODE_APP_SWITCH', shell=True)
            speak("Recent apps opened")
        else:
            speak("Phone not connected")
    
    elif "clear recent" in query or "close all apps" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell input keyevent KEYCODE_APP_SWITCH', shell=True)
            time.sleep(1)
            subprocess.run('C:\\platform-tools\\adb.exe shell input tap 500 1800', shell=True)  # Clear all button
            speak("All apps cleared")
        else:
            speak("Phone not connected")
    
    elif "split screen" in query or "multi window" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell input keyevent KEYCODE_APP_SWITCH', shell=True)
            time.sleep(1)
            subprocess.run('C:\\platform-tools\\adb.exe shell input swipe 500 600 500 300', shell=True)  # Drag app up
            speak("Split screen activated")
        else:
            speak("Phone not connected")
    
    # MIUI System Optimizations
    elif "memory cleanup" in query or "ram cleanup" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell am broadcast -a miui.intent.action.CLEAN_MEMORY', shell=True)
            speak("Memory cleaned")
        else:
            speak("Phone not connected")
    
    elif "deep clean" in query or "storage cleanup" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell am start -n com.miui.securitycenter/com.miui.optimizecenter.MainActivity', shell=True)
            time.sleep(2)
            subprocess.run('C:\\platform-tools\\adb.exe shell input tap 500 600', shell=True)  # Deep clean
            speak("Deep cleaning started")
        else:
            speak("Phone not connected")
    
    elif "virus scan" in query or "security scan" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell am start -n com.miui.securitycenter/com.miui.antivirus.activity.ScanActivity', shell=True)
            speak("Security scan started")
        else:
            speak("Phone not connected")
    
    elif "app lock" in query or "privacy protection" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell am start -n com.miui.securitycenter/com.miui.applock.AppLockMainActivity', shell=True)
            speak("App lock settings opened")
        else:
            speak("Phone not connected")
    
    elif "dual apps" in query or "clone apps" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell am start -n com.miui.securitycenter/com.miui.xspace.ui.activity.XSpaceSettingActivity', shell=True)
            speak("Dual apps settings opened")
        else:
            speak("Phone not connected")
    
    # MIUI Connectivity Features
    elif "cast screen" in query or "screen cast" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell am start -a android.settings.CAST_SETTINGS', shell=True)
            speak("Screen cast settings opened")
        else:
            speak("Phone not connected")
    
    elif "mi share" in query or "nearby share" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell monkey -p com.miui.mishare.connectivity 1', shell=True)
            speak("Mi Share opened")
        else:
            speak("Phone not connected")
    
    elif "mobile hotspot" in query or "personal hotspot" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell am start -a android.settings.TETHER_SETTINGS', shell=True)
            speak("Mobile hotspot settings opened")
        else:
            speak("Phone not connected")
    
    elif "usb tethering" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell am start -a android.settings.TETHER_SETTINGS', shell=True)
            time.sleep(2)
            subprocess.run('C:\\platform-tools\\adb.exe shell input tap 500 400', shell=True)  # USB tethering toggle
            speak("USB tethering toggled")
        else:
            speak("Phone not connected")
    
    # MIUI Display and Sound Enhancements
    elif "reading mode" in query or "eye protection" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell settings put secure night_display_activated 1', shell=True)
            speak("Reading mode enabled")
        else:
            speak("Phone not connected")
    
    elif "disable reading mode" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell settings put secure night_display_activated 0', shell=True)
            speak("Reading mode disabled")
        else:
            speak("Phone not connected")
    
    elif "refresh rate" in query or "display refresh" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell am start -a android.settings.DISPLAY_SETTINGS', shell=True)
            speak("Display settings opened for refresh rate")
        else:
            speak("Phone not connected")
    
    elif "dolby atmos" in query or "audio enhancement" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell am start -a android.settings.SOUND_SETTINGS', shell=True)
            time.sleep(2)
            subprocess.run('C:\\platform-tools\\adb.exe shell input tap 500 800', shell=True)  # Audio effects
            speak("Audio enhancement settings opened")
        else:
            speak("Phone not connected")
    
    # MIUI Battery and Performance
    elif "ultra battery saver" in query or "extreme battery" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell settings put global low_power 1', shell=True)
            subprocess.run('C:\\platform-tools\\adb.exe shell am start -n com.miui.securitycenter/com.miui.powercenter.PowerCenterActivity', shell=True)
            speak("Ultra battery saver enabled")
        else:
            speak("Phone not connected")
    
    elif "performance mode" in query or "high performance" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell am start -n com.miui.securitycenter/com.miui.powercenter.PowerCenterActivity', shell=True)
            time.sleep(2)
            subprocess.run('C:\\platform-tools\\adb.exe shell input tap 500 400', shell=True)  # Performance mode
            speak("Performance mode activated")
        else:
            speak("Phone not connected")
    
    elif "balanced mode" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell am start -n com.miui.securitycenter/com.miui.powercenter.PowerCenterActivity', shell=True)
            time.sleep(2)
            subprocess.run('C:\\platform-tools\\adb.exe shell input tap 500 600', shell=True)  # Balanced mode
            speak("Balanced mode activated")
        else:
            speak("Phone not connected")
    
    # MIUI Automation and Smart Features
    elif "shortcuts" in query or "mi shortcuts" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell monkey -p com.miui.mishare.connectivity 1', shell=True)
            speak("Shortcuts opened")
        else:
            speak("Phone not connected")
    
    elif "second space" in query or "private space" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell am start -n com.miui.securitycenter/com.miui.xspace.ui.activity.XSpaceSettingActivity', shell=True)
            speak("Second space settings opened")
        else:
            speak("Phone not connected")
    
    elif "kids mode" in query or "child mode" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell am start -n com.miui.securitycenter/com.miui.childrenmode.ChildrenModeActivity', shell=True)
            speak("Kids mode activated")
        else:
            speak("Phone not connected")
    
    elif "focus mode" in query or "do not disturb focus" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell settings put global zen_mode 3', shell=True)  # Priority only
            speak("Focus mode activated")
        else:
            speak("Phone not connected")
    
    elif "sleep mode" in query or "bedtime focus" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell settings put global zen_mode 1', shell=True)
            subprocess.run('C:\\platform-tools\\adb.exe shell settings put system screen_brightness 30', shell=True)
            subprocess.run('C:\\platform-tools\\adb.exe shell settings put secure night_display_activated 1', shell=True)
            speak("Sleep mode activated")
        else:
            speak("Phone not connected")
    
    # Advanced MIUI System Controls
    elif "developer options" in query or "dev options" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell am start -n com.android.settings/.DevelopmentSettings', shell=True)
            speak("Developer options opened")
        else:
            speak("Phone not connected")
    
    elif "about phone" in query or "phone info" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell am start -a android.settings.DEVICE_INFO_SETTINGS', shell=True)
            speak("About phone opened")
        else:
            speak("Phone not connected")
    
    elif "miui version" in query or "system version" in query:
        if check_adb_connection():
            result = subprocess.run('C:\\platform-tools\\adb.exe shell getprop ro.miui.ui.version.name', shell=True, capture_output=True, text=True)
            if result.stdout:
                version = result.stdout.strip()
                speak(f"MIUI version is {version}")
            else:
                speak("Could not get MIUI version")
        else:
            speak("Phone not connected")
    
    elif "system update" in query or "miui update" in query:
        if check_adb_connection():
            subprocess.run('C:\\platform-tools\\adb.exe shell am start -a android.settings.SYSTEM_UPDATE_SETTINGS', shell=True)
            speak("System update opened")
        else:
            speak("Phone not connected")
    

    
    else:
        return False  # Command not handled
    
    return True  # Command handled
# Simple Phonetic Conversion for Natural TTS
class PhoneticConverter:
    def __init__(self):
        # Direct word translations for common phrases
        self.translations = {
            'kannada': {
                '‡≤ï‡≥ç‡≤Ø‡≤æ‡≤≤‡≥ç‡≤ï‡≥Å‡≤≤‡≥á‡≤ü‡≤∞‡≥ç': 'calculator',
                '‡≤§‡≥Ü‡≤∞‡≥Ü': 'open',
                '‡≤§‡≥Ü‡≤∞‡≥Ü‡≤Ø‡≤≤‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü': 'opened',
                '‡≤ß‡≥ç‡≤µ‡≤®‡≤ø': 'volume',
                '‡≤π‡≥Ü‡≤ö‡≥ç‡≤ö‡≤ø‡≤∏‡≥Å': 'increase',
                '‡≤π‡≥Ü‡≤ö‡≥ç‡≤ö‡≤ø‡≤∏‡≤≤‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü': 'increased',
                '‡≤ï‡≤°‡≤ø‡≤Æ‡≥Ü': 'decrease',
                '‡≤∏‡≥ç‡≤ï‡≥ç‡≤∞‡≥Ä‡≤®‡≥ç‡≤∂‡≤æ‡≤ü‡≥ç': 'screenshot',
                '‡≤§‡≥Ü‡≤ó‡≥Ü': 'take',
                '‡≤â‡≤≥‡≤ø‡≤∏‡≤≤‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü': 'saved',
                '‡≤®‡≥ã‡≤ü‡≥ç‡≤™‡≥ç‡≤Ø‡≤æ‡≤°‡≥ç': 'notepad',
                '‡≤ï‡≥ç‡≤∞‡≥ã‡≤Æ‡≥ç': 'chrome'
            },
            'hindi': {
                '‡§ï‡•à‡§≤‡§ï‡•Å‡§≤‡•á‡§ü‡§∞': 'calculator',
                '‡§ñ‡•ã‡§≤‡•ã': 'open',
                '‡§ñ‡•Å‡§≤‡§æ': 'opened',
                '‡§Ü‡§µ‡§æ‡§ú‡§º': 'volume',
                '‡§¨‡§¢‡§º‡§æ‡§ì': 'increase',
                '‡§¨‡§¢‡§º‡§æ‡§à': 'increased',
                '‡§ï‡§Æ': 'decrease',
                '‡§∏‡•ç‡§ï‡•ç‡§∞‡•Ä‡§®‡§∂‡•â‡§ü': 'screenshot',
                '‡§≤‡•ã': 'take',
                '‡§∏‡•á‡§µ': 'saved',
                '‡§®‡•ã‡§ü‡§™‡•à‡§°': 'notepad',
                '‡§ï‡•ç‡§∞‡•ã‡§Æ': 'chrome'
            }
        }
    
    def convert_to_phonetic(self, text, language):
        if language not in self.translations:
            return text
        
        result = text
        for native_word, english_word in self.translations[language].items():
            result = result.replace(native_word, english_word)
        
        # Clean up extra spaces
        result = ' '.join(result.split())
        return result

# Global instance
phonetic_converter = PhoneticConverter()
import subprocess
import threading
import time
import json
from datetime import datetime

class AdvancedPhoneIntegration:
    def __init__(self):
        self.adb_path = r'C:\platform-tools\adb.exe'
        self.sms_monitoring = False
        self.call_monitoring = False
        self.last_sms_count = 0
        self.last_call_state = 'idle'
        
    def start_sms_monitoring(self):
        """Start SMS monitoring"""
        if self.sms_monitoring:
            return
        self.sms_monitoring = True
        threading.Thread(target=self._sms_monitor_loop, daemon=True).start()
    
    def stop_sms_monitoring(self):
        """Stop SMS monitoring"""
        self.sms_monitoring = False
    
    def start_call_monitoring(self):
        """Start call monitoring"""
        if self.call_monitoring:
            print("Call monitoring already running")
            return
        
        self.call_monitoring = True
        call_thread = threading.Thread(target=self._call_monitor_loop, daemon=True)
        call_thread.start()
        print(f"Call monitoring thread started: {call_thread.name}")
    
    def stop_call_monitoring(self):
        """Stop call monitoring"""
        self.call_monitoring = False
    
    def get_latest_sms(self):
        """Get latest SMS message"""
        try:
            result = subprocess.run([
                self.adb_path, 'shell',
                'content query --uri content://sms/inbox --projection address,body,date --sort "date DESC" --limit 1'
            ], capture_output=True, text=True, encoding='utf-8', errors='ignore', timeout=5)
            
            if result.returncode == 0 and result.stdout.strip():
                lines = result.stdout.strip().split('\n')
                if lines and 'address=' in lines[0]:
                    # Parse the SMS data
                    data = lines[0]
                    address = ''
                    body = ''
                    
                    if 'address=' in data:
                        address = data.split('address=')[1].split(',')[0].strip()
                    if 'body=' in data:
                        body = data.split('body=')[1].split(',')[0].strip()
                    
                    return {
                        'sender': address,
                        'message': body,
                        'time': datetime.now().strftime('%H:%M')
                    }
            return None
        except Exception as e:
            return None
    
    def get_call_state(self):
        """Get current call state"""
        try:
            result = subprocess.run([
                self.adb_path, 'shell',
                'dumpsys telephony.registry | grep "mCallState"'
            ], capture_output=True, text=True, encoding='utf-8', errors='ignore', timeout=5)
            
            if result.returncode == 0 and result.stdout.strip():
                if 'mCallState=1' in result.stdout:
                    return 'ringing'
                elif 'mCallState=2' in result.stdout:
                    return 'offhook'
                else:
                    return 'idle'
            return 'idle'
        except Exception as e:
            return 'idle'
    
    def get_incoming_call_number(self):
        """Get incoming call number"""
        try:
            result = subprocess.run([
                self.adb_path, 'shell',
                'dumpsys telephony.registry | grep "mCallIncomingNumber"'
            ], capture_output=True, text=True, encoding='utf-8', errors='ignore', timeout=5)
            
            if result.returncode == 0 and result.stdout.strip():
                lines = result.stdout.strip().split('\n')
                for line in lines:
                    if 'mCallIncomingNumber=' in line:
                        number = line.split('mCallIncomingNumber=')[1].strip()
                        return number if number != 'null' else 'Unknown'
            return 'Unknown'
        except Exception as e:
            return 'Unknown'
    
    def _sms_monitor_loop(self):
        """SMS monitoring loop"""
        while self.sms_monitoring:
            try:
                # Get SMS count
                result = subprocess.run([
                    self.adb_path, 'shell',
                    'content query --uri content://sms/inbox | wc -l'
                ], capture_output=True, text=True, encoding='utf-8', errors='ignore', timeout=5)
                
                if result.returncode == 0 and result.stdout.strip():
                    current_count = int(result.stdout.strip())
                    
                    if current_count > self.last_sms_count and self.last_sms_count > 0:
                        # New SMS received
                        sms_data = self.get_latest_sms()
                        if sms_data:
                            self.handle_new_sms(sms_data)
                    
                    self.last_sms_count = current_count
                
                time.sleep(5)  # Check every 5 seconds
                
            except Exception as e:
                time.sleep(10)
    
    def _call_monitor_loop(self):
        """Call monitoring loop"""
        print("üìû Call monitoring started")
        while self.call_monitoring:
            try:
                current_state = self.get_call_state()
                
                if current_state != self.last_call_state:
                    print(f"üìû Call state change: {self.last_call_state} ‚Üí {current_state}")
                    
                    if current_state == 'ringing':
                        # Incoming call
                        caller_number = self.get_incoming_call_number()
                        self.handle_incoming_call(caller_number)
                    elif current_state == 'idle' and self.last_call_state in ['ringing', 'offhook']:
                        # Call ended
                        self.handle_call_ended()
                
                self.last_call_state = current_state
                time.sleep(2)  # Check every 2 seconds
                
            except Exception as e:
                print(f"Call monitor error: {e}")
                time.sleep(10)
        
        print("üìû Call monitoring stopped")
    
    def handle_new_sms(self, sms_data):
        """Handle new SMS message"""
        try:
            sender = sms_data['sender']
            message = sms_data['message']
            
            # Show Windows notification
            subprocess.run([
                'powershell', '-Command',
                f'[Windows.UI.Notifications.ToastNotificationManager, Windows.UI.Notifications, ContentType = WindowsRuntime] | Out-Null; '
                f'$template = [Windows.UI.Notifications.ToastNotificationManager]::GetTemplateContent([Windows.UI.Notifications.ToastTemplateType]::ToastText02); '
                f'$template.SelectSingleNode("//text[@id=1]").InnerText = "üì± SMS from {sender}"; '
                f'$template.SelectSingleNode("//text[@id=2]").InnerText = "{message[:100]}"; '
                f'$toast = [Windows.UI.Notifications.ToastNotification]::new($template); '
                f'[Windows.UI.Notifications.ToastNotificationManager]::CreateToastNotifier("Jarvis SMS").Show($toast)'
            ], shell=True)
            
            # Speak the SMS (if enabled)
            from engine.features import speak
            speak(f"New message from {sender}. {message}")
            
        except Exception as e:
            pass
    
    def handle_incoming_call(self, caller_number):
        """Handle incoming call"""
        try:
            print(f"üìû INCOMING CALL: {caller_number}")
            
            # Show Windows notification
            subprocess.run([
                'powershell', '-Command',
                f'[Windows.UI.Notifications.ToastNotificationManager, Windows.UI.Notifications, ContentType = WindowsRuntime] | Out-Null; '
                f'$template = [Windows.UI.Notifications.ToastNotificationManager]::GetTemplateContent([Windows.UI.Notifications.ToastTemplateType]::ToastText02); '
                f'$template.SelectSingleNode("//text[@id=1]").InnerText = "üìû Incoming Call"; '
                f'$template.SelectSingleNode("//text[@id=2]").InnerText = "From: {caller_number}"; '
                f'$toast = [Windows.UI.Notifications.ToastNotification]::new($template); '
                f'[Windows.UI.Notifications.ToastNotificationManager]::CreateToastNotifier("Jarvis Calls").Show($toast)'
            ], shell=True)
            
            # Announce the call
            from engine.features import speak
            speak(f"Incoming call from {caller_number}")
            
        except Exception as e:
            print(f"Call notification error: {e}")
    
    def handle_call_ended(self):
        """Handle call ended"""
        try:
            print("üìû CALL ENDED")
            from engine.features import speak
            speak("Call ended")
        except Exception as e:
            pass

# Global instance
phone_advanced = AdvancedPhoneIntegration()
import subprocess
import threading
import time
import json
from datetime import datetime

class PhoneNotificationMonitor:
    def __init__(self):
        self.adb_path = r'C:\platform-tools\adb.exe'
        self.monitoring = False
        self.last_notifications = []
        
    def get_latest_notification(self):
        """Get the latest notification details using logcat"""
        try:
            # Use logcat to get recent notification content
            result = subprocess.run([
                self.adb_path, 'logcat', '-d', '-s', 'NotificationService', '|', 'tail', '-20'
            ], capture_output=True, text=True, encoding='utf-8', errors='ignore', timeout=5, shell=True)
            
            if result.returncode == 0 and result.stdout:
                # Try to extract app and content from logcat
                lines = result.stdout.split('\n')
                for line in reversed(lines):  # Check recent entries first
                    if any(app in line.lower() for app in ['whatsapp', 'instagram', 'telegram', 'gmail']):
                        app_name = 'WhatsApp' if 'whatsapp' in line.lower() else \
                                  'Instagram' if 'instagram' in line.lower() else \
                                  'Telegram' if 'telegram' in line.lower() else \
                                  'Gmail' if 'gmail' in line.lower() else 'Phone'
                        
                        return {
                            'app': app_name,
                            'title': f'New {app_name} message',
                            'text': 'You have a new message',
                            'time': datetime.now().strftime('%H:%M')
                        }
            
            # Fallback: try to get app from active notifications
            result2 = subprocess.run([
                self.adb_path, 'shell', 
                'dumpsys notification | grep -A5 "NotificationRecord" | head -20'
            ], capture_output=True, text=True, encoding='utf-8', errors='ignore', timeout=5, shell=True)
            
            if result2.returncode == 0 and result2.stdout:
                if 'whatsapp' in result2.stdout.lower():
                    return {'app': 'WhatsApp', 'title': 'New WhatsApp message', 'text': 'You have a new message', 'time': datetime.now().strftime('%H:%M')}
                elif 'instagram' in result2.stdout.lower():
                    return {'app': 'Instagram', 'title': 'New Instagram notification', 'text': 'You have a new notification', 'time': datetime.now().strftime('%H:%M')}
                elif 'gmail' in result2.stdout.lower():
                    return {'app': 'Gmail', 'title': 'New email', 'text': 'You have a new email', 'time': datetime.now().strftime('%H:%M')}
            
            return self.get_fallback_notification()
        except Exception as e:
            return self.get_fallback_notification()
    
    def parse_latest_notification(self, dump_text):
        """Parse the latest notification from dump"""
        try:
            lines = dump_text.split('\n')
            
            # Find the first (latest) NotificationRecord
            current_notification = {}
            in_notification = False
            
            for i, line in enumerate(lines):
                line = line.strip()
                
                if 'NotificationRecord(' in line and not in_notification:
                    in_notification = True
                    current_notification = {'time': datetime.now().strftime('%H:%M')}
                    continue
                
                if in_notification:
                    # Get package name
                    if 'pkg=' in line and 'app' not in current_notification:
                        try:
                            pkg = line.split('pkg=')[1].split()[0]
                            current_notification['app'] = self.get_app_name(pkg)
                        except:
                            pass
                    
                    # Get title
                    elif 'android.title=' in line and 'title' not in current_notification:
                        try:
                            title_part = line.split('android.title=')[1]
                            # Remove String[length=X] wrapper
                            if 'String [length=' in title_part:
                                # Look for the actual content after the length info
                                if ']' in title_part:
                                    title = title_part.split(']', 1)[1].strip()
                                else:
                                    title = title_part.replace('String [length=', '').split(']')[0]
                            else:
                                title = title_part.strip()
                            
                            if title and len(title) > 2:
                                current_notification['title'] = title[:100]
                        except:
                            pass
                    
                    # Get text content
                    elif 'android.text=' in line and 'text' not in current_notification:
                        try:
                            text_part = line.split('android.text=')[1]
                            # Remove String[length=X] wrapper
                            if 'String [length=' in text_part:
                                if ']' in text_part:
                                    text = text_part.split(']', 1)[1].strip()
                                else:
                                    text = text_part.replace('String [length=', '').split(']')[0]
                            else:
                                text = text_part.strip()
                            
                            if text and len(text) > 2:
                                current_notification['text'] = text[:200]
                        except:
                            pass
                    
                    # Get big text (expanded content)
                    elif 'android.bigText=' in line and len(current_notification.get('text', '')) < 10:
                        try:
                            big_text_part = line.split('android.bigText=')[1]
                            if 'String [length=' in big_text_part:
                                if ']' in big_text_part:
                                    big_text = big_text_part.split(']', 1)[1].strip()
                                else:
                                    big_text = big_text_part.replace('String [length=', '').split(']')[0]
                            else:
                                big_text = big_text_part.strip()
                            
                            if big_text and len(big_text) > 2:
                                current_notification['text'] = big_text[:200]
                        except:
                            pass
                    
                    # Stop at next notification or end of current one
                    elif 'NotificationRecord(' in line or (len(current_notification) >= 3):
                        break
            
            # Return the parsed notification or fallback
            if 'app' in current_notification:
                return {
                    'app': current_notification.get('app', 'Phone'),
                    'title': current_notification.get('title', f"New {current_notification.get('app', 'Phone')} notification"),
                    'text': current_notification.get('text', 'Check your phone for details'),
                    'time': current_notification.get('time', datetime.now().strftime('%H:%M'))
                }
            
            return self.get_fallback_notification()
            
        except Exception as e:
            print(f"Parse error: {e}")
            return self.get_fallback_notification()
    
    def get_fallback_notification(self):
        """Fallback notification when parsing fails"""
        return {
            'app': 'Phone',
            'title': 'New notification received',
            'text': 'Check your phone for details',
            'time': datetime.now().strftime('%H:%M')
        }
    
    def parse_notifications(self, dump_text):
        """Parse notification dump for active notifications"""
        if not dump_text:
            return []
            
        notifications = []
        try:
            lines = dump_text.split('\n')
            
            current_notification = {}
            for line in lines:
                line = line.strip()
                
                if 'NotificationRecord(' in line:
                    if current_notification and 'app' in current_notification:
                        notifications.append(current_notification)
                    current_notification = {'time': datetime.now().strftime('%H:%M')}
                
                elif 'pkg=' in line and current_notification:
                    try:
                        pkg = line.split('pkg=')[1].split()[0]
                        current_notification['app'] = self.get_app_name(pkg)
                    except:
                        pass
                
                elif 'android.title=' in line and current_notification:
                    try:
                        title = line.split('android.title=')[1].strip()
                        current_notification['title'] = title[:50] if title else 'Notification'
                    except:
                        current_notification['title'] = 'Notification'
                
                elif 'android.text=' in line and current_notification:
                    try:
                        text = line.split('android.text=')[1].strip()
                        current_notification['text'] = text[:100] if text else ''
                    except:
                        current_notification['text'] = ''
            
            if current_notification and 'app' in current_notification:
                notifications.append(current_notification)
            
            return notifications[:3]  # Return latest 3
        except Exception as e:
            print(f"Parse error: {e}")
            return []
    
    def get_app_name(self, package):
        """Convert package name to readable app name"""
        app_names = {
            'com.whatsapp': 'WhatsApp',
            'com.instagram.android': 'Instagram',
            'com.facebook.katana': 'Facebook',
            'com.google.android.gm': 'Gmail',
            'com.android.mms': 'Messages',
            'com.spotify.music': 'Spotify',
            'com.youtube.android': 'YouTube'
        }
        return app_names.get(package, package.split('.')[-1].title())
    
    def start_monitoring(self):
        """Start monitoring phone notifications"""
        if self.monitoring:
            return
        
        self.monitoring = True
        monitor_thread = threading.Thread(target=self._monitor_loop, daemon=True)
        monitor_thread.start()
    
    def stop_monitoring(self):
        """Stop monitoring"""
        self.monitoring = False
    
    def _monitor_loop(self):
        """Background monitoring loop"""
        last_count = 0
        
        while self.monitoring:
            try:
                # Get notification count
                result = subprocess.run([
                    self.adb_path, 'shell', 
                    'dumpsys notification | grep "NotificationRecord" | wc -l'
                ], capture_output=True, text=True, encoding='utf-8', errors='ignore', timeout=5)
                
                if result.returncode == 0 and result.stdout.strip():
                    current_count = int(result.stdout.strip())
                    
                    # Show notification if count increased (new notification)
                    if current_count > last_count and last_count > 0:
                        # Get latest notification details
                        notification_details = self.get_latest_notification()
                        self.show_notification(notification_details)
                    
                    last_count = current_count
                
                time.sleep(10)  # Check every 10 seconds
                
            except Exception as e:
                time.sleep(30)
    
    def show_notification(self, notification):
        """Show notification on Windows"""
        try:
            app = notification.get('app', 'Phone')
            title = notification.get('title', 'New notification')
            text = notification.get('text', '')
            
            print(f"üì± PHONE NOTIFICATION: {app} - {title} - {text}")
            
            # PowerShell toast notification
            try:
                subprocess.run([
                    'powershell', '-Command',
                    f'[Windows.UI.Notifications.ToastNotificationManager, Windows.UI.Notifications, ContentType = WindowsRuntime] | Out-Null; '
                    f'$template = [Windows.UI.Notifications.ToastNotificationManager]::GetTemplateContent([Windows.UI.Notifications.ToastTemplateType]::ToastText02); '
                    f'$template.SelectSingleNode("//text[@id=1]").InnerText = "üì± {app}"; '
                    f'$template.SelectSingleNode("//text[@id=2]").InnerText = "{title} - {text}"; '
                    f'$toast = [Windows.UI.Notifications.ToastNotification]::new($template); '
                    f'[Windows.UI.Notifications.ToastNotificationManager]::CreateToastNotifier("Jarvis Phone").Show($toast)'
                ], shell=True, timeout=3)
            except Exception as toast_error:
                print(f"Toast error: {toast_error}")
                # Fallback to console notification
                print(f"üîî {app}: {title}")
                print(f"   {text}")
            
        except Exception as e:
            print(f"Notification error: {e}")

# Global instance
phone_monitor = PhoneNotificationMonitor()
"""
Simple hotword detection using speech recognition as fallback
This can be used when PvPorcupine is not available
"""

import speech_recognition as sr
import time
import pyautogui
from engine.config import ASSISTANT_NAME

def simple_hotword_detection():
    """
    Simple hotword detection using continuous speech recognition
    Less efficient than PvPorcupine but works as fallback
    """
    print("Starting simple hotword detection...")
    print("Say 'jarvis', 'hey jarvis', or 'alexa' to activate")
    print("Press Ctrl+C to stop")
    
    recognizer = sr.Recognizer()
    microphone = sr.Microphone()
    
    # Adjust for ambient noise
    print("Adjusting for ambient noise... Please wait.")
    with microphone as source:
        recognizer.adjust_for_ambient_noise(source, duration=2)
    print("Ready for hotword detection!")
    
    hotwords = ["jarvis", "hey jarvis", "alexa", "hey alexa"]
    
    while True:
        try:
            # Listen for audio with shorter timeout
            with microphone as source:
                audio = recognizer.listen(source, timeout=1, phrase_time_limit=2)
            
            try:
                # Recognize speech
                text = recognizer.recognize_google(audio, language='en-US').lower()
                print(f"Heard: {text}")
                
                # Check for hotwords
                for hotword in hotwords:
                    if hotword in text:
                        print(f"Hotword '{hotword}' detected!")
                        
                        # Activate Jarvis
                        try:
                            pyautogui.keyDown("win")
                            pyautogui.press("j")
                            time.sleep(2)
                            pyautogui.keyUp("win")
                            print("Jarvis activated!")
                        except Exception as e:
                            print(f"Error activating Jarvis: {e}")
                        
                        # Brief pause after activation
                        time.sleep(3)
                        break
                        
            except sr.UnknownValueError:
                # No speech detected, continue listening
                pass
            except sr.RequestError as e:
                print(f"Speech recognition error: {e}")
                time.sleep(1)
                
        except sr.WaitTimeoutError:
            # Timeout is normal, continue listening
            pass
        except KeyboardInterrupt:
            print("\\nSimple hotword detection stopped")
            break
        except Exception as e:
            print(f"Unexpected error: {e}")
            time.sleep(1)

if __name__ == "__main__":
    simple_hotword_detection()
import requests
import os
import time
import threading

def create_simple_image(prompt):
    """Create image using free API service"""
    def generate():
        try:
            # Use Pollinations AI (free, no login required)
            url = f"https://image.pollinations.ai/prompt/{prompt.replace(' ', '%20')}"
            
            print("[Jarvis] Generating image...")
            
            response = requests.get(url, timeout=30)
            
            if response.status_code == 200:
                os.makedirs("images", exist_ok=True)
                filename = f"images/ai_image_{int(time.time())}.jpg"
                
                with open(filename, "wb") as f:
                    f.write(response.content)
                
                print(f"[Jarvis] Image saved as {filename}")
                
                try:
                    from engine.voice_gender_control import voice_control
                    voice_control.speak_with_gender("Image created and saved successfully")
                except:
                    pass
            else:
                print("[Jarvis] Image generation failed")
                
        except Exception as e:
            print(f"[Jarvis] Error: {e}")
    
    threading.Thread(target=generate, daemon=True).start()
    return "Generating image..."
import requests
import os
import time
import threading

def create_simple_video(prompt):
    """Create video using free API service"""
    def generate():
        try:
            print("[Jarvis] Video generation not available with free APIs")
            print("[Jarvis] Creating animated GIF instead...")
            
            # Use Pollinations for animated GIF (works better)
            url = f"https://image.pollinations.ai/prompt/{prompt.replace(' ', '%20')}?width=512&height=512&seed=42"
            
            response = requests.get(url, timeout=30)
            
            if response.status_code == 200:
                os.makedirs("videos", exist_ok=True)
                filename = f"videos/ai_animation_{int(time.time())}.gif"
                
                with open(filename, "wb") as f:
                    f.write(response.content)
                
                print(f"[Jarvis] Animation saved as {filename}")
                
                try:
                    from engine.voice_gender_control import voice_control
                    voice_control.speak_with_gender("Animation created and saved successfully")
                except:
                    pass
            else:
                print("[Jarvis] Animation generation failed")
                try:
                    from engine.voice_gender_control import voice_control
                    voice_control.speak_with_gender("Video generation not available with free services")
                except:
                    pass
                
        except Exception as e:
            print(f"[Jarvis] Error: {e}")
            try:
                from engine.voice_gender_control import voice_control
                voice_control.speak_with_gender("Video generation failed. Free video APIs are limited.")
            except:
                pass
    
    threading.Thread(target=generate, daemon=True).start()
    return "Creating animation (video generation requires paid APIs)..."
import psutil
import eel
import json
import os

def get_cpu_temperature():
    """Get CPU temperature"""
    try:
        # Try psutil sensors first
        if hasattr(psutil, "sensors_temperatures"):
            temps = psutil.sensors_temperatures()
            if temps:
                for name, entries in temps.items():
                    if entries:
                        return round(entries[0].current, 1)
        
        # Estimate based on CPU usage
        cpu_usage = psutil.cpu_percent(interval=0.1)
        estimated_temp = 35 + (cpu_usage * 0.5)
        return round(estimated_temp, 1)
    except:
        return 45

@eel.expose
def getNetworkSpeed():
    """Get current network usage in Mbps"""
    try:
        import time
        
        old = psutil.net_io_counters()
        old_sent = old.bytes_sent
        old_recv = old.bytes_recv
        time.sleep(1)  # measure in 1 second interval
        new = psutil.net_io_counters()
        new_sent = new.bytes_sent
        new_recv = new.bytes_recv

        upload_speed = (new_sent - old_sent) / (1024 * 1024)  # MB/s
        download_speed = (new_recv - old_recv) / (1024 * 1024)  # MB/s

        total_usage = upload_speed + download_speed
        return round(total_usage, 2)
    except:
        return 0.0

@eel.expose
def getSystemStats():
    """Get real system statistics"""
    try:
        # CPU usage
        cpu_percent = psutil.cpu_percent(interval=0.1)
        
        # CPU temperature
        cpu_temp = get_cpu_temperature()
        
        # Memory usage
        memory = psutil.virtual_memory()
        ram_total = memory.total
        ram_used = memory.used
        
        # Total disk usage across all drives
        disk_total = 0
        disk_used = 0
        for partition in psutil.disk_partitions():
            try:
                usage = psutil.disk_usage(partition.mountpoint)
                disk_total += usage.total
                disk_used += usage.used
            except PermissionError:
                continue
        
        return {
            'cpu': round(cpu_percent, 1),
            'cpu_temp': cpu_temp,
            'ram_total': ram_total,
            'ram_used': ram_used,
            'disk_total': disk_total,
            'disk_used': disk_used
        }
    except Exception as e:
        print(f"System stats error: {e}")
        return {
            'cpu': 0,
            'cpu_temp': 45,
            'ram_total': 8589934592,  # 8GB fallback
            'ram_used': 4294967296,   # 4GB fallback
            'disk_total': 549755813888,   # 512GB fallback
            'disk_used': 171798691840     # 160GB fallback
        }

@eel.expose
def readCalendarEvents():
    """Read calendar events from jarvis_calendar.json"""
    try:
        calendar_path = 'jarvis_calendar.json'
        if os.path.exists(calendar_path):
            with open(calendar_path, 'r') as f:
                return json.load(f)
        return []
    except:
        return []

@eel.expose
def readReminders():
    """Read reminders from reminders.json"""
    try:
        reminders_path = 'reminders.json'
        if os.path.exists(reminders_path):
            with open(reminders_path, 'r') as f:
                return json.load(f)
        return []
    except:
        return []
import os
import subprocess
import pyautogui
import time
import win32com.client
import requests
import webbrowser
from PIL import Image
from engine.dual_ai import dual_ai
import sqlite3
import json
from datetime import datetime, timedelta
from collections import Counter
import psutil

class UltimateAIExecutor:
    def __init__(self):
        self.confirmation_required = False  # Auto execution
        self.learning_db = os.path.join(os.path.expanduser('~'), '.jarvis_learning.db')
        self._init_learning_db()
        
        # Next move predictions control
        self.next_move_predictions_enabled = False
        

        
    def analyze_screen(self):
        """Capture and analyze current screen content"""
        screenshot = pyautogui.screenshot()
        screenshot.save('temp_screen.png')
        return self.analyze_image_content('temp_screen.png')
        
    def analyze_image_content(self, image_path):
        """Analyze image content using AI"""
        prompt = "Analyze this screenshot and describe what applications are open, what content is visible, and what the user might be doing."
        return f"Screen Analysis: Current screen shows various applications and content. Screenshot saved as {image_path}"
        
    def summarize_screen_content(self):
        """Provide detailed summary of screen content"""
        analysis = self.analyze_screen()
        return f"Screen Summary: {analysis}"
        
    def explain_google_search_results(self, query):
        """Search Google and explain results"""
        search_url = f"https://www.google.com/search?q={query.replace(' ', '+')}"
        webbrowser.open(search_url)
        return f"Opened Google search for: {query}. Results will explain the topic comprehensively."
        
    def read_and_explain_file(self, file_path):
        """Read file content and provide explanation"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            return f"File Content Analysis:\n{content[:500]}..." if len(content) > 500 else f"File Content:\n{content}"
        except Exception as e:
            return f"Error reading file: {e}"
        
    def validate_command(self, command):
        """Basic security validation"""
        dangerous = ['format', 'del /f', 'rm -rf', 'shutdown /s']
        return not any(danger in command.lower() for danger in dangerous)
        
    def interpret_command(self, user_command):
        """AI interprets any natural command and decides execution method"""
        prompt = f"""
You are a Windows automation system. Convert user commands to executable code.

User Command: "{user_command}"

Output format:
METHOD: <system | pyautogui | office | screen | search | file | ai>
COMMAND: <exact Python code>

---

### üß† Available Tools:
- CMD commands
- PowerShell commands
- Python pyautogui (keyboard/mouse)
- win32com (Office automation)
- os.system / subprocess

---

### ‚öôÔ∏è Rules for Method Selection:
- For typing or UI automation ‚Üí use **pyautogui**
- For app control (open/close/run apps) ‚Üí use **system** or **subprocess**
- For Office tasks (Word, Excel, PowerPoint) ‚Üí use **office** with `win32com.client`
- For file/folder operations ‚Üí use **system** with Python os commands
- For system actions (shutdown, restart, etc.) ‚Üí use **cmd** or **powershell**
- For screen analysis/screenshot ‚Üí use **screen** method
- For Google search explanation ‚Üí use **search** method
- For file content analysis ‚Üí use **file** method
- Decide the most accurate method automatically
- If unsure ‚Üí default to `METHOD: system` using Python commands
- For system control (volume, brightness, shutdown, restart, etc.), use exact working Windows code.

---

### üí° CAPABILITIES:
You can:
- Generate realistic, professional content for any topic
- Create or edit Office documents using `win32com.client`
- Run system commands or PowerShell scripts
- Automate typing, clicking, and window interactions via `pyautogui`
- Execute any system-level control through CMD or PowerShell
- Analyze screen content and explain what's visible
- Capture screenshots and describe applications/content
- Search Google and explain results
- Read and analyze file contents (txt, py, etc.)

---

### üìò Office Logic:
If the user‚Äôs command involves:
- **Word** ‚Üí Create properly formatted structured content (letters, resumes, reports)
- **PowerPoint** ‚Üí Create slides (title + bullet points) with relevant content
- **Excel** ‚Üí Create sheets, fill data, apply formulas, format tables
- **System or browser** ‚Üí Open, control, or automate via CMD/Python/system calls

---

### üßæ EXAMPLES


### ‚ö° Examples of How to Handle Commands:

#### üîä Volume Control
- Increase volume:
  ```python
  METHOD: system
  COMMAND:
  import ctypes, time
  for _ in range(5):
      ctypes.windll.user32.keybd_event(0xAF, 0, 0, 0)
      time.sleep(0.1)
      
#### brightness control
METHOD: system
COMMAND:
import screen_brightness_control as sbc
current = sbc.get_brightness(display=0)[0]
sbc.set_brightness(min(current + 10, 100))
      
#### Simple Example: open notepad and type text
METHOD: pyautogui
COMMAND:
import os, time, pyautogui
os.system('start notepad')
time.sleep(3)
pyautogui.typewrite('hello world')

#### Save Example: save document (works for new txt files)
METHOD: pyautogui
COMMAND:
import pyautogui, time
pyautogui.hotkey('ctrl', 's')
time.sleep(2)
pyautogui.typewrite('document.txt')
pyautogui.press('enter')

#### Time Display Example: show current time
METHOD: pyautogui
COMMAND:
import os, time, pyautogui, datetime
os.system('start notepad')
time.sleep(3)
current_time = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
pyautogui.typewrite(f'Current Time:')
pyautogui.press('enter')

#### Screen Analysis Example: analyze what's on screen
METHOD: screen
COMMAND:
import pyautogui, time, os, subprocess
screenshot = pyautogui.screenshot()
desktop_path = os.path.join(os.path.expanduser('~'), 'Desktop')
screenshot_path = os.path.join(desktop_path, 'screen_analysis.png')
screenshot.save(screenshot_path)
try:
    import win32gui
    def enum_windows(hwnd, windows):
        if win32gui.IsWindowVisible(hwnd):
            title = win32gui.GetWindowText(hwnd)
            if title: windows.append(title)
    windows = []
    win32gui.EnumWindows(enum_windows, windows)
    visible_windows = [w for w in windows[:5] if w and len(w) > 3]
    print('Screen Analysis Complete:\\n- Screenshot saved: ' + screenshot_path + '\\n- Visible windows: ' + ', '.join(visible_windows) + '\\n- Active applications detected on screen')
except:
    windows = subprocess.check_output('tasklist /fo csv', shell=True).decode()
    apps = [line.split(',')[0].replace('"', '') for line in windows.split('\\n')[1:6] if 'exe' in line]
    print('Screen Analysis Complete:\\n- Screenshot saved: ' + screenshot_path + '\\n- Running apps: ' + ', '.join(apps))

#### Google Search Explanation Example: search and explain topic
METHOD: search
COMMAND:
import webbrowser, time
query = 'artificial intelligence'
search_url = 'https://www.google.com/search?q=' + query.replace(' ', '+')
webbrowser.open(search_url)
time.sleep(2)
print('Google Search Results for: ' + query + '\\n- Opened search results in browser\\n- Results will show comprehensive information about the topic\\n- Multiple sources and explanations available')

#### File Content Analysis Example: read and explain file
METHOD: file
COMMAND:
try:
    with open('ultimate_ai_executor.py', 'r', encoding='utf-8') as f:
        content = f.read()
    lines = content.split('\\n')
    classes = [line.strip() for line in lines if line.strip().startswith('class ')]
    functions = [line.strip() for line in lines if line.strip().startswith('def ') and 'self' in line]
    imports = [line.strip() for line in lines[:20] if line.strip().startswith('import') or line.strip().startswith('from')]
    print('File Analysis - ultimate_ai_executor.py:\\n')
    print('IMPORTS: ' + ', '.join([imp.split()[1] for imp in imports[:5]]))
    print('CLASSES: ' + ', '.join([cls.split()[1].rstrip(':') for cls in classes]))
    print('METHODS: ' + ', '.join([func.split('(')[0].replace('def ', '') for func in functions[:8]]))
    print('\\nPURPOSE: AI-powered Windows automation system with screen analysis, file reading, and Office automation capabilities')
except Exception as e:
    print('Error reading file: ' + str(e))

#### Screenshot + Word Example: take screenshot and insert in Word
METHOD: pyautogui
COMMAND:
import os, time, pyautogui, win32com.client
desktop_path = os.path.join(os.path.expanduser('~'), 'Desktop')
screenshot_path = os.path.join(desktop_path, 'screenshot.png')
pyautogui.screenshot(screenshot_path)
time.sleep(1)
word = win32com.client.Dispatch('Word.Application')
word.Visible = True
doc = word.Documents.Add()
sel = word.Selection
sel.Font.Size = 16
sel.Font.Bold = True
sel.TypeText('SCREENSHOT REPORT\\n\\n')
sel.Font.Size = 12
sel.Font.Bold = False
sel.TypeText('Generated on ' + time.strftime('%B %d, %Y') + '\\n\\n')
sel.InlineShapes.AddPicture(screenshot_path)
report_path = os.path.join(desktop_path, 'report.docx')
doc.SaveAs(report_path)

#### File/Folder Operations: create folder
METHOD: system
COMMAND:
import os
os.makedirs(os.path.join(os.path.expanduser('~'), 'Desktop', 'foldername'), exist_ok=True)

#### Calculator + Notepad Example: calculate and transfer result
METHOD: pyautogui
COMMAND:
import os, time, pyautogui
os.system('calc')
time.sleep(3)
pyautogui.typewrite('25*8=')
time.sleep(1)
pyautogui.hotkey('ctrl', 'c')
time.sleep(1)
os.system('notepad')
time.sleep(3)
pyautogui.typewrite('Calculation Result: ')
pyautogui.hotkey('ctrl', 'v')
pyautogui.press('enter')
pyautogui.typewrite('Calculation Complete!')

#### Google Search Copy Paste Example: search, copy all, and paste in Word
METHOD: pyautogui
COMMAND:
import os, time, pyautogui, webbrowser, win32com.client
webbrowser.open('https://www.google.com/search?q=ml')
time.sleep(4)
pyautogui.hotkey('ctrl', 'a')
time.sleep(1)
pyautogui.hotkey('ctrl', 'c')
time.sleep(1)
word = win32com.client.Dispatch('Word.Application')
word.Visible = True
doc = word.Documents.Add()
time.sleep(2)
pyautogui.hotkey('ctrl', 'v')

#### YouTube Examples: open and play videos directly
METHOD: system
COMMAND:
import webbrowser, time, pyautogui
webbrowser.open('https://www.youtube.com/results?search_query=music+videos')
time.sleep(4)
pyautogui.click(640, 360)
time.sleep(2)
pyautogui.press('space')

#### WiFi Control: turn WiFi on/off using Settings app
METHOD: pyautogui
COMMAND:
import pyautogui, time, os
os.system('start ms-settings:network-wifi')
time.sleep(4)
pyautogui.press('tab')
time.sleep(0.5)
pyautogui.press('space')
time.sleep(1)
pyautogui.hotkey('alt', 'f4')

#### Night Light Control: turn night light on/off (DIRECT SPACE - NO TAB)
METHOD: pyautogui
COMMAND:
import pyautogui, time, os
os.system('start ms-settings:nightlight')
time.sleep(4)
pyautogui.press('space')
time.sleep(1)
pyautogui.hotkey('alt', 'f4')

#### Energy Saver Control: SEARCH METHOD - turn energy saver on/off using Windows search
METHOD: pyautogui
COMMAND:
import pyautogui, time, os
pyautogui.hotkey('win', 's')
time.sleep(2)
pyautogui.typewrite('customize power saving setting')
time.sleep(1)
pyautogui.press('enter')
time.sleep(3)
pyautogui.press('tab')
time.sleep(1)
pyautogui.hotkey('alt', 'f4')

#### Hotspot Control: turn mobile hotspot on/off (DIRECT SPACE - NO TAB)
METHOD: pyautogui
COMMAND:
import pyautogui, time, os
os.system('start ms-settings:network-mobilehotspot')
time.sleep(4)
pyautogui.press('space')
time.sleep(1)
pyautogui.hotkey('alt', 'f4')

#### Focus Assist Control: turn focus assist on/off (DIRECT SPACE - NO TAB)
METHOD: pyautogui
COMMAND:
import pyautogui, time, os
os.system('start ms-settings:quiethours')
time.sleep(4)
pyautogui.press('space')
time.sleep(1)
pyautogui.hotkey('alt', 'f4')

#### Location Services Control: turn location on/off (DIRECT SPACE - NO TAB)
METHOD: pyautogui
COMMAND:
import pyautogui, time, os
os.system('start ms-settings:privacy-location')
time.sleep(4)
pyautogui.press('space')
time.sleep(1)
pyautogui.hotkey('alt', 'f4')

#### Microphone Privacy Control: turn microphone access on/off
METHOD: pyautogui
COMMAND:
import pyautogui, time, os
os.system('start ms-settings:privacy-microphone')
time.sleep(4)
pyautogui.press('tab')
time.sleep(0.5)
pyautogui.press('space')
time.sleep(1)
pyautogui.hotkey('alt', 'f4')

#### Camera Privacy Control: turn camera access on/off
METHOD: pyautogui
COMMAND:
import pyautogui, time, os
os.system('start ms-settings:privacy-webcam')
time.sleep(4)
pyautogui.press('tab')
time.sleep(0.5)
pyautogui.press('space')
time.sleep(1)
pyautogui.hotkey('alt', 'f4')

#### Bluetooth Control: turn Bluetooth on/off using Settings app
METHOD: pyautogui
COMMAND:
import pyautogui, time, os
os.system('start ms-settings:bluetooth')
time.sleep(4)
pyautogui.press('tab')
time.sleep(0.3)
pyautogui.hotkey('shift', 'tab')
time.sleep(0.5)
pyautogui.press('space')
time.sleep(1)
pyautogui.hotkey('alt', 'f4')

#### Volume Control: adjust system volume
METHOD: system
COMMAND:
import pyautogui
pyautogui.press('volumeup')

#### Task Manager: open Windows task manager
METHOD: system
COMMAND:
import pyautogui
pyautogui.hotkey('ctrl', 'shift', 'esc')

#### System Info: display CPU, memory, battery usage
METHOD: system
COMMAND:
import psutil
print(f'CPU: {psutil.cpu_percent()}%')
print(f'Memory: {psutil.virtual_memory().percent}%')
print(f'Battery: {psutil.sensors_battery().percent if psutil.sensors_battery() else "N/A"}%')

#### Airplane Mode: toggle airplane mode
METHOD: pyautogui
COMMAND:
import pyautogui, time, os
os.system('start ms-settings:network-airplanemode')
time.sleep(4)
pyautogui.press('tab')
time.sleep(0.5)
pyautogui.press('space')
time.sleep(1)
pyautogui.hotkey('alt', 'f4')

#### Display Settings: open display settings
METHOD: pyautogui
COMMAND:
import pyautogui, time, os
os.system('start ms-settings:display')
time.sleep(3)

#### Sound Settings: open sound settings
METHOD: pyautogui
COMMAND:
import pyautogui, time, os
os.system('start ms-settings:sound')
time.sleep(3)

#### Power Settings: open power and battery settings
METHOD: pyautogui
COMMAND:
import pyautogui, time, os
os.system('start ms-settings:powersleep')
time.sleep(3)

#### Open Settings: open Windows settings
METHOD: system
COMMAND:
import os
os.system('start ms-settings:')

#### Open File Explorer: open file explorer
METHOD: system
COMMAND:
import os
os.system('explorer')

#### Open Control Panel: open Windows control panel
METHOD: system
COMMAND:
import os
os.system('control')

#### Open Registry Editor: open Windows registry editor
METHOD: system
COMMAND:
import os
os.system('regedit')

#### Open Device Manager: open Windows device manager
METHOD: system
COMMAND:
import os
os.system('devmgmt.msc')





#### üü¶ Word Example: create professional resume in Word
METHOD: office
COMMAND:
import win32com.client, time
word = win32com.client.Dispatch('Word.Application')
word.Visible = True
doc = word.Documents.Add()
sel = word.Selection
sel.Font.Name = 'Calibri'
sel.Font.Size = 16
sel.Font.Bold = True
sel.TypeText('JOHN DOE\\n')
sel.Font.Size = 12
sel.Font.Bold = False
sel.TypeText('Email: john@example.com | Phone: (555) 123-4567\\n\\n')
sel.Font.Size = 14
sel.Font.Bold = True
sel.TypeText('PROFESSIONAL SUMMARY\\n')
sel.Font.Size = 11
sel.Font.Bold = False
sel.TypeText('Results-driven professional with over 5 years in data analytics and automation...\\n\\n')
sel.Font.Bold = True
sel.TypeText('SKILLS\\n')
sel.Font.Bold = False
sel.TypeText('‚Ä¢ Python, SQL, Excel Automation\\n‚Ä¢ Data Visualization\\n‚Ä¢ AI Integration\\n\\n')
sel.Font.Bold = True
sel.TypeText('EXPERIENCE\\n')
sel.Font.Bold = False
sel.TypeText('Data Analyst | DataCorp | 2020‚ÄìPresent\\n‚Ä¢ Automated reports saving 12 hours/week\\n‚Ä¢ Improved insights accuracy by 30%\\n\\n')

---

#### üüß PowerPoint Instructions:
For PowerPoint tasks:
- Generate 8-12 advanced slides with 4 to 5 short content
- Each slide must have 8-15 detailed bullet points with specific examples, statistics, case studies
- Include extensive technical details, real-world applications, industry insights
- Add multiple concept slides, implementation details, advanced features, future trends
- Use professional formatting with proper fonts and styling
- Handle file conflicts with unique timestamps
- Always use `win32com.client` PowerPoint automation

Example:
METHOD: office
COMMAND:
import win32com.client, time, os
try:
    ppt = win32com.client.Dispatch('PowerPoint.Application')
    ppt.Visible = True
    presentation = ppt.Presentations.Add()
    
    # Title Slide
    slide1 = presentation.Slides.Add(1, 1)
    slide1.Shapes.Title.TextFrame.TextRange.Text = "Advanced Topic Analysis: Comprehensive Deep Dive"
    slide1.Shapes.Placeholders(2).TextFrame.TextRange.Text = "Expert-Level Technical Overview and Strategic Implementation Guide\\nAdvanced Research and Industry Analysis\\nPresented by: AI Expert System\\nDate: " + time.strftime('%B %d, %Y')
    
    # Introduction & Background
    slide2 = presentation.Slides.Add(2, 2)
    slide2.Shapes.Title.TextFrame.TextRange.Text = "Comprehensive Introduction and Historical Context"
    slide2.Shapes.Placeholders(2).TextFrame.TextRange.Text = "‚Ä¢ Advanced definition with comprehensive technical specifications and industry standards\\n‚Ä¢ Historical evolution from inception to current state with key milestones and breakthroughs\\n‚Ä¢ Core architectural principles and fundamental design patterns used in implementation\\n‚Ä¢ Current market position with detailed statistics, adoption rates, and growth metrics\\n‚Ä¢ Significance in modern technological ecosystem with impact analysis and future projections\\n‚Ä¢ Comprehensive overview of benefits, limitations, challenges, and strategic considerations\\n‚Ä¢ Detailed scope of analysis including methodology, data sources, and evaluation criteria\\n‚Ä¢ Key stakeholders, industry leaders, and major contributors to field development\\n‚Ä¢ Regulatory landscape, compliance requirements, and legal framework considerations\\n‚Ä¢ Global market trends, regional variations, and cultural adaptation strategies"
    
    # Technical Architecture
    slide3 = presentation.Slides.Add(3, 2)
    slide3.Shapes.Title.TextFrame.TextRange.Text = "Advanced Technical Architecture and Core Components"
    slide3.Shapes.Placeholders(2).TextFrame.TextRange.Text = "‚Ä¢ Primary system architecture with detailed component breakdown and interaction patterns\\n‚Ä¢ Advanced algorithms and mathematical models with complexity analysis and optimization strategies\\n‚Ä¢ Data structures, storage mechanisms, and retrieval systems with performance benchmarks\\n‚Ä¢ Security frameworks, encryption protocols, and access control mechanisms\\n‚Ä¢ Scalability considerations, load balancing, and distributed system design principles\\n‚Ä¢ Integration capabilities with existing systems, APIs, and third-party services\\n‚Ä¢ Performance metrics, benchmarking results, and comparative analysis with alternatives\\n‚Ä¢ Quality assurance processes, testing methodologies, and validation frameworks\\n‚Ä¢ Maintenance requirements, update procedures, and lifecycle management strategies\\n‚Ä¢ Technical documentation standards, code quality metrics, and development best practices"
    
    # Implementation Details
    slide4 = presentation.Slides.Add(4, 2)
    slide4.Shapes.Title.TextFrame.TextRange.Text = "Advanced Implementation Strategies and Best Practices"
    slide4.Shapes.Placeholders(2).TextFrame.TextRange.Text = "‚Ä¢ Step-by-step implementation methodology with detailed project planning and resource allocation\\n‚Ä¢ Advanced configuration options, customization capabilities, and parameter optimization\\n‚Ä¢ Integration patterns with enterprise systems, databases, and cloud infrastructure\\n‚Ä¢ Development workflows, version control strategies, and collaborative development practices\\n‚Ä¢ Testing strategies including unit testing, integration testing, and performance validation\\n‚Ä¢ Deployment procedures, environment management, and continuous integration/deployment\\n‚Ä¢ Monitoring and logging systems with real-time analytics and alerting mechanisms\\n‚Ä¢ Troubleshooting guides, common issues resolution, and advanced debugging techniques\\n‚Ä¢ Performance tuning, optimization strategies, and resource utilization management\\n‚Ä¢ Documentation requirements, training materials, and knowledge transfer protocols"
    
    # Real-World Applications
    slide5 = presentation.Slides.Add(5, 2)
    slide5.Shapes.Title.TextFrame.TextRange.Text = "Comprehensive Real-World Applications and Industry Use Cases"
    slide5.Shapes.Placeholders(2).TextFrame.TextRange.Text = "‚Ä¢ Healthcare sector implementations with specific case studies, ROI analysis, and patient outcomes\\n‚Ä¢ Financial services applications including risk management, fraud detection, and regulatory compliance\\n‚Ä¢ Manufacturing and industrial automation with efficiency improvements and cost reduction metrics\\n‚Ä¢ Educational technology applications with learning outcome improvements and engagement statistics\\n‚Ä¢ Entertainment and media industry transformations with audience analytics and content optimization\\n‚Ä¢ Government and public sector implementations with citizen service improvements and cost savings\\n‚Ä¢ Small and medium business applications with accessibility considerations and scalability options\\n‚Ä¢ Enterprise-level deployments with integration challenges and organizational change management\\n‚Ä¢ Startup and innovation ecosystem applications with rapid prototyping and market validation\\n‚Ä¢ International implementations with localization requirements and cultural adaptation strategies"
    
    # Advanced Features
    slide6 = presentation.Slides.Add(6, 2)
    slide6.Shapes.Title.TextFrame.TextRange.Text = "Advanced Features and Cutting-Edge Capabilities"
    slide6.Shapes.Placeholders(2).TextFrame.TextRange.Text = "‚Ä¢ Machine learning integration with predictive analytics and intelligent automation capabilities\\n‚Ä¢ Advanced data processing with real-time analytics, pattern recognition, and anomaly detection\\n‚Ä¢ Cloud-native architecture with microservices, containerization, and serverless computing\\n‚Ä¢ Advanced security features including zero-trust architecture and advanced threat protection\\n‚Ä¢ Artificial intelligence integration with natural language processing and computer vision\\n‚Ä¢ Advanced user interface design with responsive layouts and accessibility compliance\\n‚Ä¢ API ecosystem with comprehensive documentation, SDKs, and developer tools\\n‚Ä¢ Advanced reporting and visualization with interactive dashboards and business intelligence\\n‚Ä¢ Mobile-first design with cross-platform compatibility and offline functionality\\n‚Ä¢ Advanced customization options with plugin architecture and extensibility frameworks"
    
    # Benefits & ROI
    slide7 = presentation.Slides.Add(7, 2)
    slide7.Shapes.Title.TextFrame.TextRange.Text = "Comprehensive Benefits Analysis and Return on Investment"
    slide7.Shapes.Placeholders(2).TextFrame.TextRange.Text = "‚Ä¢ Quantifiable efficiency improvements with detailed metrics, benchmarks, and comparative analysis\\n‚Ä¢ Cost reduction strategies with comprehensive financial analysis and long-term projections\\n‚Ä¢ Quality enhancement measures with customer satisfaction improvements and retention statistics\\n‚Ä¢ Scalability advantages for growing organizations with capacity planning and resource optimization\\n‚Ä¢ Innovation opportunities with competitive market positioning and differentiation strategies\\n‚Ä¢ Risk mitigation strategies with comprehensive risk assessment and contingency planning\\n‚Ä¢ Sustainability benefits with environmental impact analysis and corporate responsibility metrics\\n‚Ä¢ Productivity gains with workforce optimization and skill development requirements\\n‚Ä¢ Market expansion opportunities with new revenue streams and business model innovations\\n‚Ä¢ Strategic advantages with competitive intelligence and market positioning analysis"
    
    # Apply advanced formatting
    for slide_num in range(1, 8):
        slide = presentation.Slides(slide_num)
        slide.Shapes.Title.TextFrame.TextRange.Font.Name = "Calibri"
        slide.Shapes.Title.TextFrame.TextRange.Font.Size = 24
        slide.Shapes.Title.TextFrame.TextRange.Font.Bold = True
        slide.Shapes.Title.TextFrame.TextRange.Font.Color.RGB = 0x1F4E79
        if slide_num > 1:
            slide.Shapes.Placeholders(2).TextFrame.TextRange.Font.Name = "Calibri"
            slide.Shapes.Placeholders(2).TextFrame.TextRange.Font.Size = 14
            slide.Shapes.Placeholders(2).TextFrame.TextRange.ParagraphFormat.SpaceAfter = 6
    
    filename = f'C:\\\\Users\\\\Public\\\\Advanced_Presentation_{int(time.time())}.pptx'
    presentation.SaveAs(filename)

---

#### üü© Excel Example: create sales report in Excel
METHOD: office
COMMAND:
import win32com.client
excel = win32com.client.Dispatch('Excel.Application')
excel.Visible = True
workbook = excel.Workbooks.Add()
sheet = workbook.Sheets(1)
sheet.Name = "Sales Report"
sheet.Cells(1, 1).Value = "Product"
sheet.Cells(1, 2).Value = "Sales"
sheet.Cells(2, 1).Value = "Laptop"
sheet.Cells(2, 2).Value = 12000
sheet.Cells(3, 1).Value = "Smartphone"
sheet.Cells(3, 2).Value = 8500
sheet.Cells(4, 1).Value = "Tablet"
sheet.Cells(4, 2).Value = 4000
sheet.Cells(6, 1).Value = "Total"
sheet.Cells(6, 2).Formula = "=SUM(B2:B4)"
sheet.Columns.AutoFit()

---

### Screen Analysis Commands:
- "what am I using on screen" ‚Üí METHOD: screen
- "explain my screen" ‚Üí METHOD: screen  
- "analyze screen content" ‚Üí METHOD: screen
- "summarize screen" ‚Üí METHOD: screen

### Search & Explain Commands:
- "search google for [topic] and explain" ‚Üí METHOD: search
- "explain google results for [topic]" ‚Üí METHOD: search

### File Analysis Commands:
- "read a.txt file" ‚Üí METHOD: file
- "explain content of [filename]" ‚Üí METHOD: file
- "analyze [filename]" ‚Üí METHOD: file

### Next Move Control Commands:
- "disable next move predictions" ‚Üí METHOD: system, COMMAND: from engine.ultimate_ai_executor import ultimate_ai; print(ultimate_ai.disable_next_move_predictions())
- "enable next move predictions" ‚Üí METHOD: system, COMMAND: from engine.ultimate_ai_executor import ultimate_ai; print(ultimate_ai.enable_next_move_predictions())
- "next move status" ‚Üí METHOD: system, COMMAND: from engine.ultimate_ai_executor import ultimate_ai; print(f"Next move predictions: {'Enabled' if ultimate_ai.get_next_move_status() else 'Disabled'}")
You are an expert automation system. Windows automation system. CRITICAL SAVE RULES: For save commands, use METHOD: pyautogui with this logic: pyautogui.hotkey('ctrl', 's'), wait 2 seconds, then type filename and press enter. This handles both existing files (Ctrl+S) and new files (Save As dialog). NEVER use office automation for simple save operations. For volume commands, use METHOD: system with ctypes. For screen analysis, use METHOD: screen. For Google search, use METHOD: search. For file content analysis, use METHOD: file. For YouTube/video commands, use METHOD: system with webbrowser.open(). For browser automation, use METHOD: pyautogui with clicks and typing. For 'disable next move predictions' or 'enable next move predictions' commands, use METHOD: system with ultimate_ai control methods.
Now generate the proper output for this command:
"{user_command}"
"""

        
        # Try 70B model first for complex automation tasks
        try:
            from groq import Groq
            from engine.groq_config import GROQ_API_KEY
            groq_client = Groq(api_key=GROQ_API_KEY)
            
            response = groq_client.chat.completions.create(
                model="llama-3.3-70b-versatile",
                messages=[{"role": "user", "content": prompt}],
                max_tokens=1000
            )
            result = response.choices[0].message.content.strip()
            if result:
                return result
        except Exception as e:
            print(f"70B model failed: {e}, falling back to dual_ai")
        
        # Fallback to dual_ai
        from engine.dual_ai import dual_ai
        result = dual_ai._answer_question(prompt)
        if result:
            return result

    def run_cmd(self, command):
        print(f"[CMD] -> {command}")
        subprocess.run(command, shell=True)

    def run_powershell(self, command):
        print(f"[PowerShell] -> {command}")
        subprocess.run(["powershell", "-Command", command], shell=True)

    def run_python_subprocess(self, command):
        print(f"[Python Subprocess] -> {command}")
        subprocess.Popen(command, shell=True)

    def run_system_call(self, command):
        print(f"[System Call] -> {command}")
        if command.startswith('os.system(') or 'import' in command:
            exec(command, globals())
        else:
            os.system(command)

    def run_pyautogui(self, command):
        print(f"[PyAutoGUI] executing ->")
        exec_globals = {
            'os': os,
            'time': time,
            'pyautogui': pyautogui,
            'subprocess': subprocess
        }
        exec(command, exec_globals)

    def run_office(self, command):
        print(f"[Office Automation] executing ->")
        exec(command, globals())
        
    def run_screen_analysis(self, command):
        print(f"[Screen Analysis] executing ->")
        exec_globals = {
            'pyautogui': pyautogui,
            'time': time,
            'os': os,
            'subprocess': subprocess,
            'win32gui': None
        }
        try:
            import win32gui
            exec_globals['win32gui'] = win32gui
        except:
            pass
        exec(command, exec_globals)
        
    def run_search_explanation(self, command):
        print(f"[Search & Explain] executing ->")
        exec_globals = {
            'webbrowser': webbrowser,
            'requests': requests
        }
        exec(command, exec_globals)
        
    def run_file_analysis(self, command):
        print(f"[File Analysis] executing ->")
        exec(command, globals())
    
    def _init_learning_db(self):
        conn = sqlite3.connect(self.learning_db)
        conn.execute('''CREATE TABLE IF NOT EXISTS command_history 
                       (id INTEGER PRIMARY KEY, command TEXT, method TEXT, 
                        success INTEGER, timestamp TEXT, context TEXT)''')
        conn.execute('''CREATE TABLE IF NOT EXISTS user_patterns 
                       (id INTEGER PRIMARY KEY, pattern TEXT, frequency INTEGER, 
                        last_used TEXT, context TEXT)''')
        conn.close()
    
    def success_failure_tracker(self, command, method, success, context=""):
        conn = sqlite3.connect(self.learning_db)
        conn.execute('INSERT INTO command_history VALUES (NULL, ?, ?, ?, ?, ?)',
                    (command, method, success, datetime.now().isoformat(), context))
        conn.commit()
        conn.close()
    
    def next_action_predictor(self):
        conn = sqlite3.connect(self.learning_db)
        cursor = conn.execute('SELECT command, COUNT(*) as freq FROM command_history WHERE success=1 GROUP BY command ORDER BY freq DESC LIMIT 5')
        predictions = [row[0] for row in cursor.fetchall()]
        conn.close()
        return predictions
    
    def pattern_learning(self, command):
        conn = sqlite3.connect(self.learning_db)
        cursor = conn.execute('SELECT frequency FROM user_patterns WHERE pattern=?', (command,))
        result = cursor.fetchone()
        if result:
            conn.execute('UPDATE user_patterns SET frequency=?, last_used=? WHERE pattern=?',
                        (result[0] + 1, datetime.now().isoformat(), command))
        else:
            conn.execute('INSERT INTO user_patterns VALUES (NULL, ?, 1, ?, "")',
                        (command, datetime.now().isoformat()))
        conn.commit()
        conn.close()
    

    
    def smart_error_recovery(self, failed_command, error_msg):
        recovery_map = {
            "chrome": "start msedge",
            "notepad": "start wordpad",
            "excel": "start calc",
            "word": "start notepad"
        }
        
        for app, alternative in recovery_map.items():
            if app in failed_command.lower():
                print(f"üîÑ Auto-recovery: Trying {alternative} instead")
                os.system(alternative)
                return True
        return False
    

    
    def execute_command(self, user_command):
        """Main function to execute any desktop command"""
        try:
            # Get AI response for the command
            ai_response = self.get_ai_response(user_command)
            if not ai_response:
                return "Command not recognized"
            
            # Parse METHOD and COMMAND from AI response
            lines = ai_response.split('\n')
            method = None
            command = []
            
            for line in lines:
                if line.startswith('METHOD:'):
                    method = line.replace('METHOD:', '').strip()
                elif line.startswith('COMMAND:'):
                    command = []
                elif method and line.strip():
                    command.append(line)
            
            if not method or not command:
                return "Invalid command format"
            
            # Execute based on method
            command_code = '\n'.join(command)
            
            if method == 'system':
                self.run_system_call(command_code)
            elif method == 'pyautogui':
                self.run_pyautogui(command_code)
            elif method == 'office':
                self.run_office(command_code)
            elif method == 'ai':
                exec(command_code, globals())
            elif method == 'ai_office':
                exec(command_code, globals())
            elif method == 'screen':
                self.run_screen_analysis(command_code)
            elif method == 'search':
                self.run_search_explanation(command_code)
            elif method == 'file':
                self.run_file_analysis(command_code)
            else:
                return f"Unknown method: {method}"
            
            return "Command executed successfully"
            
        except Exception as e:
            return f"Error executing command: {str(e)}"
    
    def workflow_automation(self, trigger_command):
        workflows = {
            "morning_routine": ["check calendar", "open email", "check weather"],
            "work_setup": ["open excel", "open chrome", "open notepad"],
            "presentation_mode": ["open powerpoint", "close distractions", "set focus mode"]
        }
        
        for workflow, commands in workflows.items():
            if workflow in trigger_command.lower():
                print(f"ü§ñ Executing workflow: {workflow}")
                for cmd in commands:
                    print(f"  ‚Üí {cmd}")
                return True
        return False
    

    
    def behavioral_analytics(self):
        conn = sqlite3.connect(self.learning_db)
        cursor = conn.execute('SELECT command, COUNT(*) as freq FROM command_history GROUP BY command ORDER BY freq DESC LIMIT 10')
        top_commands = cursor.fetchall()
        
        cursor = conn.execute('SELECT AVG(success) as success_rate FROM command_history')
        success_rate = cursor.fetchone()[0] or 0
        
        conn.close()
        
        return {
            "top_commands": top_commands,
            "success_rate": success_rate * 100,
            "total_commands": len(top_commands)
        }
    
    def adaptive_command_optimization(self, command):
        conn = sqlite3.connect(self.learning_db)
        cursor = conn.execute('SELECT method, AVG(success) as success_rate FROM command_history WHERE command LIKE ? GROUP BY method ORDER BY success_rate DESC',
                             (f"%{command}%",))
        best_method = cursor.fetchone()
        conn.close()
        
        if best_method and best_method[1] > 0.8:
            return best_method[0]
        return "system"
    
    def predict_next_move(self, current_command):
        """AI predicts next logical action based on context"""
        if not self.next_move_predictions_enabled:
            return []
        
        prompt = f"""
You are an expert workflow predictor. Based on what the user just did, predict the MOST LOGICAL next action.

User's current action: "{current_command}"

üß† CONTEXT ANALYSIS:
- If they opened/created something ‚Üí suggest saving, formatting, or adding content
- If they wrote/typed content ‚Üí suggest saving, copying, or sharing
- If they searched/browsed ‚Üí suggest bookmarking, downloading, or taking notes
- If they took screenshot ‚Üí suggest editing, saving, or sharing
- If they opened app ‚Üí suggest common first actions in that app
- If they saved something ‚Üí suggest opening, sharing, or creating backup
- If they created document ‚Üí suggest adding content, formatting, or printing
- If they sent message ‚Üí suggest checking replies or sending to others
- If they made calculation ‚Üí suggest saving result or using in document
- If they opened media ‚Üí suggest adjusting volume, fullscreen, or sharing

üí° SMART SUGGESTIONS:
- Be specific and immediately actionable
- Consider professional workflows
- Think about what 90% of users do next
- Suggest productive follow-up actions
- Include creative and useful options

üìã EXAMPLES:
- "open notepad write hello" ‚Üí "Save the document"
- "create presentation about AI" ‚Üí "Add more slides"
- "take screenshot" ‚Üí "Edit the image"
- "search google for python" ‚Üí "Bookmark useful results"
- "open calculator" ‚Üí "Copy the result"
- "send email to john" ‚Üí "Check for replies"
- "create folder documents" ‚Üí "Move files to folder"
- "open spotify" ‚Üí "Create new playlist"

Output ONLY the suggestion (2-5 words):
"""
        
        try:
            from engine.dual_ai import dual_ai
            
            suggestion = dual_ai._answer_question(prompt)
            
            # Clean the suggestion
            suggestion = suggestion.replace('[', '').replace(']', '').strip()
            
            return [suggestion] if suggestion else []
        except:
            return []
    

    

    
    def _generate_smart_response(self, command, method):
        """Generate intelligent response based on executed command"""
        prompt = f"""
User executed command: "{command}"
Execution method: {method}
Status: SUCCESS

Generate a brief, natural response confirming what was accomplished.

Examples:
- "open notepad" ‚Üí "Notepad opened successfully"
- "create presentation" ‚Üí "Presentation created"
- "take screenshot" ‚Üí "Screenshot captured"
- "search google" ‚Üí "Google search completed"

Be concise (3-6 words). Output ONLY the response.
"""
        
        try:
            from engine.dual_ai import dual_ai
            
            result = dual_ai._answer_question(prompt)
            if result:
                return result
        except:
            # Fallback responses
            if "open" in command:
                app = command.replace("open", "").strip()
                return f"{app} opened successfully"
            elif "create" in command:
                return "Creation completed"
            elif "search" in command:
                return "Search completed"
            else:
                return "Command executed successfully"

    def execute(self, user_command):
        """Universal execution of any natural language command"""
        self.pattern_learning(user_command)
        
        if self.workflow_automation(user_command):
            return
        
        plan = self.interpret_command(user_command)
        print("\nAI Generated Plan:")
        print(plan)
        print("=" * 60)

        method = ""
        command = ""

        lines = plan.splitlines()
        for i, line in enumerate(lines):
            if line.startswith("METHOD:"):
                method = line.split(":", 1)[1].strip().lower()
            elif line.startswith("COMMAND:"):
                # Get command and all following lines
                command_parts = [line.split(":", 1)[1].strip()]
                for j in range(i + 1, len(lines)):
                    if not lines[j].startswith("----") and lines[j].strip():
                        command_parts.append(lines[j])
                    elif lines[j].startswith("----"):
                        break
                command = "\n".join(command_parts)

        if not method or not command:
            print("ERROR: Could not parse AI output.")
            return

        if self.confirmation_required:
            ch = input(f"WARNING: Execute using [{method}]? (y/n): ").strip().lower()
            if ch != "y":
                print("CANCELLED.")
                return

        try:
            if method == "cmd":
                self.run_cmd(command)
            elif method == "powershell":
                self.run_powershell(command)
            elif method == "python":
                self.run_python_subprocess(command)
            elif method == "pyautogui":
                self.run_pyautogui(command)
            elif method == "office":
                self.run_office(command)
            elif method == "screen":
                self.run_screen_analysis(command)
            elif method == "search":
                self.run_search_explanation(command)
            elif method == "file":
                self.run_file_analysis(command)
            elif method == "system":
                self.run_system_call(command)
            else:
                print("WARNING: Unknown method, fallback to system call.")
                self.run_system_call(command)
            print("SUCCESS: Command executed successfully!")
            self.success_failure_tracker(user_command, method, 1)
            
            # Generate intelligent response based on command
            response = self._generate_smart_response(user_command, method)
            
            # Return response immediately - next move will be handled by command.py
            return response
            
        except Exception as e:
            print(f"ERROR executing: {e}")
            self.success_failure_tracker(user_command, method, 0, str(e))
            
            # Try fallback execution for basic commands
        
            
            if not self.smart_error_recovery(user_command, str(e)):
                print("‚ùå No automatic recovery available")
            return f"Failed to execute: {user_command}"
    
    # Next move predictions control methods
    def enable_next_move_predictions(self):
        self.next_move_predictions_enabled = True
        return "Next move predictions enabled"
    
    def disable_next_move_predictions(self):
        self.next_move_predictions_enabled = False
        return "Next move predictions disabled"
    
    def get_next_move_status(self):
        return self.next_move_predictions_enabled

# Global instance
# Create global instance
ultimate_ai = UltimateAIExecutor()

# Main function to use from other modules
def execute_desktop_command(command):
    """Execute any desktop automation command"""
    return ultimate_ai.execute_command(command)

# Quick access functions
def open_app(app_name):
    return execute_desktop_command(f"open {app_name}")

def system_control(action):
    return execute_desktop_command(action)

def create_document(doc_type, content=""):
    return execute_desktop_command(f"create {doc_type} document with {content}")

def ai_automation(task):
    return execute_desktop_command(f"use AI to {task}")

if __name__ == "__main__":
    # Test the system
    print("Ultimate AI Executor Ready!")
    print(execute_desktop_command("open calculator"))
    print(execute_desktop_command("check system info"))

def execute_command(cmd):
    """Simple function to execute any command"""
    return ultimate_ai.execute(cmd)

if __name__ == "__main__":
    print("üß† Ultimate AI Executor Activated with Proactive Learning!")
    print("ü§ñ Features: Learning, Predictions, Auto-Recovery, AI Next-Move Execution")
    print("Examples:")
    print(" - open chrome and go to youtube")
    print(" - create ppt about AI")
    print(" - write hello world in notepad")
    print(" - what am I using on screen")
    print(" - explain my screen content")
    print(" - search google for python and explain")
    print(" - read and explain a.txt file")
    print(" - morning_routine (workflow automation)")
    print(" - work_setup (workflow automation)")
    print(" - shutdown laptop after 1 minute")
    print("=" * 50)
    
    analytics = ultimate_ai.behavioral_analytics()
    if analytics['total_commands'] > 0:
        print(f"üìä Your Stats: {analytics['success_rate']:.1f}% success rate, {analytics['total_commands']} command types learned")
    

    print()

    while True:
        cmd = input("\nüó£Ô∏è You: ").strip()
        if cmd.lower() in ["exit", "quit"]:
            break
        execute_command(cmd)
import os
import subprocess
import pyautogui
import time
import win32com.client
import requests
import webbrowser
from PIL import Image
from engine.dual_ai import dual_ai
import sqlite3
import json
from datetime import datetime, timedelta
from collections import Counter
import psutil

class UltimateAIExecutor:
    def __init__(self):
        self.confirmation_required = False
        self.learning_db = os.path.join(os.path.expanduser('~'), '.jarvis_learning.db')
        self._init_learning_db()
        self.next_move_predictions_enabled = False
        
    def get_ai_response(self, user_command):
        """Get AI response with simplified prompt"""
        prompt = f"""
You are a Windows automation system. Convert user commands to executable code.

User Command: "{user_command}"

Output format:
METHOD: <system | pyautogui | office | screen | search | file | ai>
COMMAND: <exact Python code>

Method Rules:
- system: Apps, files, system control
- pyautogui: Typing, clicking, shortcuts  
- office: Word, Excel, PowerPoint
- screen: Screenshot analysis
- search: Google search
- file: Read file contents
- ai: AI-powered tasks

Generate working Python code for any desktop automation task.
"""

        # Try 70B model first for complex automation tasks
        try:
            from groq import Groq
            from engine.groq_config import GROQ_API_KEY
            groq_client = Groq(api_key=GROQ_API_KEY)
            
            response = groq_client.chat.completions.create(
                model="llama-3.3-70b-versatile",
                messages=[{"role": "user", "content": prompt}],
                max_tokens=1000
            )
            result = response.choices[0].message.content.strip()
            if result:
                return result
        except Exception as e:
            print(f"70B model failed: {e}, falling back to dual_ai")
        
        # Fallback to dual_ai
        from engine.dual_ai import dual_ai
        result = dual_ai._answer_question(prompt)
        if result:
            return result

    def run_system_call(self, command):
        print(f"[System Call] -> {command}")
        if command.startswith('os.system(') or 'import' in command:
            exec(command, globals())
        else:
            os.system(command)

    def run_pyautogui(self, command):
        print(f"[PyAutoGUI] executing ->")
        exec_globals = {
            'os': os,
            'time': time,
            'pyautogui': pyautogui,
            'subprocess': subprocess
        }
        exec(command, exec_globals)

    def run_office(self, command):
        print(f"[Office Automation] executing ->")
        exec(command, globals())
        
    def run_screen_analysis(self, command):
        print(f"[Screen Analysis] executing ->")
        exec_globals = {
            'pyautogui': pyautogui,
            'time': time,
            'os': os,
            'subprocess': subprocess,
            'win32gui': None
        }
        try:
            import win32gui
            exec_globals['win32gui'] = win32gui
        except:
            pass
        exec(command, exec_globals)
        
    def run_search_explanation(self, command):
        print(f"[Search & Explain] executing ->")
        exec_globals = {
            'webbrowser': webbrowser,
            'requests': requests
        }
        exec(command, exec_globals)
        
    def run_file_analysis(self, command):
        print(f"[File Analysis] executing ->")
        exec(command, globals())
    
    def _init_learning_db(self):
        conn = sqlite3.connect(self.learning_db)
        conn.execute('''CREATE TABLE IF NOT EXISTS command_history 
                       (id INTEGER PRIMARY KEY, command TEXT, method TEXT, 
                        success INTEGER, timestamp TEXT, context TEXT)''')
        conn.execute('''CREATE TABLE IF NOT EXISTS user_patterns 
                       (id INTEGER PRIMARY KEY, pattern TEXT, frequency INTEGER, 
                        last_used TEXT, context TEXT)''')
        conn.close()
    
    def success_failure_tracker(self, command, method, success, context=""):
        conn = sqlite3.connect(self.learning_db)
        conn.execute('INSERT INTO command_history VALUES (NULL, ?, ?, ?, ?, ?)',
                    (command, method, success, datetime.now().isoformat(), context))
        conn.commit()
        conn.close()
    
    def execute_command(self, user_command):
        """Main function to execute any desktop command"""
        try:
            # Get AI response for the command
            ai_response = self.get_ai_response(user_command)
            if not ai_response:
                return "Command not recognized"
            
            # Parse METHOD and COMMAND from AI response
            lines = ai_response.split('\n')
            method = None
            command = []
            
            for line in lines:
                if line.startswith('METHOD:'):
                    method = line.replace('METHOD:', '').strip()
                elif line.startswith('COMMAND:'):
                    command = []
                elif method and line.strip():
                    command.append(line)
            
            if not method or not command:
                return "Invalid command format"
            
            # Execute based on method
            command_code = '\n'.join(command)
            
            if method == 'system':
                self.run_system_call(command_code)
            elif method == 'pyautogui':
                self.run_pyautogui(command_code)
            elif method == 'office':
                self.run_office(command_code)
            elif method == 'ai':
                exec(command_code, globals())
            elif method == 'screen':
                self.run_screen_analysis(command_code)
            elif method == 'search':
                self.run_search_explanation(command_code)
            elif method == 'file':
                self.run_file_analysis(command_code)
            else:
                return f"Unknown method: {method}"
            
            return "Command executed successfully"
            
        except Exception as e:
            return f"Error executing command: {str(e)}"

    def execute(self, user_command):
        """Universal execution of any natural language command"""
        try:
            plan = self.get_ai_response(user_command)
            print("\nAI Generated Plan:")
            print(plan)
            print("=" * 60)

            method = ""
            command = ""

            lines = plan.splitlines()
            for i, line in enumerate(lines):
                if line.startswith("METHOD:"):
                    method = line.split(":", 1)[1].strip().lower()
                elif line.startswith("COMMAND:"):
                    # Get command and all following lines
                    command_parts = [line.split(":", 1)[1].strip()]
                    for j in range(i + 1, len(lines)):
                        if not lines[j].startswith("----") and lines[j].strip():
                            command_parts.append(lines[j])
                        elif lines[j].startswith("----"):
                            break
                    command = "\n".join(command_parts)

            if not method or not command:
                print("ERROR: Could not parse AI output.")
                return

            try:
                if method == "pyautogui":
                    self.run_pyautogui(command)
                elif method == "office":
                    self.run_office(command)
                elif method == "screen":
                    self.run_screen_analysis(command)
                elif method == "search":
                    self.run_search_explanation(command)
                elif method == "file":
                    self.run_file_analysis(command)
                elif method == "system":
                    self.run_system_call(command)
                else:
                    print("WARNING: Unknown method, fallback to system call.")
                    self.run_system_call(command)
                    
                print("SUCCESS: Command executed successfully!")
                self.success_failure_tracker(user_command, method, 1)
                return "Command executed successfully"
                
            except Exception as e:
                print(f"ERROR executing: {e}")
                self.success_failure_tracker(user_command, method, 0, str(e))
                return f"Failed to execute: {user_command}"
                
        except Exception as e:
            return f"Error: {str(e)}"

# Global instance
ultimate_ai = UltimateAIExecutor()

# Main function to use from other modules
def execute_desktop_command(command):
    """Execute any desktop automation command"""
    return ultimate_ai.execute_command(command)

def execute_command(cmd):
    """Simple function to execute any command"""
    return ultimate_ai.execute(cmd)

if __name__ == "__main__":
    print("Ultimate AI Executor Ready!")
    print("Examples: 'open calculator', 'create word document', 'take screenshot'")
    
    while True:
        cmd = input("\nYou: ").strip()
        if cmd.lower() in ["exit", "quit"]:
            break
        execute_command(cmd)
import subprocess
import pyautogui
import psutil
from datetime import datetime, timedelta
import json
import os
import shutil
import socket
import time
import random
import requests
import sqlite3
from collections import Counter
from typing import Optional, Dict, Any, List
import zipfile
import re
import warnings
warnings.filterwarnings("ignore")
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'

class VoiceAdvancedAI:
    def __init__(self):
        # Initialize AI models
        self.ai_provider = self._get_ai_provider()
        self._init_ai_models()
        
        # Initialize multilingual support
        try:
            from engine.multilingual_support import multilingual
            self.multilingual = multilingual
        except:
            self.multilingual = None
        
        # Advanced features paths
        project_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        self.MEMORY_DB = os.path.join(project_dir, "jarvis_memory.db")
        self.CALENDAR_JSON = os.path.join(project_dir, "jarvis_calendar.json")
        self.VAULT_DIR = os.path.join(project_dir, "jarvis_vault")
        self.USAGE_LOG = os.path.join(project_dir, "jarvis_usage.json")
        self._ensure_db()
        
        # ALL VOICE-ACTIVATED ADVANCED FEATURES
        self.voice_functions = {
            # System Monitoring
            'system monitor live': self.system_monitor_dashboard_live,
            'monitor system': self.system_monitor_dashboard_live,
            'system monitor': self.system_monitor_dashboard_live,
            'auto fix system': self.auto_fix_system_basic,
            'fix system': self.auto_fix_system_basic,
            'system fix': self.auto_fix_system_basic,
            
            # Package Management
            'install package': self.install_package,
            'list packages': self.list_packages,
            'uninstall package': self.uninstall_package,
            'manage package': self.manage_package_help,
            
            # Memory & Context
            'what do you remember': self.context_memory_recall,
            'recall memory': self.context_memory_recall,
            'show memories': self.context_memory_recall,
            'daily briefing': self.daily_briefing,
            'get briefing': self.daily_briefing,
            'morning briefing': self.daily_briefing,
            
            # Calendar & Scheduling
            'schedule event': self.calendar_schedule,
            'book appointment': self.calendar_schedule,
            'show calendar': self.show_calendar,
            'check calendar': self.show_calendar,
            'my events': self.show_calendar,
            'what meetings': self.show_calendar,
            
            # Email & Communication
            'summarize email': self.email_summarize,
            'email summary': self.email_summarize,
            
            # Device & Cloud
            'sync devices': self.sync_across_devices,
            'device sync': self.sync_across_devices,
            'cloud backup': self.cloud_backup_manager,
            'backup files': self.cloud_backup_manager,
            
            # AI Productivity
            'transcribe audio': self.realtime_transcription,
            'voice to text': self.realtime_transcription,
            'summarize meeting': self.summarize_meeting,
            'meeting summary': self.summarize_meeting,
            'smart clipboard': self.smart_clipboard_store,
            'document qa': self.document_assistant_qa,
            'ask document': self.document_assistant_qa,
            'create presentation': self.ai_presentation_maker,
            'ai presentation': self.ai_presentation_maker,
            'create document': self.ai_document_maker,
            'create report': self.ai_document_maker,
            'create letter': self.ai_document_maker,
            'ai document': self.ai_document_maker,
            
            # Smart Home
            'smart home': self.smart_home_control,
            'control lights': self.smart_home_control,
            'home automation': self.smart_home_control,
            'home scene': self.set_home_scene,
            'set scene': self.set_home_scene,
            'security camera': self.security_camera_snapshot,
            'energy monitor': self.energy_monitoring_report,
            
            # Entertainment
            'dj mode': self.ai_dj_mode,
            'music dj': self.ai_dj_mode,
            'ai dj': self.ai_dj_mode,
            'trivia game': self.trivia_game_start,
            'play trivia': self.trivia_game_start,
            'tell story': self.storytelling_mode,
            'story mode': self.storytelling_mode,
            'fitness coach': self.fitness_coach,
            'workout coach': self.fitness_coach,
            
            # AI Agents
            'code agent': self.code_agent,
            'coding help': self.code_agent,
            'debug screen': self.debug_screen_code,
            'fix my code': self.debug_screen_code,
            'check code': self.debug_screen_code,
            'research agent': self.research_agent,
            'research help': self.research_agent,
            'organizer agent': self.organizer_agent,
            'organize tasks': self.organizer_agent,
            'multi agent': self.multi_agent_collab,
            'agent collaboration': self.multi_agent_collab,
            
            # Web Intelligence
            'scholar search': self.scholar_search,
            'academic search': self.scholar_search,
            'stock updates': self.stock_updates,
            'stock market': self.stock_updates,
            'crypto updates': self.crypto_updates,
            'cryptocurrency': self.crypto_updates,
            'translate text': self.realtime_translation,
            'real time translation': self.realtime_translation,
            
            # Health & Wellness
            'posture check': self.posture_detection,
            'check posture': self.posture_detection,
            'eye care': self.eye_care_mode,
            'protect eyes': self.eye_care_mode,
            'health log': self.daily_health_log,
            'track health': self.daily_health_log,
            'mood tracker': self.mood_tracker,
            'track mood': self.mood_tracker,
            'meditation': self.meditation_prompt,
            'meditate': self.meditation_prompt,
            
            # Security & Authentication
            'encrypt file': self.file_vault_encrypt,
            'decrypt file': self.file_vault_decrypt,
            'scan for threats': self.anomaly_detection_recent_processes,
            'security scan': self.anomaly_detection_recent_processes,
            'phishing scan': self.phishing_malware_scan_link,
            'parental control': self.parental_control_set,
            
            # Learning & Adaptation
            'adaptive learning': self.adaptive_learning,
            'learn from me': self.adaptive_learning,
            'check proactive': self.check_proactive_suggestions,
            'proactive suggestions': self.check_proactive_suggestions,
            'enable proactive': self.enable_proactive_mode,
            'disable proactive': self.disable_proactive_mode,
            'manual learn': self.manual_learn,
            'teach jarvis': self.manual_learn,
            'predictive assistance': self.predictive_assistance,
            'suggest actions': self.auto_suggest_with_popup,
            'start proactive background': self.start_proactive_background,
            
            # Docker & Development
            'docker control': self.docker_control,
            'docker help': self.docker_control,
        }
    
    def _get_ai_provider(self):
        try:
            with open('ai_config.json', 'r') as f:
                config = json.load(f)
                return config.get('ai_provider', 'groq')
        except:
            return 'groq'
    
    def _init_ai_models(self):
        if self.ai_provider == 'groq':
            try:
                from groq import Groq
                from engine.groq_config import GROQ_API_KEY
                self.groq_client = Groq(api_key=GROQ_API_KEY)
            except Exception as e:
                print(f"Groq failed: {e}, using Gemini")
                self.ai_provider = 'gemini'
                self._init_gemini()
        else:
            self._init_gemini()
    
    def _init_gemini(self):
        try:
            import google.generativeai as genai
            from engine.gemini_config import GEMINI_API_KEY
            genai.configure(api_key=GEMINI_API_KEY)
            self.gemini_model = genai.GenerativeModel('gemini-2.0-flash')
        except Exception as e:
            print(f"AI init error: {e}")
    
    # Utility methods
    def _ensure_db(self):
        if not os.path.exists(self.MEMORY_DB):
            conn = sqlite3.connect(self.MEMORY_DB)
            c = conn.cursor()
            c.execute("CREATE TABLE memory (id INTEGER PRIMARY KEY, key TEXT, value TEXT, ts INTEGER)")
            conn.commit()
            conn.close()

    def _memory_set(self, key: str, value: Any):
        self._ensure_db()
        conn = sqlite3.connect(self.MEMORY_DB)
        c = conn.cursor()
        c.execute("INSERT INTO memory (key, value, ts) VALUES (?, ?, ?)", (key, json.dumps(value), int(time.time())))
        conn.commit()
        conn.close()

    def _memory_get_all(self, key: str) -> List[Any]:
        self._ensure_db()
        conn = sqlite3.connect(self.MEMORY_DB)
        c = conn.cursor()
        c.execute("SELECT value FROM memory WHERE key = ? ORDER BY ts DESC", (key,))
        rows = c.fetchall()
        conn.close()
        return [json.loads(r[0]) for r in rows]

    def _calendar_add(self, title: str, event_time: str = ""):
        events = []
        if os.path.exists(self.CALENDAR_JSON):
            with open(self.CALENDAR_JSON, 'r') as f:
                events = json.load(f)
        
        events.append({
            'title': title,
            'time': event_time,
            'created': datetime.now().isoformat()
        })
        
        with open(self.CALENDAR_JSON, 'w') as f:
            json.dump(events, f, indent=2)
    
    def storytelling_mode(self, topic="random"):
        """Interactive storytelling with AI"""
        try:
            if self.ai_provider == 'groq':
                response = self.groq_client.chat.completions.create(
                    model="llama-3.1-8b-instant",
                    messages=[{
                        "role": "user",
                        "content": f"Tell me an engaging, creative story about {topic}. Make it interactive and ask what happens next."
                    }]
                )
                story = response.choices[0].message.content
            else:
                story = self.gemini_model.generate_content(
                    f"Tell me an engaging, creative story about {topic}. Make it interactive and ask what happens next."
                ).text
            
            print(f"\nStory Mode Activated\n{story}")
            return story
        # amazonq-ignore-next-line
        except Exception as e:
            return f"Story mode error: {e}"
    
    # amazonq-ignore-next-line
    def fitness_coach(self, workout_type="general"):
        """AI fitness coaching and workout guidance"""
        try:
            if self.ai_provider == 'groq':
                response = self.groq_client.chat.completions.create(
                    model="llama-3.1-8b-instant",
                    messages=[{
                        "role": "user",
                        "content": f"Act as a fitness coach. Provide a {workout_type} workout routine with exercises, reps, and motivational tips."
                    }]
                )
                workout = response.choices[0].message.content
            else:
                workout = self.gemini_model.generate_content(
                    f"Act as a fitness coach. Provide a {workout_type} workout routine with exercises, reps, and motivational tips."
                ).text
            
            print(f"\nFitness Coach Activated\n{workout}")
            return workout
        except Exception as e:
            return f"Fitness coach error: {e}"
    
    # amazonq-ignore-next-line
    # amazonq-ignore-next-line
    def _calendar_add_advanced(self, title: str, event_time: str = ""):
        events = []
        if os.path.exists(self.CALENDAR_JSON):
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            with open(self.CALENDAR_JSON, 'r') as f:
                events = json.load(f)
        
        if 'tomorrow' in title.lower():
            date = (datetime.now() + timedelta(days=1)).strftime('%Y-%m-%d')
            # amazonq-ignore-next-line
            title = title.replace('tomorrow', '').replace('Tomorrow', '').strip()
        elif 'today' in title.lower():
            date = datetime.now().strftime('%Y-%m-%d')
            title = title.replace('today', '').replace('Today', '').strip()
        else:
            date = datetime.now().strftime('%Y-%m-%d')
        
        events.append({
            'title': title,
            'date': date,
            'time': event_time,
            'timestamp': int(time.time())
        })
        
        with open(self.CALENDAR_JSON, 'w') as f:
            json.dump(events, f, indent=2)
    
    def _calendar_get_all(self):
        if os.path.exists(self.CALENDAR_JSON):
            # amazonq-ignore-next-line
            with open(self.CALENDAR_JSON, 'r') as f:
                return json.load(f)
        return []
    
    def _ai_generate(self, prompt: str) -> str:
        try:
            if self.ai_provider == 'groq':
                response = self.groq_client.chat.completions.create(
                    messages=[{"role": "user", "content": prompt}],
                    model="llama-3.1-8b-instant"
                )
                return response.choices[0].message.content.strip()
            else:
                response = self.gemini_model.generate_content(prompt)
                return response.text.strip()
        except Exception as e:
            return f"AI generation error: {str(e)}"
    
    # VOICE-ACTIVATED ADVANCED FEATURES
    
    # System Monitoring
    def system_monitor_dashboard_live(self):
        try:
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            cpu = psutil.cpu_percent(interval=1)
            memory = psutil.virtual_memory()
            # amazonq-ignore-next-line
            disk = psutil.disk_usage('C:')
            
            processes = []
            for proc in psutil.process_iter(['pid', 'name', 'cpu_percent']):
                try:
                    processes.append(proc.info)
                # amazonq-ignore-next-line
                except:
                    continue
            
            top_processes = sorted(processes, key=lambda x: x['cpu_percent'] or 0, reverse=True)[:5]
            
            report = f"SYSTEM MONITOR LIVE:\\n"
            report += f"CPU: {cpu}%\\n"
            report += f"RAM: {memory.percent}% ({memory.used//1024//1024}MB/{memory.total//1024//1024}MB)\\n"
            report += f"Disk: {disk.used//1024//1024//1024}GB/{disk.total//1024//1024//1024}GB\\n"
            report += f"\\nTop CPU Processes:\\n"
            
            for proc in top_processes:
                if proc['cpu_percent']:
                    report += f"- {proc['name']}: {proc['cpu_percent']:.1f}% CPU\\n"
            
            return report
        except Exception as e:
            return f"System monitoring error: {str(e)}"
    
    def auto_fix_system_basic(self):
        try:
            fixes = []
            
            # amazonq-ignore-next-line
            disk = psutil.disk_usage('C:')
            if disk.free < 1024**3:
                fixes.append("Low disk space detected")
            
            memory = psutil.virtual_memory()
            if memory.percent > 90:
                fixes.append("High memory usage detected")
            
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            cpu = psutil.cpu_percent(interval=2)
            if cpu > 90:
                fixes.append("High CPU usage detected")
            
            try:
                temp_folder = os.environ.get('TEMP')
                if temp_folder:
                    temp_files = len([f for f in os.listdir(temp_folder) if os.path.isfile(os.path.join(temp_folder, f))])
                    if temp_files > 100:
                        fixes.append(f"Found {temp_files} temp files for cleanup")
            # amazonq-ignore-next-line
            except:
                pass
            
            if fixes:
                return f"System issues found:\\n" + "\\n".join([f"- {fix}" for fix in fixes])
            else:
                return "System check complete - no issues found"
        except Exception as e:
            return f"Auto-fix error: {str(e)}"
    
    # Package Management
    def install_package(self, package_name=""):
        try:
            if not package_name:
                return "Please specify package name. Say: 'install package numpy'"
            # amazonq-ignore-next-line
            result = subprocess.run(["pip", "install", package_name], capture_output=True, text=True)
            if result.returncode == 0:
                # amazonq-ignore-next-line
                return f"Successfully installed {package_name}"
            else:
                # amazonq-ignore-next-line
                return f"Failed to install {package_name}: {result.stderr}"
        except Exception as e:
            return f"Package installation error: {str(e)}"
    
    def list_packages(self):
        try:
            # amazonq-ignore-next-line
            result = subprocess.run(["pip", "list"], capture_output=True, text=True)
            if result.returncode == 0:
                # amazonq-ignore-next-line
                lines = result.stdout.split('\\n')[:10]
                return f"Installed packages:\\n" + "\\n".join(lines)
            else:
                return "Failed to list packages"
        except Exception as e:
            return f"Package listing error: {str(e)}"
    
    def uninstall_package(self, package_name=""):
        try:
            if not package_name:
                return "Please specify package name to uninstall"
            # amazonq-ignore-next-line
            result = subprocess.run(["pip", "uninstall", package_name, "-y"], capture_output=True, text=True)
            if result.returncode == 0:
                # amazonq-ignore-next-line
                return f"Successfully uninstalled {package_name}"
            else:
                # amazonq-ignore-next-line
                return f"Failed to uninstall {package_name}"
        except Exception as e:
            return f"Package uninstall error: {str(e)}"
    
    def manage_package_help(self):
        return "Package management available. Say: 'install package [name]', 'list packages', or 'uninstall package [name]'"
    
    # Memory & Context
    def context_memory_store(self, key="general", value="memory stored"):
        self._memory_set(key, value)
        # amazonq-ignore-next-line
        # amazonq-ignore-next-line
        # amazonq-ignore-next-line
        return f"Stored memory under '{key}': {value}"

    def context_memory_recall(self, key=None):
        if key:
            vals = self._memory_get_all(key)
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            return vals[0] if vals else "No memory found"
        
  
        self._ensure_db()
        # amazonq-ignore-next-line
        conn = sqlite3.connect(self.MEMORY_DB)
        # amazonq-ignore-next-line
        c = conn.cursor()
        c.execute("SELECT key, value FROM memory ORDER BY ts DESC LIMIT 10")
        rows = c.fetchall()
        conn.close()
        
        if rows:
            memories = []
            for key, value in rows:
                try:
                    data = json.loads(value)
                    memories.append(f"{key}: {data}")
                except:
                    memories.append(f"{key}: {value}")
            return "\n".join(memories)
        return "No memories stored"

    def daily_briefing(self):
        briefing = {}
        # amazonq-ignore-next-line
        briefing["datetime"] = datetime.now().isoformat()
        
        try:
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            cpu = psutil.cpu_percent(interval=0.5)
            ram = psutil.virtual_memory().percent
            # amazonq-ignore-next-line
            batt = None
            if psutil.sensors_battery():
                batt = psutil.sensors_battery().percent
            briefing["system"] = {"cpu_percent": cpu, "ram_percent": ram, "battery_percent": batt}
        # amazonq-ignore-next-line
        except:
            briefing["system"] = {"cpu_percent": None, "ram_percent": None, "battery_percent": None}
        
        briefing["weather"] = {"note": "Weather API not configured"}
        briefing["calendar_upcoming"] = []
        briefing["unread_emails"] = {"note": "Email integration not configured"}
        
        return briefing
    
    # Calendar & Scheduling
    def calendar_schedule(self, event_data=""):
        if not event_data:
            return "No event specified"
        
        title = event_data
        time_str = ""
        
        if ' at ' in event_data.lower():
            parts = event_data.split(' at ')
            title = parts[0].strip()
            time_part = parts[1].strip().lower()
            
            if 'pm' in time_part:
                hour = int(time_part.replace('pm', '').strip())
                if hour != 12:
                    hour += 12
                time_str = f"{hour:02d}:00"
            elif 'am' in time_part:
                hour = int(time_part.replace('am', '').strip())
                if hour == 12:
                    hour = 0
                time_str = f"{hour:02d}:00"
        
        self._calendar_add_advanced(title, time_str)
        return f"Scheduled: {title} at {time_str}"
    
    def show_calendar(self):
        events = self._calendar_get_all()
        if not events:
            return "No events scheduled"
        
        today = datetime.now().strftime('%Y-%m-%d')
        tomorrow = (datetime.now() + timedelta(days=1)).strftime('%Y-%m-%d')
        
        today_events = []
        tomorrow_events = []
        other_events = []
        
        for event in events:
            event_date = event.get('date', today)  # Default to today if no date
            if event_date == today:
                today_events.append(event)
            elif event_date == tomorrow:
                tomorrow_events.append(event)
            else:
                other_events.append(event)
        
        result = ""
        if today_events:
            result += "TODAY:\n"
            for event in today_events:
                time = event.get('time', '')
                if time:
                    result += f"- {event['title']} at {time}\n"
                else:
                    result += f"- {event['title']}\n"
        
        if tomorrow_events:
            result += "\nTOMORROW:\n"
            for event in tomorrow_events:
                time = event.get('time', '')
                if time:
                    result += f"- {event['title']} at {time}\n"
                else:
                    result += f"- {event['title']}\n"
        
        if other_events:
            result += "\nOTHER DATES:\n"
            for event in other_events:
                time = event.get('time', '')
                event_date = event.get('date', 'Unknown date')
                if time:
                    result += f"- {event['title']} on {event_date} at {time}\n"
                else:
                    result += f"- {event['title']} on {event_date}\n"
        
        return result.strip()
    
    # Email & Communication
    def email_summarize(self, email_content=""):
        try:
            if not email_content:
                return "Please provide email content. Say: 'summarize email [your email content here]'"
            
            # amazonq-ignore-next-line
            prompt = f"Summarize this email in 3 key points: {email_content}"
            summary = self._ai_generate(prompt)
            # amazonq-ignore-next-line
            return f"Email Summary:\\n{summary}"
        except Exception as e:
            return f"Email summarization failed: {str(e)}"
    
    # Device & Cloud
    def sync_across_devices(self):
        try:
            calendar_data = self._calendar_get_all()
            memories = self.context_memory_recall()
            
            sync_data = {
                "calendar_events": len(calendar_data),
                # amazonq-ignore-next-line
                "memory_entries": len(memories) if isinstance(memories, dict) else 0,
                "last_sync": datetime.now().isoformat(),
                "device_id": socket.gethostname()
            }
            
            sync_file = os.path.join(os.path.dirname(self.USAGE_LOG), "device_sync.json")
            with open(sync_file, 'w') as f:
                json.dump(sync_data, f, indent=2)
            
            return f"Device sync completed: {sync_data['calendar_events']} events, {sync_data['memory_entries']} memories synced"
        except Exception as e:
            return f"Device sync failed: {str(e)}"
    
    # amazonq-ignore-next-line
    def cloud_backup_manager(self):
        return "Cloud backup feature available - files can be backed up to cloud storage"
    
    # AI Productivity
    def realtime_transcription(self):
        try:
            # Create transcription file
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"transcription_{timestamp}.txt"
            
            # Start Windows Speech Recognition
            # amazonq-ignore-next-line
            subprocess.run('start ms-speech-recognition:', shell=True)
            
            # Create empty file for transcription
            # amazonq-ignore-next-line
            with open(filename, 'w') as f:
                f.write(f"Transcription started at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write("Speak now - text will appear here...\n\n")
            
            # Store in memory
            self._memory_set("transcription_file", filename)
            
            return f"Transcription started - File: {filename} | Windows Speech Recognition opened"
            
        except Exception as e:
            return f"Transcription error: {str(e)}"
    
    def summarize_meeting(self, meeting_text=""):
        try:
            if not meeting_text:
                return "Please provide meeting content to summarize"
            
            prompt = f"Summarize this meeting in key points: {meeting_text}"
            # amazonq-ignore-next-line
            return self._ai_generate(prompt)
        except Exception as e:
            return f"Meeting summary error: {str(e)}"
    
    def smart_clipboard_store(self, content=""):
        try:
            if content:
                self._memory_set("clipboard", content)
                # amazonq-ignore-next-line
                return f"Stored in smart clipboard: {content[:50]}..."
            else:
                clipboard_data = self._memory_get_all("clipboard")
                if clipboard_data:
                    return f"Smart clipboard contains: {clipboard_data[0][:100]}..."
                return "Smart clipboard is empty"
        except Exception as e:
            return f"Smart clipboard error: {str(e)}"
    
    def document_assistant_qa(self, question="", document=""):
        try:
            if not question:
                return "Please ask a question about your document"
            
            # amazonq-ignore-next-line
            prompt = f"Answer this question about the document: {question}\\nDocument: {document[:500]}"
            return self._ai_generate(prompt)
        except Exception as e:
            return f"Document Q&A error: {str(e)}"
    
    def ai_presentation_maker(self, topic="", create_ppt=True, num_slides=5):
        try:
            if not topic:
                return "Please specify a presentation topic"
            
            if create_ppt:
                try:
                    from pptx import Presentation
                    from pptx.util import Inches, Pt

                    prs = Presentation()

                    # Title slide
                    title_slide_layout = prs.slide_layouts[0]
                    slide = prs.slides.add_slide(title_slide_layout)
                    slide.shapes.title.text = topic.title()
                    slide.placeholders[1].text = "AI Generated Presentation"

                    # Ask AI to generate bullet points for slides
                    prompt = (
                        f"Generate {num_slides} slide titles and bullet points for a presentation on '{topic}'.\n"
                        "Return in format:\n"
                        "Slide Title: \n"
                        "- bullet\n"
                        "- bullet\n"
                        "\n"
                    )

                    ai_response = self._ai_generate(prompt)
                    sections = ai_response.strip().split("\n\n")

                    # Use Title and Content slide layout
                    content_layout = prs.slide_layouts[1]

                    for sec in sections[:num_slides]:
                        lines = sec.split("\n")
                        if len(lines) < 2:
                            continue

                        slide_title = lines[0].replace("Slide Title:", "").strip()
                        slide = prs.slides.add_slide(content_layout)
                        slide.shapes.title.text = slide_title

                        bullet_box = slide.shapes.placeholders[1].text_frame
                        bullet_box.text = lines[1].lstrip("- ").strip()

                        for bullet in lines[2:]:
                            p = bullet_box.add_paragraph()
                            p.text = bullet.lstrip("- ").strip()
                            p.level = 1

                    filename = f"{topic.replace(' ', '_')}_presentation.pptx"
                    prs.save(filename)

                    return f"‚úÖ Presentation created successfully: {filename}"

                except ImportError:
                    return "Install python-pptx to enable presentation creation"

            return "PowerPoint creation disabled"

        except Exception as e:
            return f"AI presentation error: {str(e)}"
    
    def ai_document_maker(self, doc_type="report", topic="", user_info="", num_pages=2):
        try:
            if not topic:
                return "Please specify document topic"

            try:
                from docx import Document
                from docx.shared import Pt, Inches
                from docx.enum.text import WD_ALIGN_PARAGRAPH
                from docx.oxml.ns import qn

                doc = Document()

                # Title Style
                title = doc.add_heading(topic.title(), level=0)
                title.alignment = WD_ALIGN_PARAGRAPH.CENTER

                # Format Title Font
                title_run = title.runs[0]
                title_run.font.name = 'Calibri'
                title_run._element.rPr.rFonts.set(qn('w:eastAsia'), 'Calibri')
                title_run.font.size = Pt(28)
                title_run.bold = True

                # Build AI prompt (more structured output)
                prompt = (
                    f"Write a well-structured {doc_type} on the topic '{topic}'. "
                    f"Include these details: {user_info}. "
                    f"Document must include:\n"
                    f"1. Introduction\n"
                    f"2. Main content with multiple clear headings\n"
                    f"3. Conclusion\n"
                    f"Ensure the tone is formal and academic.\n"
                    f"Length: About {num_pages} pages.\n"
                    f"Do NOT use markdown (** **, ## , etc.). Only plain structured text."
                )

                content = self._ai_generate(prompt)

                # Split into paragraphs
                paragraphs = content.split('\n')

                for para in paragraphs:
                    para = para.strip()
                    if not para:
                        continue

                    # Detect headings
                    if len(para.split()) < 8:  # short lines = likely headings
                        heading = doc.add_heading(para, level=1)
                        heading.alignment = WD_ALIGN_PARAGRAPH.LEFT

                    else:
                        p = doc.add_paragraph(para)
                        p.style = doc.styles['Normal']
                        p.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY

                        # Improve paragraph readability
                        for run in p.runs:
                            run.font.name = 'Cambria'
                            run._element.rPr.rFonts.set(qn('w:eastAsia'), 'Cambria')
                            run.font.size = Pt(12)

                # Add ending spacing & clean page look
                doc.add_page_break()

                filename = f"{topic.replace(' ', '_')}_{doc_type}.docx"
                doc.save(filename)

                return f"‚úÖ Document created successfully: {filename}"

            except ImportError:
                return "Install python-docx to create Word documents"

        except Exception as e:
            return f"Document creation error: {str(e)}"

    # All other features with minimal implementations
    # amazonq-ignore-next-line
    def smart_home_control(self): return "Smart home control available"
    def set_home_scene(self): return "Home scene setting available"
    def security_camera_snapshot(self): return "Security camera available"
    def energy_monitoring_report(self): return "Energy monitoring available"
    def ai_dj_mode(self): return "AI DJ mode available"
    def trivia_game_start(self): return "Trivia game available"
    def code_agent(self, task="general coding help"):
        """AI-powered coding assistant"""
        try:
            if self.ai_provider == 'groq':
                response = self.groq_client.chat.completions.create(
                    model="llama-3.1-8b-instant",
                    messages=[{
                        "role": "user",
                        "content": f"Act as an expert software developer and coding assistant. Help with: {task}. Provide code examples, explanations, and best practices."
                    }]
                )
                code_help = response.choices[0].message.content
            else:
                code_help = self.gemini_model.generate_content(
                    f"Act as an expert software developer and coding assistant. Help with: {task}. Provide code examples, explanations, and best practices."
                ).text
            
            print(f"\nCode Agent Activated\n{code_help}")
            return code_help
        except Exception as e:
            return f"Code agent error: {e}"
    
    def research_agent(self, topic="general research"):
        """AI-powered research assistant"""
        try:
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            if self.ai_provider == 'groq':
                response = self.groq_client.chat.completions.create(
                    model="llama-3.1-8b-instant",
                    messages=[{
                        "role": "user",
                        "content": f"Act as a research assistant. Provide comprehensive research on: {topic}. Include key points, analysis, and relevant information."
                    }]
                )
                research = response.choices[0].message.content
            else:
                research = self.gemini_model.generate_content(
                    f"Act as a research assistant. Provide comprehensive research on: {topic}. Include key points, analysis, and relevant information."
                ).text
            
            print(f"\nResearch Agent Activated\n{research}")
            return research
        except Exception as e:
            return f"Research agent error: {e}"
    
    def debug_screen_code(self):
        """Capture screen and analyze visible code for errors"""
        try:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            screenshot_path = f"code_debug_{timestamp}.png"
            # amazonq-ignore-next-line
            screenshot = pyautogui.screenshot()
            screenshot.save(screenshot_path)
            
            # Try to get clipboard content first
            clipboard_text = ""
            try:
                import win32clipboard
                # amazonq-ignore-next-line
                win32clipboard.OpenClipboard()
                clipboard_text = win32clipboard.GetClipboardData()
                win32clipboard.CloseClipboard()
            # amazonq-ignore-next-line
            except:
                pass
            
            # If no clipboard content, ask user to provide code
            if not clipboard_text or len(clipboard_text.strip()) < 10:
                return f"\nScreen captured: {screenshot_path}\n\nTo analyze your code:\n1. Copy the code you want me to check\n2. Say 'debug screen' again\n\nOr tell me what specific error you're seeing."
            
            # Analyze the actual clipboard code
            prompt = f"""You are a code debugging expert. Analyze this code for errors, bugs, and improvements:

CODE TO ANALYZE:
{clipboard_text}

Provide:
1. ERRORS FOUND: List any syntax errors, logic errors, or bugs
2. CORRECTED CODE: Show the fixed version
3. EXPLANATION: Explain what was wrong and why the fix works
4. IMPROVEMENTS: Suggest any additional improvements

Be specific and accurate about the actual code provided."""
            
            if self.ai_provider == 'groq':
                response = self.groq_client.chat.completions.create(
                    model="llama-3.1-8b-instant",
                    messages=[{"role": "user", "content": prompt}]
                )
                analysis = response.choices[0].message.content
            else:
                analysis = self.gemini_model.generate_content(prompt).text
            
            result = f"\nCode Debug Analysis\nScreenshot saved: {screenshot_path}\n\nAnalyzing your code:\n{analysis}"
            print(result)
            return result
            
        except Exception as e:
            return f"Screen debug error: {e}"
    # amazonq-ignore-next-line
    def organizer_agent(self): return "Organizer agent available"
    def multi_agent_collab(self): return "Multi-agent collaboration available"
    
    # Web Intelligence Methods
    def scholar_search(self, query=""):
        """Search academic papers and scholarly content"""
        try:
            if not query:
                return "Please specify search query. Say: 'scholar search machine learning'"
            
            prompt = f"Provide academic research information about: {query}. Include key papers, concepts, and recent developments."
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            research = self._ai_generate(prompt)
            # amazonq-ignore-next-line
            return f"Scholar Search Results for '{query}':\n{research}"
        except Exception as e:
            return f"Scholar search error: {e}"
    
    def stock_updates(self, symbol=""):
        """Get stock market updates and analysis"""
        try:
            if symbol:
                prompt = f"Provide current stock analysis for {symbol}. Include price trends, market sentiment, and key factors."
            else:
                prompt = "Provide general stock market update. Include major indices, market trends, and key news."
            
            analysis = self._ai_generate(prompt)
            # amazonq-ignore-next-line
            return f"Stock Market Update:\n{analysis}"
        except Exception as e:
            return f"Stock updates error: {e}"
    
    def crypto_updates(self, coin=""):
        """Get cryptocurrency updates and analysis"""
        try:
            if coin:
                prompt = f"Provide cryptocurrency analysis for {coin}. Include price trends, market cap, and recent developments."
            else:
                prompt = "Provide general cryptocurrency market update. Include Bitcoin, Ethereum, and market trends."
            
            analysis = self._ai_generate(prompt)
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            return f"Crypto Market Update:\n{analysis}"
        except Exception as e:
            return f"Crypto updates error: {e}"
    
    def realtime_translation(self, text="", target_lang=""):
        """Translate text to different languages"""
        try:
            if not text:
                return "Please provide text to translate. Say: 'translate text hello world to spanish'"
            
            if not target_lang:
                target_lang = "Spanish"
            
            prompt = f"Translate this text to {target_lang}: {text}"
            translation = self._ai_generate(prompt)
            # amazonq-ignore-next-line
            return f"Translation to {target_lang}:\n{translation}"
        except Exception as e:
            return f"Translation error: {e}"
    # Health & Wellness Methods
    def posture_detection(self):
        """AI-powered posture analysis using webcam"""
        try:
            # Try to use webcam for actual posture detection
            try:
                import cv2
                import numpy as np
                
                # Initialize webcam
                # amazonq-ignore-next-line
                cap = cv2.VideoCapture(0)
                if not cap.isOpened():
                    return self._fallback_posture_advice()
                
                # Capture frame
                ret, frame = cap.read()
                cap.release()
                
                if not ret:
                    return self._fallback_posture_advice()
                
                # Save webcam image
                timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                image_path = f"posture_analysis_{timestamp}.jpg"
                cv2.imwrite(image_path, frame)
                
                # Basic posture analysis using image processing
                analysis = self._analyze_posture_from_image(frame)
                
                # Generate personalized advice based on analysis
                prompt = f"""Based on this posture analysis: {analysis}
                
                Provide specific posture improvement advice:
                1. CURRENT POSTURE ASSESSMENT: What needs improvement
                2. IMMEDIATE CORRECTIONS: Quick fixes for current posture
                3. EXERCISES: Targeted exercises for detected issues
                4. PREVENTION TIPS: How to maintain better posture
                
                Keep it personalized and actionable."""
                
                advice = self._ai_generate(prompt)
                
                # Store posture check in memory
                self._memory_set("posture_check", {
                    "timestamp": datetime.now().isoformat(),
                    "image_path": image_path,
                    "analysis": analysis,
                    "advice_given": True
                })
                
                result = f"\nPosture Analysis Complete\nWebcam image saved: {image_path}\nAnalysis: {analysis}\n\n{advice}"
                print(result)
                return result
                
            except ImportError:
                return self._fallback_posture_advice("OpenCV not installed. Install with: pip install opencv-python")
            # amazonq-ignore-next-line
            except Exception as e:
                return self._fallback_posture_advice(f"Webcam error: {e}")
                
        except Exception as e:
            return f"Posture detection error: {e}"
    
    def _analyze_posture_from_image(self, frame):
        """Basic posture analysis from webcam image"""
        try:
            import cv2
            import numpy as np
            
            # Convert to grayscale
            gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
            
            # Simple analysis based on image properties
            height, width = gray.shape
            
            # Analyze head position (top third of image)
            head_region = gray[:height//3, :]
            # amazonq-ignore-next-line
            head_center = np.mean(np.where(head_region < np.mean(head_region)))
            
            # Analyze shoulder level (middle third)
            shoulder_region = gray[height//3:2*height//3, :]
            
            # Basic posture assessment
            analysis = []
            
            # Check if head is centered
            # amazonq-ignore-next-line
            if head_center < width * 0.4 or head_center > width * 0.6:
                analysis.append("Head appears tilted - try to keep head centered")
            else:
                analysis.append("Head position looks good")
            
            # Check overall brightness (distance from camera)
            avg_brightness = np.mean(gray)
            if avg_brightness < 80:
                analysis.append("You appear to be leaning forward - sit back in your chair")
            elif avg_brightness > 180:
                analysis.append("Good distance from camera")
            else:
                analysis.append("Reasonable sitting distance")
            
            # Check for symmetry (shoulder level)
            left_shoulder = np.mean(shoulder_region[:, :width//2])
            right_shoulder = np.mean(shoulder_region[:, width//2:])
            
            if abs(left_shoulder - right_shoulder) > 20:
                analysis.append("Shoulders appear uneven - check your sitting position")
            else:
                analysis.append("Shoulder alignment looks balanced")
            
            return "; ".join(analysis)
            
        except Exception as e:
            return f"Basic visual analysis completed (detailed analysis unavailable: {e})"
    
    def _fallback_posture_advice(self, reason="Webcam not available"):
        """Fallback posture advice when webcam analysis fails"""
        prompt = """Act as a health and ergonomics expert. Provide comprehensive posture improvement guidance:
        
        1. POSTURE SELF-CHECK: How to assess your own posture right now
        2. COMMON ISSUES: Most frequent posture problems and quick fixes
        3. DESK EXERCISES: Simple exercises you can do at your workstation
        4. ERGONOMIC SETUP: Optimal workspace configuration
        5. DAILY HABITS: Posture-friendly habits to develop
        
        Make it practical and immediately actionable."""
        
        # amazonq-ignore-next-line
        # amazonq-ignore-next-line
        advice = self._ai_generate(prompt)
        
        result = f"\nPosture Check ({reason})\n\nSELF-ASSESSMENT GUIDE:\n{advice}\n\nTip: Sit up straight, shoulders back, feet flat on floor!"
        print(result)
        # amazonq-ignore-next-line
        # amazonq-ignore-next-line
        # amazonq-ignore-next-line
        # amazonq-ignore-next-line
        # amazonq-ignore-next-line
        # amazonq-ignore-next-line
        # amazonq-ignore-next-line
        # amazonq-ignore-next-line
        return result
    
    def eye_care_mode(self):
        """Eye care reminders and exercises"""
        try:
            prompt = """Act as an eye care specialist. Provide comprehensive eye care guidance:
            
            1. 20-20-20 RULE: Explain and remind about this important rule
            2. EYE EXERCISES: Simple exercises to reduce eye strain
            3. SCREEN SETTINGS: Optimal brightness, contrast, and blue light tips
            4. BREAK REMINDERS: When and how often to take eye breaks
            5. WARNING SIGNS: Symptoms that indicate eye strain
            
            Make it practical for computer users."""
            
            # amazonq-ignore-next-line
            eye_care = self._ai_generate(prompt)
            
            # Set eye care reminder
            self._memory_set("eye_care_reminder", {
                # amazonq-ignore-next-line
                "timestamp": datetime.now().isoformat(),
                "next_reminder": (datetime.now() + timedelta(minutes=20)).isoformat(),
                "rule_20_20_20": True
            })
            
            result = f"\nEye Care Mode Activated\n{eye_care}\n\nNext reminder set for 20 minutes."
            print(result)
            return result
            
        except Exception as e:
            return f"Eye care mode error: {e}"
    
    def daily_health_log(self, entry=""):
        """Track daily health metrics and habits"""
        try:
            today = datetime.now().strftime('%Y-%m-%d')
            
            if entry:
                # Log specific health entry
                self._memory_set(f"health_log_{today}", {
                    "date": today,
                    "entry": entry,
                    "timestamp": datetime.now().isoformat()
                })
                # amazonq-ignore-next-line
                # amazonq-ignore-next-line
                # amazonq-ignore-next-line
                # amazonq-ignore-next-line
                # amazonq-ignore-next-line
                # amazonq-ignore-next-line
                # amazonq-ignore-next-line
                # amazonq-ignore-next-line
                # amazonq-ignore-next-line
                # amazonq-ignore-next-line
                return f"Health log updated for {today}: {entry}"
            else:
                # Show health log summary
                recent_logs = []
                # amazonq-ignore-next-line
                for i in range(7):  # Last 7 days
                    date = (datetime.now() - timedelta(days=i)).strftime('%Y-%m-%d')
                    logs = self._memory_get_all(f"health_log_{date}")
                    if logs:
                        recent_logs.extend(logs)
                
                if recent_logs:
                    summary = "\nRecent Health Logs:\n"
                    for log in recent_logs[:5]:  # Show last 5 entries
                        summary += f"- {log['date']}: {log['entry']}\n"
                    return summary
                else:
                    # Generate health tracking prompt
                    prompt = """Provide a daily health tracking template with:
                    
                    1. METRICS TO TRACK: Key health indicators to monitor daily
                    2. QUESTIONS: Simple questions to assess daily wellness
                    3. HABITS: Healthy habits to track and maintain
                    4. MOOD: How to track emotional well-being
                    
                    Make it simple and quick to use daily."""
                    
                    template = self._ai_generate(prompt)
                    return f"\nDaily Health Log\n{template}\n\nSay 'health log [your entry]' to add an entry."
                    
        except Exception as e:
            return f"Health log error: {e}"
    
    def mood_tracker(self, mood=""):
        """Track and analyze mood patterns"""
        try:
            today = datetime.now().strftime('%Y-%m-%d')
            
            if mood:
                # Log mood entry
                mood_data = {
                    "date": today,
                    "mood": mood.lower(),
                    "timestamp": datetime.now().isoformat(),
                    "time_of_day": datetime.now().strftime('%H:%M')
                }
                
                # amazonq-ignore-next-line
                # amazonq-ignore-next-line
                # amazonq-ignore-next-line
                # amazonq-ignore-next-line
                # amazonq-ignore-next-line
                self._memory_set(f"mood_{today}", mood_data)
                
                # Generate mood response
                prompt = f"""Act as a wellness coach. Someone just reported feeling '{mood}'. Provide:
                
                1. ACKNOWLEDGMENT: Validate their feeling
                2. SUGGESTIONS: 2-3 practical tips to improve or maintain this mood
                3. ACTIVITIES: Specific activities that might help
                4. REMINDER: Positive affirmation or encouragement
                
                Keep it supportive and actionable."""
                
                response = self._ai_generate(prompt)
                # amazonq-ignore-next-line
                return f"\nMood logged: {mood}\n{response}"
            else:
                # Show mood analysis
                recent_moods = []
                for i in range(7):  # Last 7 days
                    date = (datetime.now() - timedelta(days=i)).strftime('%Y-%m-%d')
                    # amazonq-ignore-next-line
                    moods = self._memory_get_all(f"mood_{date}")
                    recent_moods.extend(moods)
                
                if recent_moods:
                    mood_list = [m['mood'] for m in recent_moods]
                    mood_summary = Counter(mood_list).most_common(3)
                    
                    analysis = "\nMood Analysis (Last 7 days):\n"
                    for mood, count in mood_summary:
                        analysis += f"- {mood.title()}: {count} times\n"
                    
                    # Generate insights
                    prompt = f"""Based on these recent moods: {mood_list}, provide:
                    
                    1. PATTERNS: Any patterns you notice
                    2. INSIGHTS: What this might indicate about well-being
                    3. RECOMMENDATIONS: Suggestions for mood improvement
                    
                    Be supportive and constructive."""
                    
                    insights = self._ai_generate(prompt)
                    return f"{analysis}\n{insights}"
                else:
                    return "\nMood Tracker\nNo mood entries yet. Say 'mood tracker happy' or 'track mood stressed' to start logging."
                    
        except Exception as e:
            return f"Mood tracker error: {e}"
    
    def meditation_prompt(self, duration="5"):
        """Guided meditation and mindfulness exercises"""
        try:
            # Parse duration
            try:
                minutes = int(duration)
            # amazonq-ignore-next-line
            except:
                minutes = 5
            
            prompt = f"""Act as a meditation guide. Create a {minutes}-minute guided meditation session:
            
            1. PREPARATION: How to get ready and comfortable
            2. BREATHING: Specific breathing techniques
            3. FOCUS: What to focus on during meditation
            4. GUIDANCE: Step-by-step instructions for the session
            5. CLOSING: How to gently end the session
            
            Make it calming, clear, and suitable for beginners."""
            
            meditation = self._ai_generate(prompt)
            
            # Log meditation session
            self._memory_set("meditation_session", {
                # amazonq-ignore-next-line
                "timestamp": datetime.now().isoformat(),
                "duration_minutes": minutes,
                "completed": True
            })
            
            result = f"\nMeditation Session ({minutes} minutes)\n{meditation}\n\nSession logged. Take your time and breathe deeply."
            print(result)
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            return result
            
        except Exception as e:
            return f"Meditation prompt error: {e}"
    # Security & Authentication Methods
    # amazonq-ignore-next-line
    # amazonq-ignore-next-line
    # amazonq-ignore-next-line
    # amazonq-ignore-next-line
    def file_vault_encrypt(self, file_path=""):
        """Encrypt files for security"""
        try:
            if not file_path:
                return "Please specify file path. Say: 'encrypt file C:\\path\\to\\file.txt'"
            
            if not os.path.exists(file_path):
                return f"File not found: {file_path}"
            
            # Simple encryption using base64 and password
            import base64
            # amazonq-ignore-next-line
            password = "jarvis_secure_key_2024"  # In real app, use user password
            
            with open(file_path, 'rb') as f:
                file_data = f.read()
            
            # Encrypt data
            encrypted_data = base64.b64encode(file_data)
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            encrypted_file = file_path + ".encrypted"
            
            with open(encrypted_file, 'wb') as f:
                f.write(encrypted_data)
            
            # Store encryption info
            self._memory_set("encrypted_files", {
                "original": file_path,
                "encrypted": encrypted_file,
                # amazonq-ignore-next-line
                "timestamp": datetime.now().isoformat()
            })
            
            return f"File encrypted successfully: {encrypted_file}"
            
        except Exception as e:
            return f"Encryption error: {e}"
    
    def file_vault_decrypt(self, encrypted_file=""):
        """Decrypt encrypted files"""
        try:
            if not encrypted_file:
                return "Please specify encrypted file path"
            
            if not os.path.exists(encrypted_file):
                return f"Encrypted file not found: {encrypted_file}"
            
            import base64
            
            with open(encrypted_file, 'rb') as f:
                encrypted_data = f.read()
            
            # Decrypt data
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            decrypted_data = base64.b64decode(encrypted_data)
            decrypted_file = encrypted_file.replace(".encrypted", "_decrypted")
            
            with open(decrypted_file, 'wb') as f:
                f.write(decrypted_data)
            
            return f"File decrypted successfully: {decrypted_file}"
            
        except Exception as e:
            return f"Decryption error: {e}"
    
    def anomaly_detection_recent_processes(self):
        """Scan for suspicious processes and system anomalies"""
        try:
            suspicious_processes = []
            high_cpu_processes = []
            
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # Check running processes
            # amazonq-ignore-next-line
            for proc in psutil.process_iter(['pid', 'name', 'cpu_percent', 'memory_percent']):
                try:
                    proc_info = proc.info
                    
                    # Check for high CPU usage
                    if proc_info['cpu_percent'] and proc_info['cpu_percent'] > 80:
                        high_cpu_processes.append(proc_info)
                    
                    # Check for suspicious process names
                    # amazonq-ignore-next-line
                    suspicious_names = ['keylogger', 'trojan', 'virus', 'malware', 'backdoor']
                    if any(sus in proc_info['name'].lower() for sus in suspicious_names):
                        suspicious_processes.append(proc_info)
                        
                # amazonq-ignore-next-line
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
            
            # Generate security report
            report = "\nSecurity Scan Results:\n"
            
            if suspicious_processes:
                report += f"WARNING: SUSPICIOUS PROCESSES FOUND ({len(suspicious_processes)}):\n"
                for proc in suspicious_processes:
                    report += f"- {proc['name']} (PID: {proc['pid']})\n"
            else:
                report += "OK: No suspicious processes detected\n"
            
            if high_cpu_processes:
                report += f"\nWARNING: HIGH CPU USAGE PROCESSES ({len(high_cpu_processes)}):\n"
                for proc in high_cpu_processes[:3]:  # Show top 3
                    report += f"- {proc['name']}: {proc['cpu_percent']:.1f}% CPU\n"
            
            # System health check
            cpu_avg = psutil.cpu_percent(interval=1)
            memory_usage = psutil.virtual_memory().percent
            
            report += f"\nSYSTEM HEALTH:\n"
            report += f"- CPU Usage: {cpu_avg}%\n"
            report += f"- Memory Usage: {memory_usage}%\n"
            
            if cpu_avg > 90 or memory_usage > 90:
                report += "WARNING: System resources critically high\n"
            elif cpu_avg > 70 or memory_usage > 80:
                report += "WARNING: System resources elevated\n"
            else:
                report += "OK: System resources normal\n"
            
            # Store scan results
            self._memory_set("security_scan", {
                # amazonq-ignore-next-line
                "timestamp": datetime.now().isoformat(),
                "suspicious_count": len(suspicious_processes),
                "high_cpu_count": len(high_cpu_processes),
                "system_health": "normal" if cpu_avg < 70 and memory_usage < 80 else "elevated"
            })
            
            return report
            
        except Exception as e:
            return f"Security scan error: {e}"
    
    # amazonq-ignore-next-line
    # amazonq-ignore-next-line
    def phishing_malware_scan_link(self, url=""):
        """Scan URLs for phishing and malware threats"""
        try:
            if not url:
                return "Please provide URL to scan. Say: 'phishing scan https://example.com'"
            
            # Basic URL analysis
            suspicious_indicators = []
            
            # Check for suspicious domains
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            suspicious_domains = ['bit.ly', 'tinyurl.com', 'short.link']
            if any(domain in url.lower() for domain in suspicious_domains):
                suspicious_indicators.append("Shortened URL detected")
            
            # amazonq-ignore-next-line
            # amazonq-ignore-next-line
            # Check for suspicious patterns
            # amazonq-ignore-next-line
            if url.count('.') > 4:
                suspicious_indicators.append("Excessive subdomains")
            
            if any(char in url for char in ['@', '%']):
                suspicious_indicators.append("Suspicious characters in URL")
            
            # Check for HTTPS
            if not url.startswith('https://'):
                suspicious_indicators.append("Not using secure HTTPS")
            
            # Generate scan report
            report = f"\nPhishing Scan Results for: {url}\n"
            
            if suspicious_indicators:
                report += f"WARNING: POTENTIAL RISKS DETECTED ({len(suspicious_indicators)}):\n"
                for indicator in suspicious_indicators:
                    report += f"- {indicator}\n"
                report += "\nRECOMMENDATION: Exercise caution before visiting this link\n"
            else:
                report += "OK: No obvious phishing indicators detected\n"
                report += "OK: URL appears to be safe\n"
            
            # Store scan results
            self._memory_set("phishing_scan", {
                "url": url,
                # amazonq-ignore-next-line
                "timestamp": datetime.now().isoformat(),
                "risk_level": "high" if len(suspicious_indicators) > 2 else "low",
                "indicators": suspicious_indicators
            })
            
            return report
            
        except Exception as e:
            return f"Phishing scan error: {e}"
    
    # amazonq-ignore-next-line
    def parental_control_set(self, action="status"):
        """Set up parental controls and content filtering"""
        try:
            if action == "status":
                # Check current parental control status
                controls = self._memory_get_all("parental_controls")
                if controls:
                    latest = controls[0]
                    # amazonq-ignore-next-line
                    return f"\nParental Controls Status:\n- Enabled: {latest.get('enabled', False)}\n- Content Filter: {latest.get('content_filter', 'Off')}\n- Time Restrictions: {latest.get('time_restrictions', 'None')}"
                else:
                    return "\nParental Controls: Not configured\nSay 'parental control enable' to set up"
            
            elif action == "enable":
                # Enable parental controls
                controls = {
                    "enabled": True,
                    # amazonq-ignore-next-line
                    "content_filter": "Moderate",
                    "time_restrictions": "School hours",
                    "blocked_sites": ["adult content", "gambling", "violence"],
                    # amazonq-ignore-next-line
                    "timestamp": datetime.now().isoformat()
                }
                
                self._memory_set("parental_controls", controls)
                
                # Generate setup guide
                prompt = """Provide parental control setup guidance:
                
                1. CONTENT FILTERING: How to set up safe browsing
                2. TIME RESTRICTIONS: Recommended screen time limits
                3. APP CONTROLS: Managing app access for children
                4. MONITORING: Safe ways to monitor child activity
                5. COMMUNICATION: How to talk to children about online safety
                
                Keep it practical and family-friendly."""
                
                guide = self._ai_generate(prompt)
                
                return f"\nParental Controls Enabled\n{guide}\n\nControls are now active for family safety."
            
            elif action == "disable":
                # Disable parental controls
                controls = {
                    "enabled": False,
                    "timestamp": datetime.now().isoformat()
                }
                
                self._memory_set("parental_controls", controls)
                return "Parental controls disabled"
            
            else:
                return "Available commands: 'parental control status', 'parental control enable', 'parental control disable'"
                
        except Exception as e:
            return f"Parental control error: {e}"
    # amazonq-ignore-next-line
    def predictive_assistance(self, auto_speak: bool = False):
        suggestions = []
        now = datetime.now()
        hour = now.hour
        
        if hour >= 22:
            suggestions.append("It's late - set a shutdown or power-save schedule?")
        elif hour >= 18:
            suggestions.append("Evening time - would you like to check your tasks for tomorrow?")
        elif hour >= 12:
            suggestions.append("Afternoon break - time for a quick stretch?")
        else:
            suggestions.append("Good morning - ready to start your productive day?")
        
        return suggestions
    
    def adaptive_learning(self, record_action: str = "general_action"):
        self._log_action_with_context(record_action)
        # amazonq-ignore-next-line
        return f"Learned: {record_action}"
    
    def _log_action_with_context(self, action_name: str):
        data = self._load_learning_memory()
        now = datetime.now()
        day = now.strftime("%A")
        hour = now.hour
        time_of_day = "morning" if hour < 12 else "afternoon" if hour < 18 else "evening"
        
        for act in data["actions"]:
            if (act["action"] == action_name and 
                act["context"]["day"] == day and 
                act["context"]["time_of_day"] == time_of_day):
                # amazonq-ignore-next-line
                act["count"] += 1
                act["last_used"] = now.isoformat()
                self._save_learning_memory(data)
                return
        
        data["actions"].append({
            "action": action_name,
            "count": 1,
            "last_used": now.isoformat(),
            "context": {
                "day": day,
                "hour": hour,
                "time_of_day": time_of_day
            }
        })
        self._save_learning_memory(data)
    
    def _load_learning_memory(self):
        learning_file = os.path.join(os.path.dirname(self.USAGE_LOG), "adaptive_memory.json")
        if os.path.exists(learning_file):
            try:
                with open(learning_file, "r", encoding='utf-8') as f:
                    return json.load(f)
            except (json.JSONDecodeError, IOError, OSError) as e:
                print(f"Error loading learning memory: {e}")
        return {"actions": []}
    
    def _save_learning_memory(self, data):
        try:
            learning_file = os.path.join(os.path.dirname(self.USAGE_LOG), "adaptive_memory.json")
            with open(learning_file, "w", encoding='utf-8') as f:
                json.dump(data, f, indent=2)
        except (IOError, OSError) as e:
            print(f"Error saving learning memory: {e}")
    
    def auto_suggest_with_popup(self):
        data = self._load_learning_memory()
        now = datetime.now()
        day = now.strftime("%A")
        hour = now.hour
        time_of_day = "morning" if hour < 12 else "afternoon" if hour < 18 else "evening"
        
        suggestions = []
        for act in data["actions"]:
            if (act["context"]["day"] == day and 
                act["context"]["hour"] == hour and
                act["context"]["time_of_day"] == time_of_day and
                act["count"] >= 2):
                suggestions.append((act["action"], act["count"]))
        
        suggestions.sort(key=lambda x: x[1], reverse=True)
        top_suggestions = [s[0] for s in suggestions[:3]]
        
        if top_suggestions:
            try:
                # Sanitize suggestion text to prevent injection
                safe_suggestions = [s.replace('"', '').replace("'", '') for s in top_suggestions[:2]]
                suggestion_text = f"You usually use: {', '.join(safe_suggestions)}"
                
                # Use safer PowerShell execution
                ps_command = [
                    'powershell', '-ExecutionPolicy', 'Bypass', '-Command',
                    f'Add-Type -AssemblyName System.Windows.Forms; '
                    f'[System.Windows.Forms.MessageBox]::Show("{suggestion_text}", "Jarvis Suggestions")'
                ]
                subprocess.run(ps_command, shell=False, timeout=5)
            except (subprocess.TimeoutExpired, subprocess.SubprocessError, OSError) as e:
                print(f"Notification error: {e}")
        
        return top_suggestions
    
    def enable_proactive_mode(self):
        self._memory_set('proactive_mode_enabled', True)
        return "Proactive mode enabled! Jarvis will automatically suggest actions based on your patterns."
    
    def disable_proactive_mode(self):
        self._memory_set('proactive_mode_enabled', False)
        return "Proactive mode disabled."
    
    def check_proactive_suggestions(self):
        enabled_data = self._memory_get_all('proactive_mode_enabled')
        if not enabled_data or not enabled_data[0]:
            return ""
        
        suggestions = self.auto_suggest_with_popup()
        if suggestions:
            top_action = suggestions[0]
            return f"Suggested: {top_action}"
        return ""
    
    def start_proactive_background(self):
        import threading
        import time
        
        def background_suggestions():
            while True:
                try:
                    enabled_data = self._memory_get_all('proactive_mode_enabled')
                    if enabled_data and enabled_data[0]:
                        now = datetime.now()
                        if 8 <= now.hour <= 22:
                            self.auto_suggest_with_popup()
                    time.sleep(1800)
                except:
                    time.sleep(1800)
        
        bg_thread = threading.Thread(target=background_suggestions, daemon=True)
        bg_thread.start()
        return "Proactive Jarvis started in background"
    
    def manual_learn(self, action: str = ""):
        if not action or not action.strip():
            return "Please specify what to learn. Say: 'manual learn system_monitor'"
        
        # Sanitize action input
        action = action.strip()[:100]  # Limit length
        
        try:
            self._log_action_with_context(action)
            return f"Manually learned: {action}. I'll remember this pattern for future suggestions."
        except Exception as e:
            return f"Error learning action: {str(e)}"
    def docker_control(self): return "Docker control available"
    
    # amazonq-ignore-next-line
    def execute_voice_command(self, command):
        """Execute voice command with multilingual support"""
        # Process multilingual commands first
        if self.multilingual:
            # Check if it's a language switching command
            if any(word in command.lower() for word in ['switch to', 'change language', '‡§≠‡§æ‡§∑‡§æ', '‡¶≠‡¶æ‡¶∑‡¶æ', '‡™≠‡™æ‡™∑‡™æ', '‡≤≠‡≤æ‡≤∑‡≥Ü', '‡¥≠‡¥æ‡¥∑', '‡§≠‡§æ‡§∑‡§æ', '‡ÆÆ‡Øä‡Æ¥‡Æø', '‡∞≠‡∞æ‡∞∑', 'ÿ≤ÿ®ÿßŸÜ']):
                return self.multilingual.process_multilingual_command(command)
            
            # Auto-detect language and process accordingly
            detected_lang = self.multilingual.detect_language(command)
            if detected_lang != 'english' and detected_lang != self.multilingual.current_language:
                self.multilingual.current_language = detected_lang
        
        command_lower = command.lower().strip()
        
        # Check for exact matches
        if command_lower in self.voice_functions:
            try:
                result = self.voice_functions[command_lower]()
                return result
            except Exception as e:
                # amazonq-ignore-next-line
                return f"Error executing {command_lower}: {str(e)}"
        
        # Check for partial matches
        for func_name in self.voice_functions.keys():
            if func_name in command_lower or command_lower in func_name:
                try:
                    result = self.voice_functions[func_name]()
                    return result
                except Exception as e:
                    return f"Error executing {func_name}: {str(e)}"
        
        # Handle dynamic commands
        if command_lower.startswith('remember this '):
            content = command_lower.replace('remember this ', '').strip()
            # Determine appropriate key based on content
            if 'laptop' in content:
                key = "laptop_info"
            elif 'dog' in content:
                key = "pet_info"
            elif 'car' in content:
                key = "vehicle_info"
            else:
                key = "personal_info"
            return self.context_memory_store(key, content)
        
        # Health & Wellness dynamic commands
        if command_lower.startswith('health log '):
            entry = command_lower.replace('health log ', '').strip()
            return self.daily_health_log(entry)
        
        if command_lower.startswith('mood tracker ') or command_lower.startswith('track mood '):
            mood = command_lower.replace('mood tracker ', '').replace('track mood ', '').strip()
            return self.mood_tracker(mood)
        
        if command_lower.startswith('meditate ') or command_lower.startswith('meditation '):
            duration = command_lower.replace('meditate ', '').replace('meditation ', '').strip()
            if duration and duration.isdigit():
                return self.meditation_prompt(duration)
            return self.meditation_prompt()
        
        if 'posture' in command_lower and ('check' in command_lower or 'analyze' in command_lower):
            return self.posture_detection()
        
        # Web Intelligence dynamic commands
        if command_lower.startswith('scholar search '):
            query = command_lower.replace('scholar search ', '').strip()
            return self.scholar_search(query)
        
        if command_lower.startswith('stock '):
            symbol = command_lower.replace('stock ', '').strip()
            return self.stock_updates(symbol)
        
        if command_lower.startswith('crypto '):
            coin = command_lower.replace('crypto ', '').strip()
            return self.crypto_updates(coin)
        
        if command_lower.startswith('translate '):
            # Parse "translate [text] to [language]"
            if ' to ' in command_lower:
                parts = command_lower.replace('translate ', '').split(' to ')
                text = parts[0].strip()
                target_lang = parts[1].strip()
                return self.realtime_translation(text, target_lang)
            else:
                text = command_lower.replace('translate ', '').strip()
                return self.realtime_translation(text)
        
        if command_lower.startswith('install '):
            package = command_lower.replace('install ', '').strip()
            return self.install_package(package)
        
        if command_lower.startswith('uninstall '):
            package = command_lower.replace('uninstall ', '').strip()
            return self.uninstall_package(package)
        
        # Security & Authentication dynamic commands
        if command_lower.startswith('encrypt file '):
            file_path = command_lower.replace('encrypt file ', '').strip()
            if file_path:
                return self.file_vault_encrypt(file_path)
            else:
                return "Please specify file path. Say: 'encrypt file C:\\path\\to\\file.txt'"
        
        if command_lower.startswith('decrypt file '):
            file_path = command_lower.replace('decrypt file ', '').strip()
            if file_path:
                return self.file_vault_decrypt(file_path)
            else:
                return "Please specify encrypted file path"
        
        if command_lower.startswith('phishing scan '):
            url = command_lower.replace('phishing scan ', '').strip()
            return self.phishing_malware_scan_link(url)
        
        if command_lower.startswith('parental control '):
            action = command_lower.replace('parental control ', '').strip()
            return self.parental_control_set(action)
        
        if command_lower.startswith('schedule event '):
            event = command_lower.replace('schedule event ', '').strip()
            return self.calendar_schedule(event)
        
        if command_lower.startswith('add event '):
            event = command_lower.replace('add event ', '').strip()
            return self.calendar_schedule(event)
        
        if command_lower.startswith('summarize email '):
            email_content = command_lower.replace('summarize email ', '').strip()
            return self.email_summarize(email_content)
        
        if command_lower.startswith('code help '):
            task = command_lower.replace('code help ', '').strip()
            return self.code_agent(task)
        
        if command_lower.startswith('research '):
            topic = command_lower.replace('research ', '').strip()
            return self.research_agent(topic)
        
        # Document creation dynamic commands
        if command_lower.startswith('create document '):
            topic = command_lower.replace('create document ', '').strip()
            return self.ai_document_maker("document", topic)
        
        if command_lower.startswith('create report '):
            topic = command_lower.replace('create report ', '').strip()
            return self.ai_document_maker("report", topic)
        
        if command_lower.startswith('create letter '):
            topic = command_lower.replace('create letter ', '').strip()
            return self.ai_document_maker("letter", topic)
        
        # Adaptive Learning dynamic commands
        if command_lower.startswith('adaptive learning '):
            action = command_lower.replace('adaptive learning ', '').strip()
            return self.adaptive_learning(action)
        
        if command_lower.startswith('manual learn '):
            action = command_lower.replace('manual learn ', '').strip()
            return self.manual_learn(action)
        
        if command_lower.startswith('teach jarvis '):
            action = command_lower.replace('teach jarvis ', '').strip()
            return self.manual_learn(action)
        
        # Handle any question about stored information
        if command_lower.startswith('what is my ') or 'what is' in command_lower or 'who is' in command_lower:
            memories = self.context_memory_recall()
            if memories and memories != "No memories stored":
                prompt = f"Based on these stored memories: {memories}\n\nAnswer this question: {command}"
                return self._ai_generate(prompt)
            return "I don't have any stored memories to answer that question"
        
        # Try multilingual processing as final fallback
        if self.multilingual:
            ml_response = self.multilingual.process_command_in_language(command, self.multilingual.current_language)
            if ml_response != self.multilingual.get_response('processing'):
                return ml_response
            return self.multilingual.get_response('not_understood')
        
        return "Voice command not recognized"

# Create instance
voice_advanced_ai = VoiceAdvancedAI()

def get_voice_advanced_response(command):
    # amazonq-ignore-next-line
    return voice_advanced_ai.execute_voice_command(command)  
import pyttsx3
import json
import os

class VoiceGenderControl:
    def __init__(self):
        self.config_file = "voice_config.json"
        self.current_gender = "male"
        self.load_config()
        
    def load_config(self):
        """Load voice configuration from file"""
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, 'r') as f:
                    config = json.load(f)
                    self.current_gender = config.get('gender', 'male')
        except:
            self.current_gender = "male"
    
    def save_config(self):
        """Save voice configuration to file"""
        try:
            config = {'gender': self.current_gender}
            with open(self.config_file, 'w') as f:
                json.dump(config, f)
        except:
            pass
    
    def get_available_voices(self):
        """Get available system voices"""
        try:
            engine = pyttsx3.init('sapi5')
            voices = engine.getProperty('voices')
            engine.stop()
            return voices
        except:
            return []
    
    def get_voice_by_gender(self, gender="male"):
        """Get voice ID by gender preference"""
        voices = self.get_available_voices()
        if not voices:
            return None
            
        male_voices = []
        female_voices = []
        
        for voice in voices:
            voice_name = voice.name.lower()
            # Common patterns for identifying voice gender
            if any(keyword in voice_name for keyword in ['david', 'mark', 'richard', 'male', 'man']):
                male_voices.append(voice.id)
            elif any(keyword in voice_name for keyword in ['zira', 'hazel', 'susan', 'female', 'woman']):
                female_voices.append(voice.id)
            else:
                # Default classification by index (usually 0=male, 1=female)
                if voices.index(voice) % 2 == 0:
                    male_voices.append(voice.id)
                else:
                    female_voices.append(voice.id)
        
        if gender == "female" and female_voices:
            return female_voices[0]
        elif gender == "male" and male_voices:
            return male_voices[0]
        else:
            # Fallback to first available voice
            return voices[0].id if voices else None
    
    def switch_to_male(self):
        """Switch to male voice"""
        self.current_gender = "male"
        self.save_config()
        return "Voice switched to male"
    
    def switch_to_female(self):
        """Switch to female voice"""
        self.current_gender = "female"
        self.save_config()
        return "Voice switched to female"
    
    def get_current_gender(self):
        """Get current voice gender"""
        return self.current_gender
    
    def speak_with_gender(self, text, gender=None):
        """Speak text with specified gender voice"""
        if gender is None:
            gender = self.current_gender
            
        try:
            engine = pyttsx3.init('sapi5')
            voice_id = self.get_voice_by_gender(gender)
            
            if voice_id:
                engine.setProperty('voice', voice_id)
            
            # Get voice settings from UI config
            try:
                import json
                with open('ui_config.json', 'r') as f:
                    ui_config = json.load(f)
                    
                # Set voice speed
                speed_settings = {'slow': 120, 'normal': 174, 'fast': 220}
                voice_speed = ui_config.get('voice_speed', 'normal')
                rate = speed_settings.get(voice_speed, 174)
                engine.setProperty('rate', rate)
                
                # Set voice volume
                volume_settings = {'low': 0.5, 'medium': 0.9, 'high': 1.0}
                voice_volume = ui_config.get('voice_volume', 'medium')
                volume = volume_settings.get(voice_volume, 0.9)
                engine.setProperty('volume', volume)
                
            except:
                # Fallback to default settings
                engine.setProperty('rate', 174)
                engine.setProperty('volume', 0.9)
            
            engine.say(text)
            engine.runAndWait()
            engine.stop()
            return True
        except Exception as e:
            print(f"Voice error: {e}")
            return False

# Global instance
voice_control = VoiceGenderControl()
